#!/bin/bash
# @(#) ================================================================================================================
# @(#) File        : ORArexec
# @(#) Author      : Marcel Pils
# @(#) Modified    :
# @(#)
# @(#) Description : This is a script for remote executions.
# @(#)               You can run any commands or scripts on remote servers oder databases.
# @(#)
# @(#) Version     : 1.3
# @(#) Date        : 05.07.2016
# @(#)
# @(#) Attention   : This script must be started as user ORACLE!
# @(#)
# @@(#) Change History:
# @@(#)
# @@(#) 1.0  10.10.2013  Pils   Created
# @@(#)
# @@(#) 1.1  17.12.2015  Thiel  Beruecksichtigung des Returncodes des db_scriptes
# @@(#) 1.2  17.12.2015  Thiel  Abbruch mit Warnhinweis bei leerer Targetliste
# @@(#) 1.3  05.07.2016  MPils  Pattern Suche auf AWK umgestellt und usage() Beispiele erweitert
# @(#) ================================================================================================================
#set -x
#set +x      #needed to hide passwords in shell variables from "set -x" bash execution (e.g. ControlM Logfile)

#-----------------------------------------------------------------------------------------------------------------
#     Global script environment
#-----------------------------------------------------------------------------------------------------------------
#MAILTO="unix-dba@barmenia.de"
#HOST=`hostname -s`
#LONGHOST=`hostname -f`
SCRIPTNAME=$(basename $0)
SCRIPTSHORTDESC="Executes a scripts on different servers or databases."
#LOGDIR="/app/logs"
#LOGFILE="${LOGDIR}/${SCRIPTNAME}_`date +%Y%m%d%H%M%S%N`.log"

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Help routine
#-----------------------------------------------------------------------------------------------------------------
function usage()
{
echo ""
echo "  Command     : ORArexec -pfile <target file> \ "
echo "                         -os \"linux|aix|all\" \ "
echo "                         -host \"<server grep pattern>\" | -db \"<db grep pattern>\" \ "
echo "                         -c \"<command string>\" | -script <script file> "
echo ""
echo "  Parameters  : -os,         {optional}  target os type"
echo "                -host,                   running remote on distinct host list"
echo "                -db,                     running remote on  db list"
echo "                -pfile,                  file with listed targets (host's/db's)"
echo "                -c|-command,             command string for remote execution"
echo "                -script,                 script for remote execution"
echo "                -p1,         {optional}  parameter for usage in script"
echo "                -showonly,   {optional}  don't execute ssh connection but shows it"
echo "                -h,          {optional}  help screen"
echo ""
echo "  Example     : ORArexec -host \"v5.*\" -os \"aix\" -pfile ./orahosts -script mybashscript"
echo "              : ORArexec -host \"lx.*\" -pfile ./orahosts -script mybashscript"
echo "              : ORArexec -host \"lxhjg\" -db \"ORA.*\" -pfile ./orahosts -script mybashscript"
echo "              : ORArexec -db \".*ora.*\" -pfile ./orahosts -script mybashscript"
echo ""
echo "  Attention   : This script must be started as user ORACLE"
echo "              : Please mind the '\"' around parameter values!"
echo "              : Search pattern are case insensitiv!"
echo "              : Awk regex syntax use '.*' as 'any string' wildcard!"
exit
}

#-----------------------------------------------------------------------------------------------------------------
#     Check if user is oracle, otherwise abort
#-----------------------------------------------------------------------------------------------------------------
if [ `id -un` != "oracle" ]; then
  echo "Script may not run as user `id -un`, it must be started and run as oracle"
  RC=255
  echo "Error Code: ${RC}"
  exit $RC
fi

#-----------------------------------------------------------------------------------------------------------------
#     Get Parameter
#-----------------------------------------------------------------------------------------------------------------
while true; do
  case "$1" in
    -os ) OS_PATTERN="$2";os=1; shift 2 ;;
    -host ) HOST_PATTERN="$2";host=1; shift 2 ;;
    -db ) DB_PATTERN="$2";db=1; shift 2 ;;
    -pfile ) PFILE="$2";pfile=1; shift 2 ;;
    -script ) SCRIPT="$2";script=1; shift 2 ;;
    -p1 ) P1="$2";p1=1; shift 2 ;;
    -c | -command ) COMMAND=$2;command=1; shift 2 ;;
    -showonly ) showonly=1; shift 1 ;;
    -h | --help ) usage ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

#-----------------------------------------------------------------------------------------------------------------
#     test to see if they gave the option
#-----------------------------------------------------------------------------------------------------------------
#if [ "x" != "x$host" ] && [ "x" != "x$db" ]; then
#  echo "-host and -db [options] can't be used together"; echo ""; usage
#fi
if [ "x" = "x$host" ] && [ "x" = "x$db" ]; then
  echo "-host or -db [option] is required"; echo ""; usage
fi
if [ "x" != "x$script" ] && [ "x" != "x$command" ]; then
  echo "-script and -c/-command [options] can't be used together"; echo ""; usage
fi
if [ "x" = "x$script" ] && [ "x" = "x$command" ]; then
  echo "-script or -c|-command [option] is required"; echo ""; usage
fi
if [ "x" = "x$pfile" ]; then
  echo "-pfile [option] is required"; echo ""; usage
fi


#-----------------------------------------------------------------------------------------------------------------
#     Set Environment
#-----------------------------------------------------------------------------------------------------------------
#ACTUALDIR=$PWD
#OS_PATTERN_LC=`echo $OS_PATTERN|tr 'A-Z' 'a-z'`
#HOST_PATTERN=$(echo $HOST_PATTERN|sed 's/*/.*/')
#DB_PATTERN=$(echo $DB_PATTERN|sed 's/*/.*/')

# append start and end signs for exact search pattern
OS_PATTERN=`echo "^$OS_PATTERN\$"`
DB_PATTERN=`echo "^$DB_PATTERN\$"`
HOST_PATTERN=`echo "^$HOST_PATTERN\$"`

#-----------------------------------------------------------------------------------------------------------------
#     Main program - start
#-----------------------------------------------------------------------------------------------------------------
TARGETS="cat ${PFILE}|grep -v '^#'"

# filter OS_PATTERN
if [ "x$os" = "x1" ]; then
  if [ "$OS_PATTERN_LC" = "all" ]; then 
    OS_PATTERN=".*"
  fi
  TARGETS="${TARGETS}|awk 'BEGIN{FS=\":\"};{IGNORECASE=1; if (\$1 ~ /${OS_PATTERN}/) print \$0}'"
fi

# filter HOST_PATTERN
if [ "x$host" = "x1" ]; then
  TARGETS="${TARGETS}|awk 'BEGIN{FS=\":\"};{IGNORECASE=1; if (\$2 ~ /${HOST_PATTERN}/) print \$0}'"
fi

# filter DB_PATTERN anf generate TARGET list
if [ "x$db" = "x1" ]; then
  TARGETS="${TARGETS}|awk 'BEGIN{FS=\":\"};{IGNORECASE=1; if (\$4 != \"-\" && \$4 ~ /${DB_PATTERN}/) print \$2\":\"\$4}'"
else
  TARGETS="${TARGETS}|awk 'BEGIN{FS=\":\"};{print \$2}'|sort -u"
fi

if [ $(bash -c "$TARGETS"|wc -l) -eq 0 ]
then
   echo
   echo "WARNUNG: Die Liste der Targets ist leer!"
   echo
   echo "exit ..."
   exit 1
fi

if [ "x$showonly" = "x1" ]; then
  echo "####### show only mode ########"
fi

for i in $(bash -c "$TARGETS"); do 
  echo $i|awk 'BEGIN{FS=":"};{print $1" "$2}'|while read REMHOST REMDB; do
    REMDB=$(echo $REMDB|tr "[:upper:]" "[:lower:]")
    if [ "x$command" = "x" ]; then
      CMD="ssh -q -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=3 $REMHOST 'bash -s' < '$SCRIPT' '$REMDB' '$P1'"
    else
      CMD="ssh -q -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=3 $REMHOST 'bash -c \"$COMMAND\"'"
    fi
    if [ "x$showonly" = "x1" ]; then
      echo $CMD
    else
      echo "==================================================="
      echo $(date +%Y%m%d.%H%M%S)": "$CMD
      echo "==================================================="
      bash -c "$CMD"
      RC=$?
      if [ $RC -ne 0 ]
      then
         echo "$i: Fehler bei $CMD"
      fi
    fi
  done
done

#cd $ACTUALDIR
#-----------------------------------------------------------------------------------------------------------------
#     Main program - end
#-----------------------------------------------------------------------------------------------------------------
exit

