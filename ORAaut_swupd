# @(#) ================================================================================================================
# @(#)  File        : ORAaut_swupd
# @(#)  Author      : Thorsten Thiel
# @(#)  Modified    : 
# @(#)
# @(#)  Description : This script does all the things described after
# @(#)                http://lxwiki.unix.lan/wiki_root/dokuwiki/dokumentationen/doku.php?id=datenbanken:oracle:oraautswupd
# @(#)
# @(#)  Version     : 4.7
# @(#)  Date        : 15.02.2023
# @(#)
# @(#)  Presumption : This script
# @(#)                1. must be started as user ORACLE
# @(#)
# @@(#)  Change History:
# @@(#)
# @@(#)    0.1  2016-10-24  Thiel       Created
# @@(#)    1.0  2016-10-28  Thiel       Version fue NON-DG -Umgebungen fertiggestellt
# @@(#)    1.1  2016-12-06  MPils       change_oratab fixed for database specified handling
# @@(#)    1.2  2016-12-15  Thiel       change rman configuration from
# @@(#)                                 OLD: CONFIGURE SNAPSHOT CONTROLFILE NAME TO '/app/oracle/product/12.1.0/db12102_160419/dbs/snapcf_${ORACLE_SID}.f';
# @@(#)                                 NEW: CONFIGURE SNAPSHOT CONTROLFILE NAME TO '/app/oracle/admin/dbhome/dbs/snapcf_${ORACLE_SID}.f';
# @@(#)    1.3  2016-12-19  Thiel       create checkmk blackouts during patch installation and revoke it afterwards
# @@(#)    1.4  2017-10-02  Thiel       change rman catalog from rcvcat to rcvcat-n when upgrading to 12102_170814
# @@(#)                                 stop listener only if it is running
# @@(#)                                 when upgrading to 12102_170814 and _optimizer_adaptive_plans=TRUE, backup spfile and create a new spfile without that parameter
# @@(#)    1.5  06.12.2017  Thiel       checkmk blackouts are not necessary now, but we have to blackout foglight
# @@(#)                                 created functions create_foglight_blackout/revoke_foglight_blackout
# @@(#)    1.6  08.12.2017  Thiel       function create_foglight_blackout cannot be invoked in functions stop_instance, as stop_instance has many invocations
# @@(#)    1.7  12.12.2017  Thiel	if instance runs with target version already exit with message and exitcode 0 (no error)
# @@(#)					added option -f to set foglight blackouts
# @@(#)                                 exit with error mesage if ORACLE_HOME is not set
# @@(#)    1.8  25.01.2018  MPils	changed pwddir location
# @@(#)    1.9  02.02.2018  Thiel       when actual ORACLE_HOME is 12102_171017 interims fix 22652097 must be rolled back
# @@(#)                                 additional message when rolling back interims patches
# @@(#)    2.0  14.03.2018  Thiel       added function set_fix_control
# @@(#)                                 added function exec_stat
# @@(#)    2.1  16.03.2018  Thiel       minor change in error check of function create_restore_point
# @@(#)    2.2  19.03.2018  Thiel       added function is_patch_installed, needs a patchnumber to proof
# @@(#)                                                                    returns 0 if patch is installed
# @@(#)                                                                    returns 1 if patch is NOT installed
# @@(#)                                                                    returns 2 if any error
# @@(#)    2.3  27.03.2019  Thiel       added function add_fix_controls
# @@(#)    2.4  23.07.2019  Thiel       when patching to db12102_190715 interims fix 27321179 has to be removed first
# @@(#)    2.5  05.08.2019  Thiel       build emcli commands to update enterprise manager information
# @@(#)    2.6  06.08.2019  Thiel       invoke function add_fix_controls on primary site only
# @@(#)    2.7  09.08.2019  Thiel       stop listener at the very beginning and kill all remote sessions
# @@(#)    2.8  13.08.2019  Thiel       need an option -on_agent to get emcli comands working for agent
# @@(#)    2.9  21.08.2019  Thiel       include ORAlib
# @@(#)    3.0  21.08.2019  Thiel       if NEW_HOME exists but is not listed in inventory; attach ORACLE_HOME
# @@(#)    3.1  30.01.2023  Thiel       upgrade mode isn't necessary
# @@(#)    3.2  30.01.2023  Thiel       maintain EM information
# @@(#)    3.3  30.01.2023  Thiel       we have to restart the instance from new ORACLE_HOME
# @@(#)    3.4  30.01.2023  Thiel       bouncing to normal mode not needed
# @@(#)    3.5  31.01.2023  Thiel       dba_registry_sqlpatch changed with 19c
# @@(#)    3.6  31.01.2023  Thiel       linesize has to be set, too
# @@(#)    3.7  01.02.2023  Thiel       added function set_compatible
# @@(#)    3.8  01.02.2023  Thiel       use correct syntax to set compatible parameter and instance restart is needed
# @@(#)    3.9  01.02.2023  Thiel       remove $SQLRESULT at valid place
# @@(#)    4.0  02.02.2023  Thiel       removed call of add_fixcontrols in invoke_datapatch
# @@(#)    4.1  02.02.2023  Thiel       create restore point when new ORACLE_HOME environment is active
# @@(#)    4.2  02.02.2023  Thiel       switch archivelog mode (and reset) if necessary
# @@(#)    4.3  02.02.2023  Thiel       reset to NOARCHIVELOGMODE
# @@(#)    4.4  02.02.2023  Thiel       better chronology in calling set_compatible and reset archivelog mode
# @@(#)    4.5  02.02.2023  Thiel       adding somehow lost stop_instance again
# @@(#)    4.6  09.02.2023  Thiel       avoid error messages when removing $SQLRESULT
# @@(#)    4.7  15.02.2023  Thiel       dealing with compatible parameter for standby sites
# @(#) ================================================================================================================

#-----------------------------------------------------------------------------------------------------------------
#     Global script environment
#-----------------------------------------------------------------------------------------------------------------
MAILTO="unix-dba@barmenia.de"
SENDER="unix-dba@barmenia.de"
HOST=`hostname -s`
LONGHOST=`hostname -f`
SCRIPTNAME=$(basename $0)
SCRIPTSHORTDESC="does all the things described at

                http://lxwiki.unix.lan/wiki_root/dokuwiki/dokumentationen/doku.php?id=datenbanken:oracle:oraautswupd
"
SCRIPTDIR=/app/oracle/bin
TEMPLATEDIR=/app/oracle/bin/templates/dbca
ORACLE_BASE="/app/oracle"
BINDIR="/app/oracle/bin"
TMPSQLOUT=/tmp/sql.out
DBSET="/app/oracle/bin/dbset"
BLACKOUT_CREATED=0
PWDDIR=/app/oracle/admin/etc/pwddir
EM_INFO_DIR=/oranfs/share/ora_admin/EM
EM_INFO_FILE=update_em_info.sh

source /app/oracle/bin/.bash_functions
RC=$?
if [ $RC -ne 0 ]; then
   echo ".bash_functions file not found!"
   exit $RC
fi

WHAT="/app/oracle/bin/what"
SCRIPTVERSION="`$WHAT /app/oracle/bin/$SCRIPTNAME|grep 'Version     :'|awk '{print $3,$4,$5}'`"
SCRIPTDATE="`$WHAT /app/oracle/bin/$SCRIPTNAME|grep 'Date        :'|awk '{print $3,$4,$5}'`"

Bmsg -m "# =============================================================================="
Bmsg -m "$SCRIPTNAME - $SCRIPTSHORTDESC"
Bmsg -m "# =============================================================================="
STARTTIME=`date +"%Y-%m-%d %k:%M:%S.%N"`
Bmsg -m "Start Time: $STARTTIME"

ORALIB=/app/oracle/bin/ORAlib
if [ ! -s "$ORALIB" ]
then
   echo
   echo "notwendige Bibliothek $ORALIB nicht vorhanden!"
   echo "exit ..."
   exit 1
fi
source $ORALIB
Logger

logger_info "$SCRIPTNAME gestartet"
LOGDATE=`date +"%Y%m%d"`
LOGFILE="/app/oracle/admin/log/${SCRIPTNAME}-${LOGDATE}.log"
Bmsg -bm "All actions are logged in $LOGFILE!"

#-----------------------------------------------------------------------------------------------------------------
#     Check if user is oracle, otherwise abort
#-----------------------------------------------------------------------------------------------------------------
ACTIVE_USER=`id -un`
if [ "$ACTIVE_USER" != "oracle" ]; then
  MESSAGE="Script may not run as user $ACTIVE_USER, it must be started and run as oracle"
  Bmsg -rm "$MESSAGE"
  logger_fatal "$MESSAGE"
  RC=255
  MESSAGE="Error Code: ${RC}"
  Bmsg -rm "$MESSAGE"
  logger_fatal "$MESSAGE"
  exit $RC
fi

#-----------------------------------------------------------------------------------------------------------------
#     START of FUNCTION SECTION
#-----------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Help routine
#-----------------------------------------------------------------------------------------------------------------
function usage()
{
if [ $help -eq 1 ]
then
   RC=0
else
   RC=1
fi
echo ""
echo "  Command     : $SCRIPTNAME $S_OS DBNAME $V_OS ORAVERSION [$F_OS] [$W_OS SECS] [$H_OS] "
echo "  Description : $SCRIPTSHORTDESC"
echo ""
echo "  Parameters  : $V_OPT,      define ORAVERSION"
echo "                $S_OPT,             define ORACLE_SID"
echo "                $F_OPT,             set Foglight Blackout"
echo "                $W_OPT,            define seconds to wait before really begin"
echo "                $H_OPT,                help screen"
echo ""
echo "  Example     : upgrade database KBAT to ORACLE version 12.1.0.2.5"
echo "                ${SCRIPTNAME} $S_OS KBAT $V_OS 121025"
echo ""
echo "  Attention   : This script must be started as user ORACLE"
echo ""
exit $RC
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: install software
#-----------------------------------------------------------------------------------------------------------------
function install_sw()
{
echo
MESSAGE="install oracle software"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
ORAclone_db -home $NEW_HOME
if [ $? -ne 0 ]
then
   echo
   MESSAGE="installation of oracle software failed!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check software installation
#-----------------------------------------------------------------------------------------------------------------
function check_sw()
{
INVLOC=`grep inventory_loc /etc/oraInst.loc|awk -F= '{print $2}'`
INVXML="${INVLOC}/ContentsXML/inventory.xml"
grep $NEW_HOME $INVXML >/dev/null
if [ $? -ne 0 ]
then
   echo
   MESSAGE="given ORACLE_HOME $NEW_HOME not registered in $INVXML!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
}


#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check domain
#-----------------------------------------------------------------------------------------------------------------
function check_domain()
{
if [ $# -ne 1 ]
then
   echo
   MESSAGE="function check_domain requires an parameter!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
CHECKHOST=$1
CHECKDOMAIN="barmenia.lan unix.lan"
for DOM in $CHECKDOMAIN
do
   echo $CHECKHOST|grep $DOM >/dev/null
   if [ $? -eq 0 ] # domain gefunden
   then
      return
   fi
done
echo
MESSAGE="the hostname provided lacks the domain!"
Bmsg -rm "$MESSAGE"
logger_error "$MESSAGE"
usage
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION check oracle error
#-----------------------------------------------------------------------------------------------------------------
chk_ora_err ()
{
if [ $IS_PRIMARY -eq 1 ] # single instance oder primary
then
   OERR=`grep "ORA-" $SQLRESULT`
else # standby side
   OERR=`grep "ORA-" $SQLRESULT|grep -v -e "ORA-01109" -e "ORA-16669"`
fi

if [ "$OERR" != "" ]
then
   RC=1
fi
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION check input of ORACLE_SID
#-----------------------------------------------------------------------------------------------------------------
function check_sid()
{
if [ ! -z $ORACLE_SID ]
then
   grep $ORACLE_SID /etc/oratab >/dev/null
   if [ $? -ne 0 ]
   then
      echo
      MESSAGE="ORACLE_SID >$ORACLE_SID< could not be found in /etc/oratab!"
      Bmsg -rm "$MESSAGE"
      logger_fatal "$MESSAGE"
      exit 1
   fi
else
   echo
   MESSAGE="you have to provide an ORACLE-SID!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION check input of WAITSECS 
#-----------------------------------------------------------------------------------------------------------------
function check_seconds()
{
CHECK=`expr $WAITSECS + 1 >/dev/null 2>&1`
if [ $? -ne 0 ]
then
   echo
   MESSAGE="key in a correct NUMBER!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION check running ORACLE version against target version
# vergleicht die eingegebene Zielversion mit der Version der laufenden Instanz zu der uebergebenen ORACLE_SID
#-----------------------------------------------------------------------------------------------------------------
function check_installed_version()
{
ACT_VERSION="$(basename $ORACLE_HOME|sed s/db//)"
SRCVERSPOS=`ORAclone_db -lv|grep -n $ACT_VERSION|awk -F: '{print $1}'`
if [ $SRCVERSPOS -eq $TGTVERSPOS ]
then
   MESSAGE="the oracle version you wish to upgrade to, is already active!
running version: $ACT_VERSION
 target version: $ORAVERSION"
   echo
   logger_info "$MESSAGE"
   exit 
elif [ $SRCVERSPOS -gt $TGTVERSPOS ]
then
   MESSAGE="the oracle version you wish to upgrade to, is lower than the active version!
running version: $ACT_VERSION
 target version: $ORAVERSION"
   echo
   logger_fatal "$MESSAGE"
   exit 1
fi
MAINACTVERS=`echo $ACT_VERSION|cut -b -2`  # 1. - 2. Stelle
#ausgehend von 11g-Installationen muss in der 11g-Umgebung zuerst preupgrade gestartet werden
#danach wird das ORACLE_HOME geswitched
#dann in der 12c-Umgebung mit startup upgrade gestartet
#dann datapatch aufgerufen ==>> noch alles zu tun
if [ $MAINACTVERS -eq 11 ]
then
   MESSAGE="this script isn't prepared to deal with 11g source versions, yet!"
   echo
   logger_fatal "$MESSAGE"
   exit 1
fi
return
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION check input of ORAVERSION 
# vergleicht die eingegebene Zielversion mit den fue ORAclone_db zur Verfüueng stehenden Imageversionen
#-----------------------------------------------------------------------------------------------------------------
function check_target_version()
{
VERSIONS=`ORAclone_db -lv`
if [ $? -ne 0 ]
then
   echo
   MESSAGE="could not retrieve available ORACLE versions!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
TGTVERSPOS=0
for VERS in $VERSIONS
do
   TGTVERSPOS=`expr $TGTVERSPOS + 1`
   if [ "$VERS" == "$ORAVERSION" ]
   then
      MAINVERS=`echo $VERS|cut -b -2`  # 1. - 2. Stelle
      MINORVERS=`echo $VERS|cut -b 3`  # 3. Stelle
      NEW_HOME="/app/oracle/product/${MAINVERS}.${MINORVERS}.0/db${VERS}"
      check_installed_version
      return
   fi
done
#keine passende Version gefunden
MESSAGE="no oracle clone image of version $ORAVERSION found!"
Bmsg -rm "$MESSAGE"
logger_error "$MESSAGE"
echo
MESSAGE="you may use >ORAclone_db -lv< to retrieve available versions"
Bmsg -bm "$MESSAGE"
logger_error "$MESSAGE"
exit 1
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION add fix_controls
#-----------------------------------------------------------------------------------------------------------------
function add_fix_controls()
{
echo
MESSAGE="add fix_controls"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
SQLRESULT=/tmp/result_sql6.lst
${ORACLE_HOME}/bin/sqlplus <<EOSQL >/dev/null
connect / as sysdba
set linesize 160
spool $SQLRESULT;
execute dbms_optim_bundle.enable_optim_fixes('ON','BOTH', 'YES');
exit;
EOSQL

chk_ora_err
if [ $RC -eq 1 ]
then
   echo
   MESSAGE="cannot ${MESSAGE}!"
   Bmsg -rm "$MESSAGE"
   logger_error "$MESSAGE"
else
   cat $SQLRESULT
fi
rm $SQLRESULT 2>/dev/null
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION set compatible
#-----------------------------------------------------------------------------------------------------------------
function set_compatible()
{
echo
MESSAGE="set compatible parameter"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
SQLRESULT=/tmp/result_sql7.lst
${ORACLE_HOME}/bin/sqlplus <<EOSQL >/dev/null
connect / as sysdba
set linesize 160
spool $SQLRESULT;
alter system set compatible='${compatible}' scope=spfile;
exit;
EOSQL

chk_ora_err
if [ $RC -eq 1 ]
then
   echo
   MESSAGE="cannot ${MESSAGE}!"
   Bmsg -rm "$MESSAGE"
   logger_error "$MESSAGE"
   rm $SQLRESULT 2>/dev/null
else
   cat $SQLRESULT
   rm $SQLRESULT 2>/dev/null
   if [ $reset_archivelog -eq 0 -a $IS_PRIMARY -eq 1 ] # archivelog Modus muss nicht auf NOARCHIVELOG zurueckgesetzt werden
#ansonsten erfolgt das Bouncen der Instanz beim Reset des archivelog Modus
   then
      MESSAGE="starting instance with new compatible parameter $compatible"
      Bmsg -gm "$MESSAGE"
      logger_info "$MESSAGE"
      stop_instance
      start_instance "startup"
   fi
fi
rm $SQLRESULT 2>/dev/null
}


#-----------------------------------------------------------------------------------------------------------------
# FUNCTION invoke datapatch
#-----------------------------------------------------------------------------------------------------------------
function invoke_datapatch()
{
Bmsg -1m "${SCRIPTNAME} - invoke datapatch"

MESSAGE="starting instance with new ORACLE_HOME"
Bmsg -gm "$MESSAGE"
start_instance "startup"

#Restore Point anlegen
create_restore_point

MESSAGE="execute datapatch"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
datapatch -verbose 2>&1 |tee /tmp/datapatch_$ORAVERSION #gibt es auswertbare Fehlermöglichkeiten?
###ERRORHANDLING!!!!
PATCHLOG=`cat /tmp/datapatch_$ORAVERSION|awk '/Log file for this invocation:/ {print $NF}'`
cat $PATCHLOG|grep -i -e error: -e "Prereq check failed" -e "exiting without installing any patches" >/dev/null
if [ $? -eq 0 ]
then
   MESSAGE="datapatch failed!
for more information have a look at $PATCHLOG"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
rm /tmp/datapatch_$ORAVERSION
###ERRORHANDLING!!!!

MESSAGE="show datapatch success"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
SQLRESULT=/tmp/result_sql2.lst
${ORACLE_HOME}/bin/sqlplus <<EOSQL >/dev/null
connect / as sysdba
set linesize 180;
col ACTION_TIME format a32;
col DESCRIPTION format a60;
spool $SQLRESULT;
select PATCH_ID, PATCH_UID, PATCH_TYPE, ACTION, STATUS, ACTION_TIME, DESCRIPTION from dba_registry_sqlpatch;
exit;
EOSQL

chk_ora_err
if [ $RC -eq 1 ]
then
   echo
   MESSAGE="cannot ${MESSAGE}!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
else
   cat $SQLRESULT
fi
rm $SQLRESULT 2>/dev/null
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION  determine ctrl-m environment
#-----------------------------------------------------------------------------------------------------------------
function det_ctm_env()
{
MESSAGE="determine ctrl-m environment"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
CTMCONFIG=/opt/ctm_ag/pcmag1/ctm/data/CONFIG.dat
if [ ! -s $CTMCONFIG ]
then
   MESSAGE="The CTRL-M environment is not defined correctly!"
   Bmsg -rm "$MESSAGE"
   logger_error "$MESSAGE"
   MESSAGE="The config file $CTMCONFIG does not exist!"
   Bmsg -rm "$MESSAGE"
   logger_error "$MESSAGE"
   return
else
   CTMENV=`grep HOST /opt/ctm_ag/pcmag1/ctm/data/CONFIG.dat|grep CTMSHOST|awk '{print $2}'|awk -F\. '{print $1}'`
fi
}
#-----------------------------------------------------------------------------------------------------------------
# FUNCTION  get newest oracle version available
#-----------------------------------------------------------------------------------------------------------------
function get_newest_ora_vers()
{
ORAVERSION=`ORAclone_db -lv|tail -1`
if [ $? -ne 0 ]
then
   echo
   MESSAGE="could not retrieve newest ORACLE version!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
check_target_version # hier wird u.a. NEW_HOME gesetzt!
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION  check inventory
#searches for $NEW_HOME in ORACLE inventory
#-----------------------------------------------------------------------------------------------------------------
function check_inventory()
{
INVPATH="$(grep inventory_loc /etc/oraInst.loc|awk -F= '{print $2}')/ContentsXML"
INVENTORY="$INVPATH/inventory.xml"
INVLINES=0
INVLINES=`grep $NEW_HOME $INVENTORY|grep -v REMOVED|wc -l`
if [ $INVLINES -ne 1 ]
then
   MESSAGE="ORACLE_HOME >$NEW_HOME< does not exist in ORACLE inventory >$INVENTORY<"
   Bmsg -bm "$MESSAGE"
   logger_info "$MESSAGE"
   missinv=1
fi
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION  check NEW_HOME directory
#-----------------------------------------------------------------------------------------------------------------
#compares $NEW_HOME  content and image content
function check_OH_content()
{
if [ ! -d $NEW_HOME ]
then
   MESSAGE="directory >$NEW_HOME< does not exist!"
   Bmsg -bm "$MESSAGE"
   logger_info "$MESSAGE"
   misscont=1
fi
#den Inhalt von NEW_HOME und dem IMAGE vergleichen
#IMGDIR="/app/oracle/software/clones/${MAINVERS}.${MINORVERS}.0/database"
#IMAGE="${IMGDIR}/db${ORAVERSION}.tgz"
#echo "IMAGE: $IMAGE#"
#for FILE in `tar ztvf $IMAGE|awk '{print $NF}'`
#do
#   find $NEW_HOME/.. -name $(basename $FILE)
#   if [ $? -ne 0 ]
#   then
#      misscont=1
#   fi
#done
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Check if DB is open
#-----------------------------------------------------------------------------------------------------------------
function get_db_values()
{
  Bmsg -1m "${SCRIPTNAME} - Get values from database"
  export ORACLE_HOME=${ORACLE_HOME}
  export ORACLE_SID=${ORACLE_SID}
  ${ORACLE_HOME}/bin/sqlplus -s /nolog <<EOSQL
  connect / as sysdba
  set serverout on size unlimited feedback off
  whenever sqlerror exit sql.sqlcode
  spool $TMPSQLOUT
  declare
    l_primary_mode   pls_integer  := 0;
    l_db_name        varchar2(20) := '';
    l_db_unique_name varchar2(20) := '';
    l_dg_broker      pls_integer  := 0;
    l_arc_log_mode   varchar2(20) := '';
  begin
    select case DATABASE_ROLE when 'PRIMARY' then 1 else 0 end,
           NAME,
           DB_UNIQUE_NAME,
           case DATAGUARD_BROKER when 'ENABLED' then 1 else 0 end,
           LOG_MODE
      into l_primary_mode,l_db_name,l_db_unique_name,l_dg_broker,l_arc_log_mode
      from v\$database;
    dbms_output.put_line('export IS_PRIMARY='||l_primary_mode);
    dbms_output.put_line('export DBNAME='||l_db_name);
    dbms_output.put_line('export DBUNAME='||l_db_unique_name);
    dbms_output.put_line('export DGUARD='||l_dg_broker);
    dbms_output.put_line('export ARCLOGMODE='||l_arc_log_mode);
  end;
/
EOSQL
  RC=$?
  if [ "$RC" -eq 0 ]; then
    source $TMPSQLOUT
  fi
  rm $TMPSQLOUT
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: create restore point
#-----------------------------------------------------------------------------------------------------------------
function create_restore_point()
{
Bmsg -1m "${SCRIPTNAME} - create restore point before_upgrade_${LOGDATE}"
export ORACLE_HOME=${ORACLE_HOME}
export ORACLE_SID=${ORACLE_SID}
${ORACLE_HOME}/bin/sqlplus -s /nolog <<EOSQL
connect / as sysdba
set serverout on size unlimited feedback on
whenever sqlerror exit sql.sqlcode
spool $TMPSQLOUT
create restore point before_upgrade_${LOGDATE}
GUARANTEE FLASHBACK DATABASE;
EOSQL
RC=$?
if [ $RC -ne 0 ]; then
   MESSAGE="restore point could not be created"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
rm $TMPSQLOUT
return
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: drop restore point
#-----------------------------------------------------------------------------------------------------------------
function drop_restore_point()
{
Bmsg -1m "${SCRIPTNAME} - drop restore point"
export ORACLE_HOME=${ORACLE_HOME}
export ORACLE_SID=${ORACLE_SID}
${ORACLE_HOME}/bin/sqlplus -s /nolog <<EOSQL
connect / as sysdba
set serverout on size unlimited feedback on
whenever sqlerror exit sql.sqlcode
spool $TMPSQLOUT
drop restore point before_upgrade_${LOGDATE};
EOSQL
RC=$?
if [ "$RC" -ne 0 ]; then
   MESSAGE="restore point could not be dropped"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
rm $TMPSQLOUT
return
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: stop instance
#-----------------------------------------------------------------------------------------------------------------
function stop_instance()
{
Bmsg -1m "${SCRIPTNAME} - stop instance"
export ORACLE_HOME=${ORACLE_HOME}
export ORACLE_SID=${ORACLE_SID}
SQLRESULT=/tmp/result_sql3.lst
${ORACLE_HOME}/bin/sqlplus -s /nolog <<EOSQL
connect / as sysdba
set serverout on size unlimited feedback off
spool $SQLRESULT
shutdown immediate;
exit;
EOSQL

chk_ora_err
if [ "$RC" -ne 0 ]; then
   MESSAGE="instance couldn't be stopped"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
rm $SQLRESULT 2>/dev/null
return
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: start instance
#-----------------------------------------------------------------------------------------------------------------
function start_instance()
{
STARTCMD=$1
MESSAGE="starting instance with: $STARTCMD"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
SQLRESULT=/tmp/result_sql1.lst
${ORACLE_HOME}/bin/sqlplus <<EOSQL >/dev/null
connect / as sysdba
spool $SQLRESULT;
$STARTCMD;
exit;
EOSQL

chk_ora_err
if [ $RC -eq 1 ]
then
   echo
   MESSAGE="$MESSAGE failed!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   MESSAGE=`cat $SQLRESULT`
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
rm $SQLRESULT 2>/dev/null
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: change oratab
#-----------------------------------------------------------------------------------------------------------------
function change_oratab()
{
Bmsg -1m "${SCRIPTNAME} - change oratab"
#cat /etc/oratab|sed s+"$ORACLE_HOME"+"$NEW_HOME"+ >/tmp/oratab
grep -v "^${ORACLE_SID}:" /etc/oratab >/tmp/oratab
grep "^${ORACLE_SID}:" /etc/oratab | sed s+"$ORACLE_HOME"+"$NEW_HOME"+ >>/tmp/oratab
cp /tmp/oratab /etc/oratab && rm /tmp/oratab
return
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: rollback patch
#-----------------------------------------------------------------------------------------------------------------
function rollback_patch()
{
PATCHID=$1
MESSAGE="${SCRIPTNAME} - rollback patch >$PATCHID<"
Bmsg -1m "$MESSAGE"
logger_info "$MESSAGE"

is_patch_installed $PATCHID
if [ $? -eq 1 ] # patch NOT installed
then
   return
fi

stop_instance

opatch rollback -id $PATCHID 2>&1 <<EOIN |tee /tmp/rbk_patch.out
y
EOIN
if [ $? -ne 0 ]
then
   MESSAGE="patch >$PATCHID< couldn't be rolled back!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
FAILURE=`grep "OPatch failed with error code" /tmp/rbk_patch.out`
if [ $? -eq 0 ]
then
   MESSAGE="opatch failed: $FAILURE"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi

rm /tmp/rbk_patch.out
invoke_datapatch
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: is_standby_patched
#-----------------------------------------------------------------------------------------------------------------
function is_standby_patched()
{
determine_standby
check_ssh_connectivity
check_stby_patch
return
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: determine_standby
#-----------------------------------------------------------------------------------------------------------------
function determine_standby()
{
if [ "${ORACLE_SID}_S1" == "$DBUNAME" ]
then
   STBY_HOST=`tnsping ${ORACLE_SID}_S2|grep DESCRIPTION|sed 's/.*HOST *= *//'|awk -F\) '{print $1}'`
else
   STBY_HOST=`tnsping ${ORACLE_SID}_S1|grep DESCRIPTION|sed 's/.*HOST *= *//'|awk -F\) '{print $1}'`
fi
return
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check_ssh_connectivity
#-----------------------------------------------------------------------------------------------------------------
check_ssh_connectivity()
#Diese Funktion prueft die SSH-Connectivity zu dem uebergebenen HOST
#durch die Verwendung von -o "StrictHostKeyChecking=no" -o "BatchMode=yes" wird zusaetzlich automatisch ein Eintrag in der known_hosts erzeugt,
#ohne das man die sonst obligatorische Frage nach dem Weitermachen mit yes beantworten muss
{
SSH_STATUS=`(ssh -q -o "StrictHostKeyChecking=no" -o "BatchMode=yes" -o "ConnectTimeout=3" $STBY_HOST "echo 2>&1" && echo SSH_OK || echo SSH_NOK)|tail -1`
if [ "$SSH_STATUS" != "SSH_OK" ]
then
   MESSAGE="Es besteht keine SSH-Vertrauensstellung zu >$STBY_HOST<"
   Bmsg -rl $LOGFILE -m "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check_stby_patch
#-----------------------------------------------------------------------------------------------------------------
check_stby_patch()
#ist auf dem standby host in der Datei /etc/oratab fuer die bearbeitete Instanz schon das neue ORACLE_HOME eingetragen,
#dann ist dort der Patch schon installiert
{
STBY_ORA_HOME=`ssh $STBY_HOST "grep $ORACLE_SID /etc/oratab" | awk -F: '{print $2}'`
if [ "$NEW_HOME" != "$STBY_ORA_HOME" ]
then
   MESSAGE="standby side >$STBY_HOST< isn't patched yet!
standby side still uses >$STBY_ORA_HOME<"
   Bmsg -rl $LOGFILE -m "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi
return
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: stop_listener
#-----------------------------------------------------------------------------------------------------------------
stop_listener()
{
Bmsg -1m "${SCRIPTNAME} - stop listener LISTENER_$ORACLE_SID"
lsnrctl stop LISTENER_$ORACLE_SID
if [ $? -ne 0 ]
then
   MESSAGE="LISTENER_$ORACLE_SID could not be stopped!
you should do it manually!!!"
   Bmsg -rl $LOGFILE -m "$MESSAGE"
   logger_error "$MESSAGE"
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check_running_listener
#-----------------------------------------------------------------------------------------------------------------
check_running_listener()
{
RL=`ps -ef|grep LISTENER_$ORACLE_SID|grep -v grep|wc -l`
return $RL
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: change_listenerora
#-----------------------------------------------------------------------------------------------------------------
change_listenerora()
{
Bmsg -1m "${SCRIPTNAME} - change listener.ora"
cp $TNS_ADMIN/listener.ora $TNS_ADMIN/listener.ora.old
cat $TNS_ADMIN/listener.ora|sed s+"$ORACLE_HOME"+"$NEW_HOME"+ >/tmp/listenerora
cp /tmp/listenerora $TNS_ADMIN/listener.ora && rm /tmp/listenerora
return
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: start_listener
#-----------------------------------------------------------------------------------------------------------------
start_listener()
{
Bmsg -1m "${SCRIPTNAME} - start listener LISTENER_$ORACLE_SID"
lsnrctl start LISTENER_$ORACLE_SID
if [ $? -ne 0 ]
then
   MESSAGE="LISTENER_$ORACLE_SID could not be started!
you should do it manually!!!"
   Bmsg -rl $LOGFILE -m "$MESSAGE"
   logger_error "$MESSAGE"
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: chg_rman_config
#-----------------------------------------------------------------------------------------------------------------
chg_rman_config()
{
Bmsg -1m "${SCRIPTNAME} - change RMAN configuration"
cat <<EORMAN >/tmp/chg_rman_$ORACLE_SID.cmd
CONFIGURE SNAPSHOT CONTROLFILE NAME TO '/app/oracle/admin/dbhome/dbs/snapcf_${ORACLE_SID}.f';
exit;
EORMAN
MESSAGE='RMAN configuration could not be changed!'
rman target / cmdfile=/tmp/chg_rman_$ORACLE_SID.cmd log=/tmp/chg_rman_$ORACLE_SID.log
if [ $? -ne 0 ]
then
   Bmsg -rl $LOGFILE -m "$MESSAGE"
   logger_error "$MESSAGE"
fi
rm /tmp/chg_rman_$ORACLE_SID.cmd 2>/dev/null
rm /tmp/chg_rman_$ORACLE_SID.log 2>/dev/null
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: chg_rmantab
#-----------------------------------------------------------------------------------------------------------------
chg_rmantab()
{
Bmsg -1m "${SCRIPTNAME} - change RMANTAB"
RMANTAB="${ORACLE_BASE}/admin/config/backup/rmantab"
RTAB=`grep "^${ORACLE_SID}:" ${RMANTAB}`
RMANUSER=`echo "${RTAB}"|cut -d: -f4`
RMANCAT=`echo "${RTAB}"|cut -d: -f3`
if [ "$RMANCAT" == "rcvcat" ]
then
   RMANCAT_N="rcvcat-n"
   RTAB_N=`echo $RTAB|sed s/":${RMANCAT}:"/":${RMANCAT_N}:"/`
   sed -i s/"$RTAB"/"$RTAB_N"/ $RMANTAB
   register_db
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: register_db
#-----------------------------------------------------------------------------------------------------------------
register_db()
{
Bmsg -1m "${SCRIPTNAME} - register database in catalog $RMANCAT_N"
cat <<EOCAT >${RMANCMD}
register database;
EOCAT
RMAN=$ORACLE_HOME/bin/rman
source $PWDDIR/.pwdfile_db_rman
RT=$($RMAN target / catalog $RMANUSER/$PWDRMAN@$RCVCAT_N cmdfile=$RMANCMD | echo $? )
if [ $RT -eq 0 ]
then
   Bmsg -1m "${SCRIPTNAME} - database in catalog $RMANCAT_N registered"
else
   Bmsg -1m "${SCRIPTNAME} - could NOT register database in catalog $RMANCAT_N!"
fi
return $RT
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: create_foglight_blackout
#-----------------------------------------------------------------------------------------------------------------
create_foglight_blackout()
{
Bmsg -1m  "${SCRIPTNAME}: create foglight blackout"
$SCRIPTDIR/ORAblackout -o start -t db -d $DBUNAME -m f
if [ $? -ne 0 ]
then
   MESSAGE='creating blackout in Foglight failed!'
   Bmsg -rl $LOGFILE -m "$MESSAGE"
#   logger_error "$MESSAGE"
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: create_checkmk_blackout
#-----------------------------------------------------------------------------------------------------------------
create_checkmk_blackout()
{
Bmsg -1m  "${SCRIPTNAME}: create checkmk blackout"
~/bin/sysmgt_cmk_deploy_api -o host_downtime -h $LONGHOST -m add -k '${BO_MESSAGE}' >/dev/null 2>&1
if [ $? -ne 0 ]
then
   MESSAGE='creating blackout in CheckMK failed!'
   Bmsg -rl $LOGFILE -m "$MESSAGE"
   logger_error "$MESSAGE"
fi
BLACKOUT_CREATED=1
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: revoke_foglight_blackout
#-----------------------------------------------------------------------------------------------------------------
revoke_foglight_blackout()
{
Bmsg -1m  "${SCRIPTNAME}: revoke foglight blackout"
$SCRIPTDIR/ORAblackout -o stop -t db -d $DBUNAME -m f
if [ $? -ne 0 ]
then
   MESSAGE='revoking blackout from Foglight failed!'
   Bmsg -rl $LOGFILE -m "$MESSAGE"
#   logger_error "$MESSAGE"
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: revoke_checkmk_blackout
#-----------------------------------------------------------------------------------------------------------------
revoke_checkmk_blackout()
{
Bmsg -1m  "${SCRIPTNAME}: revoke checkmk blackout"
~/bin/sysmgt_cmk_deploy_api -o host_downtime -h $LONGHOST -m del -k '${BO_MESSAGE}' >/dev/null 2>&1
if [ $? -ne 0 ]
then
   MESSAGE='revoking blackout in CheckMK failed!'
   Bmsg -rl $LOGFILE -m "$MESSAGE"
   logger_error "$MESSAGE"
fi
BLACKOUT_CREATED=0
}


#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check_opt_adapt_plan
#-----------------------------------------------------------------------------------------------------------------
check_opt_adapt_plan()
{
cp $ORACLE_HOME/dbs/spfile${ORACLE_SID}.ora $ORACLE_HOME/dbs/spfile${ORACLE_SIDa}.ora.bkp

MESSAGE="remove parameter _optimizer_adaptive_plans"
logger_info "$MESSAGE"
MESSAGE="create temporary pfile"
logger_info "$MESSAGE"
SQLRESULT=/tmp/result_sql4.lst
TMPPFILE="/tmp/init${ORACLE_SID}.ora"
CREATECMD="create pfile='$TMPPFILE' from spfile;"
${ORACLE_HOME}/bin/sqlplus <<EOSQL >/dev/null
connect / as sysdba
spool $SQLRESULT;
$CREATECMD
exit;
EOSQL

chk_ora_err
if [ $RC -eq 1 ]
then
   echo
   MESSAGE="$MESSAGE failed!"
   logger_fatal "$MESSAGE"
   MESSAGE=`cat $SQLRESULT`
   logger_fatal "$MESSAGE"
   exit 1
fi
rm $SQLRESULT 2>/dev/null

#check pfile
if [ ! -s $TMPPFILE ]
then
   MESSAGE="$MESSAGE OK! But it's empty!"
   logger_fatal "$MESSAGE"
   exit 1
fi

#remove parameter _optimizer_adaptive_plans
cat $TMPPFILE|grep -vi "_optimizer_adaptive_plans"  >/tmp/egal
mv /tmp/egal $TMPPFILE

stop_instance
start_instance "startup pfile='$TMPPFILE'"
MESSAGE="create new spfile"
logger_info "$MESSAGE"
SQLRESULT=/tmp/result_sql5.lst
TMPPFILE="/tmp/init${ORACLE_SID}.ora"
CREATECMD="create spfile from pfile='$TMPPFILE';"
${ORACLE_HOME}/bin/sqlplus <<EOSQL >/dev/null
connect / as sysdba
spool $SQLRESULT;
$CREATECMD
exit;
EOSQL

chk_ora_err
if [ $RC -eq 1 ]
then
   echo
   MESSAGE="$MESSAGE failed!"
   logger_fatal "$MESSAGE"
   MESSAGE=`cat $SQLRESULT`
   logger_fatal "$MESSAGE"
   exit 1
fi
rm $SQLRESULT 2>/dev/null
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION set fix_control
#-----------------------------------------------------------------------------------------------------------------
set_fix_control()
{
MESSAGE="FIX_CONTROL setzen!"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
SQLRESULT=/tmp/result_sql22.lst
${ORACLE_HOME}/bin/sqlplus <<EOSQL >/dev/null
connect / as sysdba
spool $SQLRESULT;
ALTER SYSTEM SET "_fix_control"='26664361:7','16732417:1','20243268:1' SCOPE=both;
exit;
EOSQL

chk_ora_err
if [ $RC -eq 1 ]
then
   echo
   MESSAGE="cannot ${MESSAGE}!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
else
   cat $SQLRESULT
fi
rm $SQLRESULT 2>/dev/null
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION exec statistics
#-----------------------------------------------------------------------------------------------------------------
exec_stat()
{
MESSAGE="EXECute STATs packages!"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
SQLRESULT=/tmp/result_sql23.lst
${ORACLE_HOME}/bin/sqlplus <<EOSQL >/dev/null
connect / as sysdba
spool $SQLRESULT;
@?/rdbms/admin/execstat.sql
exit;
EOSQL

chk_ora_err
if [ $RC -eq 1 ]
then
   echo
   MESSAGE="cannot ${MESSAGE}!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
else
   cat $SQLRESULT
fi
rm $SQLRESULT
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION is_patch_installed
#-----------------------------------------------------------------------------------------------------------------
function is_patch_installed()
{
   if [ $# -ne 1 ]
   then
      logger_debug "--------> Function is_patch_installed"
      logger_error "function needs a patchnumber!"
      return 2
   fi
   logger_debug "--------> Function is_patch_installed"
   PROOFNR=$1
   PATCHIDS=`opatch lsinventory|grep Patch|grep 'applied on'|awk '{print $2}'`
   for PNR in $PATCHIDS
   do
      if [ "$PROOFNR" == "$PNR" ]
      then
         return 0
      fi
   done
   return 1
}

#-----------------------------------------------------------------------------------------------------------------
# FUNCTION kill_rem_sess
#-----------------------------------------------------------------------------------------------------------------
function kill_rem_sess()
{
MESSAGE="kill remote sessions!"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
for SESS_PID in `ps -ef|grep LOCAL=NO|grep -v grep|awk '{print $2}'`
do
   kill -9 $SESS_PID
done
}

#-----------------------------------------------------------------------------------------------------------------
#     END of FUNCTION SECTION
#-----------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------
#     Get Parameter
#-----------------------------------------------------------------------------------------------------------------
V_OS="-v"; V_OL="--oraversion";   V_OPT="$V_OS[|$V_OL]"
S_OS="-s"; S_OL="--sid";          S_OPT="$S_OS[|$S_OL]"
F_OS="-f"; F_OL="--fgl";          F_OPT="$F_OS[|$F_OL]"
W_OS="-w"; W_OL="--wait";         W_OPT="$W_OS[|$W_OL]"
H_OS="-h"; H_OL="-?";             H_OPT="$H_OS[|$H_OL]"
help=0
if [ $# -eq 0 ]
then
   usage
else
   while [ $# -gt 0 ]; do
     case "$1" in
         $S_OS | $S_OL ) ORACLE_SID="$2"
                         ORACLE_SID=`echo $ORACLE_SID|tr [a-z] [A-Z]`
                         check_sid
                         . $DBSET $ORACLE_SID
                         sid=1
                         shift 2;;
         $V_OS | $V_OL ) ORAVERSION="$2"
                         check_target_version
                         vers=1
                         BO_MESSAGE="ORACLE_UPDATE_${ORAVERSION}"
                         shift 2;;
         $F_OS | $F_OL ) fglblkout=1;
                         shift 1;;
         $W_OS | $W_OL ) WAITSECS="$2"
                         check_seconds
                         wait=1
                         shift 2;;
         $H_OS | $H_OL ) help=1
                         usage;;
         * )             usage;;
     esac
   done
fi

#-----------------------------------------------------------------------------------------------------------------
#     Check if ORACLE_HOME is set
#-----------------------------------------------------------------------------------------------------------------
if [ -z $ORACLE_HOME ]
then
   MESSAGE="ORACLE_HOME is not set!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi

#-----------------------------------------------------------------------------------------------------------------
#     test to see if they gave the mandatory options
#-----------------------------------------------------------------------------------------------------------------
if [ "x" == "x$sid" ]; then
  MESSAGE="$S_OPT Option is required!"
  Bmsg -rm "$MESSAGE"
  logger_error "$MESSAGE"
  usage
fi
if [ "x" == "x$vers" ]; then
  MESSAGE="$V_OPT Option is required!"
  Bmsg -rm "$MESSAGE"
  logger_error "$MESSAGE"
  usage
fi

#set compatible according to RU
case $ORAVERSION in
    19000_230117 ) compatible='19.18.0.0';;
               * ) compatible='19.10.0.0';;
esac
#-----------------------------------------------------------------------------------------------------------------
#     evaluate conditional options
#-----------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------
#     some preliminary checks
#-----------------------------------------------------------------------------------------------------------------
check_inventory
check_OH_content

#to be commented out
echo "ORACLE_SID: $ORACLE_SID#"
echo "upgrade to version: $ORAVERSION"
echo "NEW_HOME: $NEW_HOME#"

if [ "x$missinv" == "x1" -o "x$misscont" == "x1" ]
then
   echo "ORACLE-Software installieren!"
fi
if [ "x$fglblkout" == "x1" ]
then
   echo "Foglight Blackout setzen!"
else
   echo "KEIN Foglight Blackout setzen!"
fi
echo
if [ "x1" == "x$wait" ]
then
   echo "in $WAITSECS Sekunden geht's weiter!"
   echo "oder CTRL-C druecken!"
   sleep $WAITSECS
fi
#to be commented out

#-----------------------------------------------------------------------------------------------------------------
#     Main program - start
#-----------------------------------------------------------------------------------------------------------------

if [ "x$missinv" == "x" -a "x$misscont" == "x1" ]
#NEW_HOME in Inventory aufgefuehrt, aber das Directory NEW_HOME gibt es nicht
then
   #Zeile mit NEW_HOME aus Inventory entfernen und Software installieren
   sed -i "/$(basename $NEW_HOME)/d" $INVENTORY
   install_sw 
elif [ "x$missinv" == "x1" -a "x$misscont" == "x" ]
#NEW_HOME NICHT in Inventory aufgefuehrt, aber das Directory NEW_HOME existiert
then
   MESSAGE="directory $NEW_HOME exists, but is not listed in ORACLE inventory!"
   Bmsg -bm "$MESSAGE"
   logger_info "$MESSAGE"
   attachOH $NEW_HOME
   if [ $? -ne 0 ]
   then
      MESSAGE="ORACLE_HOME >$NEW_HOME< konnte nicht attached werden!"
      Bmsg -rm "$MESSAGE"
      logger_error "exit ..."
      exit 1
   fi
elif [ "x$missinv" == "x1" -a "x$misscont" == "x1" ]
#NEW_HOME NICHT in Inventory aufgefuehrt, und das Directory NEW_HOME gibt es nicht
then
   install_sw
fi
if [ "x$fglblkout" == "x" ]
then
   fglblkout=0;
fi

#create foglight blackout
if [ $fglblkout -eq 1 ]
then
   create_foglight_blackout
fi

#auf DG-Umgebung pruefen
get_db_values
if [ $? -ne 0 ]
then
   MESSAGE="retrieving db values failed!"
   Bmsg -rm "$MESSAGE"
   logger_fatal "$MESSAGE"
   exit 1
fi

#evtl. archivelog mode aendern
reset_archivelog=0
if [ "$ARCLOGMODE" == 'NOARCHIVELOG' ]
then
   MESSAGE="Die Instanz befindet sich im $ARCLOGMODE Modus!"
   Bmsg -bm "$MESSAGE"
   MESSAGE="wird zu ARCHIVELOG geaendert!"
   Bmsg -bm "$MESSAGE"
   /app/oracle/bin/ORAarchlogMode -sid $ORACLE_SID -am ARCHIVELOGMODE
   if [ $? -ne 0 ] #arc1ogmode couldn't be switched
   then
      MESSAGE="Der ARCHIVELOG Modus konnte nicht geaendert werden!"
      Bmsg -bm "$MESSAGE"
      exit 1
   else
      reset_archivelog=1
   fi
fi

echo "IS_PRIMARY=$IS_PRIMARY"
echo "ORACLE_HOME=$ORACLE_HOME"

if [ $IS_PRIMARY -eq 1 ] # single instance oder primary
then
   #Listener anhalten
   check_running_listener
   if [ $? -eq 1 ]
   then
      stop_listener
   fi
   # alle remoten Sessions killen
   kill_rem_sess

   # abhaengig vom neuen Patchstand alte Patches zurueckrollen
   #OJVM-Patches entfernen
   if [ "$ORACLE_HOME" == "/app/oracle/product/12.1.0/db121023" ]
   then
      rollback_patch 20415564
   elif [ "$ORACLE_HOME" == "/app/oracle/product/12.1.0/db121024" ]
   then
      rollback_patch 21068507
   elif [ "$ORACLE_HOME" == "/app/oracle/product/12.1.0/db121025" ]
   then
      rollback_patch 21555660
   elif [ "$ORACLE_HOME" == "/app/oracle/product/12.1.0/db12102_160119" ]
   then
      rollback_patch 22139226
   elif [ "$ORACLE_HOME" == "/app/oracle/product/12.1.0/db12102_171017" ]
   then
      rollback_patch 22652097
   elif [ "$ORACLE_HOME" == "/app/oracle/product/12.1.0/db12102_190115" ]
   then
      rollback_patch 27321179
   fi

   #Restore Point anlegen, Aufruf von datapatch und Loeschen des Restore Points ist nur fuer single instances
   #bzw. primary databases notwendig
   #check, if patch is installed on standby side already
   if [ $DGUARD -eq 1 ] # dg primary instance
   then
      is_standby_patched
   fi
fi

if [ "$ORAVERSION" == "12102_170814" ]
then
   check_opt_adapt_plan
fi

#instanz anhalten
stop_instance

#oratab anpassen
change_oratab 

#Listener anhalten
check_running_listener
if [ $? -eq 1 ]
then
   stop_listener
fi
#listener.ora anpassen
change_listenerora

#Environment auf NEW_HOME umstellen
Bmsg -1m "${SCRIPTNAME} - change environment"
. $DBSET $ORACLE_SID
echo "PATH: $PATH"

if [ $IS_PRIMARY -eq 1 ] # single instance oder primary
then
   #patch durchfuehren
   invoke_datapatch

   #restore point entfernen
   drop_restore_point

   #compatible parameter setzen
   set_compatible

   if [ $reset_archivelog -eq 1 ] # archivelog modus auf NOARCHIVELOG zuruecksetzen
   then
      MESSAGE="set archivelog mode to NOARCHIVELOG"
      Bmsg -gm "$MESSAGE"
      /app/oracle/bin/ORAarchlogMode -sid $ORACLE_SID -am NOARCHIVELOGMODE
      if [ $? -ne 0 ] #arc1ogmode couldn't be switched
      then
         SUBJECT='Aenderung des ARCHIVELOG Modus'
         MESSAGE="Die $SUBJECT konnte nicht durchgefuehrt werden!"
         Bmsg -rm "$MESSAGE"
         TEXT="Hallo Kollegen,\nach dem Patchen konnte der archivelog mode nicht wieder auf NOARCHIVELOG geaendert werden!\n\nVielen Dank.\n\nGruss,\ndie DB-Admins\nTel. 3745\n"
         MAIL_TXT="Subject: $SUBJECT\nFrom: $SENDER\nTo: $MAILTO\n\n$TEXT"
         echo -e $MAIL_TXT | $SENDMAIL -t
         if [ $? -ne 0 ]
         then
            echo
            MESSAGE="Mail zur $SUBJECT konnte nicht versendet werden!"
            Bmsg -rm "$MESSAGE"
            logger_error "$MESSAGE"
         else
            echo
            MESSAGE="Mail zur $SUBJECT erfolgreich versandt"
            Bmsg -gm "$MESSAGE"
            logger_info "$MESSAGE"
         fi
      fi
   fi

   #RMAN catalog aktualisieren
   #  upgrade_catalog;

   #evtl. fix_controls setzen
   #und Stistiken neu bilden
   if [ "$ORAVERSION" == "12102_180116" ]
   then
      set_fix_control
      exec_stat
   fi

else # standby seite explizit starten
   start_instance "startup"

#compatible parameter setzen
   set_compatible

fi

#Listener starten
start_listener

#Foglight Blackout entfernen
if [ $fglblkout -eq 1 ]
then
   revoke_foglight_blackout
fi

#RMAN Konfig anpassen
chg_rman_config
if [ "$ORAVERSION" == "12102_170814" ]
then
   chg_rmantab
fi

#EnterpriseManager Homes pflegen
/app/oracle/bin/ORAmakeEMconfig -a upd -o $ORACLE_HOME

MESSAGE="Upgrade successfull!"
Bmsg -gm "$MESSAGE"
logger_info "$MESSAGE"
exit 0
