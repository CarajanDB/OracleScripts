#!/bin/bash
# @(#) ================================================================================================================
# @(#) File        : ORArotate_pwd
# @(#) Author      : Thorsten Thiel
# @(#)
# @(#) Version     : 2.2
# @(#) Date        : 09.04.2024
# @(#)
# @(#) Description : This script set the database password for a given account
# @(#)               In a dataguard environment the oracle password file $ORACLE_HOME/dbs/orapw${ORACLE_SID}
# @(#)               will be copied to the standby server
# @(#)
# @(#) Syntax      : ORArotate_pwd -h|account_name
# @(#)
# @(#) Attention   : This script must be started as user ORACLE
# @(#)
# @@(#) Change History:
# @@(#)
# @@(#) 1.0 10.12.2015 THI   Created
# @@(#)
# @@(#) 1.1 02.03.2016 THI   Ob DataGuard aktiv ist wird an einem enableten dataguard broker festgemacht!
# @@(#)                      NICHT an unterschiedlichem DBNAMEN und DBUNAMEN!
# @@(#)
# @@(#) 1.2 17.03.2016 THI   Im MAIN-Teil des Programmes wird die Function check_primary direkt nach
# @@(#)                      nach der Function check_instance ausgefuehrt. Ansonsten ist die Variable $DGUARD
# @@(#)                      noch nicht gesetzt.
# @@(#) 1.3 21.06.2016 THI   an account_name has to be provided
# @@(#)
# @@(#) 1.4 07.10.2016 THI   StrictHostKeyChecking=no eingefuehrt
# @@(#) 1.5 04.01.2017 MPils Sqlplus Output beim PWD Change nach DevNull umgelengt
# @@(#) 1.6 25.01.2018 MPils changed pwddir location
# @@(#) 1.7 02.10.2020 THI   no exit in function usage
# @@(#) 1.8 02.10.2020 THI   in case of erraneous parameters, we need log output, too
# @@(#) 1.9 07.07.2023 THI   changed error handling of function update_cmdb
# @@(#) 2.0 07.07.2023 THI   we have to use valid function name chk_ora_err
# @@(#) 2.1 07.07.2023 THI   give correct error message when update_cmdb fails
# @@(#) 2.2 09.04.2024 MPils Added "" for Oracle Password
# @(#) ================================================================================================================

#-----------------------------------------------------------------------------------------------------------------
#     Global script environment
#-----------------------------------------------------------------------------------------------------------------
LONGHOST=`hostname -f`
SCRIPTNAME=$(basename $0)
SCRIPTSHORTDESC="Set password for a given database account"
ORACLE_BASE="/app/oracle"
LOGDIR="/app/logs"
LOGFILE="${LOGDIR}/${SCRIPTNAME}_`date +%Y%m%d%H%M%S%N`.log"
SCRIPTPATH="/app/oracle/bin"
NFSPWDDIR="/oranfs/share/ora_admin/SYSTEM/pwddir"
PWDDIR="/app/oracle/admin/etc/pwddir"
source $NFSPWDDIR/.pwdfile_db_sys      #liefert die Variable PWDSYS
source $NFSPWDDIR/.pwdfile_db_bvcmdb   #liefert die Variable PWDBVCMDB

FUNCTIONSFILE="${SCRIPTPATH}/.bash_functions"
RC=0

source $FUNCTIONSFILE
RC=$?
if [ $RC -ne 0 ]; then
 echo "${FUNCTIONSFILE} file not found!"
 exit 1
fi

Bscriptstart "${SCRIPTNAME} - ${SCRIPTSHORTDESC}" |tee -a $LOGFILE

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Help routine
#-----------------------------------------------------------------------------------------------------------------
function usage()
{
echo ""
echo "  Command     : $SCRIPTNAME"
echo "  Description : $SCRIPTSHORTDESC"
echo ""
echo "  Parameters  : -sid,                     Database Name "
echo "                -acc                      Account Name"
echo "                -h,                       help screen"
echo ""
echo "  Example     : ORArotate_pwd -sid PAOP -acc system"
echo ""
echo "  Attention   : This script must be started as user ORACLE"
echo ""
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: exit routine
#-----------------------------------------------------------------------------------------------------------------
exit_script()
{
   Bmsg -b -m "Logfile written to $LOGFILE"
   Bscriptend
   exit $1
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check pwdfile exists
#-----------------------------------------------------------------------------------------------------------------
check_dbpwdfile()
{
if [ ! -s $DBPWDFILE ]
then
   Bmsg -rl $LOGFILE -m "ERR: file >$DBPWDFILE< does not exist!"
   Bmsg -rl $LOGFILE -m "ERR: will exit now!"
   exit_script 10
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check running instance
#-----------------------------------------------------------------------------------------------------------------
check_instance()
{
SMON=`ps -ef|grep -i smon|grep ${ORACLE_SID}|tail -1|awk '{print $NF}'`
if [ ! "$SMON" == "ora_smon_${ORACLE_SID}" ] # SMON nicht gefunden; Instanz laueft nicht
then
   grep ${ORACLE_SID} /app/oracle/inst_int_down >/dev/null 2>&1
   if [ $? -eq 0 ] # Instanz absichtlich aus
   then
      Bmsg -gl $LOGFILE -m "Die Instanz laueft nicht!"
      Bmsg -gl $LOGFILE -m "Die Instanz ist absichtlich aus!"
      exit_script 0
   else
      Bmsg -bl $LOGFILE -m "ERR: Die Instanz laueft nicht!"
      exit_script 0
   fi
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check db exists in oratab
#-----------------------------------------------------------------------------------------------------------------
check_oratab()
{
if [ -s /etc/oratab ]
then
   grep -i $ORACLE_SID /etc/oratab >/dev/null
   if [ $? -ne 0 ]
   then
      Bmsg -rl $LOGFILE -m "ERR: Die Umgebung fuer SID $ORACLE_SID kann nicht gesetzt werden!"
      Bmsg -rl $LOGFILE -m "ERR: Kein Eintrag in /etc/oratab!"
      exit_script 0
   fi
else
   Bmsg -rl $LOGFILE -m "ERR: Die Datei >/etc/oratab< existiert nicht!"
   exit_script 0
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check db instance role (dataguard)
#-----------------------------------------------------------------------------------------------------------------
check_primary()
{
  export ORACLE_HOME=${ORACLE_HOME}
  export ORACLE_SID=${ORACLE_SID}
  TMPSQLOUT="/tmp/check_primary.out"
  ${ORACLE_HOME}/bin/sqlplus -s /nolog <<EOSQL >/dev/null 2>&1
  connect / as sysdba
  set serverout on size unlimited feedback off
  whenever sqlerror exit sql.sqlcode
  spool $TMPSQLOUT
  declare
    l_primary_mode   pls_integer  := 0;
    l_db_name        varchar2(20) := '';
    l_db_unique_name varchar2(20) := '';
    l_dg_broker      pls_integer  := 0;
  begin
    select case DATABASE_ROLE when 'PRIMARY' then 1 else 0 end,
           NAME,
           DB_UNIQUE_NAME,
           case DATAGUARD_BROKER when 'ENABLED' then 1 else 0 end
      into l_primary_mode,l_db_name,l_db_unique_name,l_dg_broker
      from v\$database;
    dbms_output.put_line('export IS_PRIMARY='||l_primary_mode);
    dbms_output.put_line('export DBNAME='||l_db_name);
    dbms_output.put_line('export DBUNAME='||l_db_unique_name);
    dbms_output.put_line('export DGUARD='||l_dg_broker);
  end;
/
EOSQL
  RC=$?
  if [ "$RC" -eq 0 ]; then
    source $TMPSQLOUT >/dev/null 2>&1
  fi
  rm $TMPSQLOUT >/dev/null 2>&1
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check sqlplus spool file
#-----------------------------------------------------------------------------------------------------------------
chk_ora_err()
{
OERR=`grep "ORA-" $SQLRESULT`

if [ "$OERR" != "" ]
then
   Bmsg -rl $LOGFILE -m "$OERR"
   Bmsg -rl $LOGFILE -m "ERR: $MESSAGE"
   exit_script 30
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: get standby database (dataguard)
#-----------------------------------------------------------------------------------------------------------------
determine_secondary()
{
MESSAGE="Das Standby-System konnte nicht ermittelt werden!"
SQLRESULT=/tmp/dgmgrl.out
dgmgrl <<EODGMGRL  >$SQLRESULT
connect sys/${PWDSYS}@${DBUNAME_UC}
show configuration verbose
exit
EODGMGRL

chk_ora_err

TNS_S2=`cat $SQLRESULT|grep "Physical standby database"|awk '{print $1}'`
rm $SQLRESULT 2>/dev/null
if [ "${TNS_S2}x" != "x" ]
then
   STBY_HOST=`$ORACLE_HOME/bin/tnsping $TNS_S2|grep "(DESCRIPTION"|awk -F"HOST" '{print $2}'|sed s/=//|awk -F")" '{print $1}'|sed s/" "//g`
#da der gefundene STBY_HOST auch den DOMAIN-Anteil enthaelt, die SSH-Vertrauensstellung mit diesem HOSTNAMEN manchmal hakt
#wird der DOMAIN-Anteil noch abgeschnitten
   STBY_HOST=$(echo $STBY_HOST|awk -F\. '{print $1}')
else
   exit_script 60
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: update cmdb table BV$CMDB.ORA_ROTATEPWD
#-----------------------------------------------------------------------------------------------------------------
update_cmdb()
{
MESSAGE='Die CMDB konnte nnicht aktualisiert werden!'
CMDB_TNS='CMDB-P'
CMDB_USR='BV$CMDB'
CMDB_PWD=$PWDBVCMDB
CMDB_TABLE="${CMDB_USR}.ORA_ROTATEPWD"
PWDFILE_TS=`find ${DBPWDFILE} -printf "%Td-%Tm-%TY %TT"|cut -d. -f1`

SQLRESULT=/tmp/cmdb.out
${ORACLE_HOME}/bin/sqlplus -s /nolog  <<EOSQL >$SQLRESULT 2>&1
connect ${CMDB_USR}/"${CMDB_PWD}"@${CMDB_TNS}
set termout off;
set feed off;
declare
  l_dbname   varchar2(10)  := '${DBNAME}';
  l_user     varchar2(100) := upper('${ACCOUNT}');
  l_ddldate  date          := sysdate;
  l_filedate date          := to_date('${PWDFILE_TS}','DD-MM-YYYY HH24:MI:SS');
  l_comment  varchar2(100) := 'Script ${SCRIPTNAME} from host ${LONGHOST}';
  l_count    pls_integer   := 0;
begin
  update ${CMDB_TABLE}
     set pwd_ddl_ts     = l_ddldate
       , pwd_file_ts    = l_filedate
       , comments       = l_comment
   where username = l_user
     and db_name  = l_dbname
  return count(1) into l_count;
  if l_count = 0 then
     insert into ${CMDB_TABLE}
            (username, db_name, pwd_ddl_ts, pwd_file_ts, comments)
     values (l_user, l_dbname, l_ddldate, l_filedate, l_comment);
  end if;
  commit;
end;
/
exit;
EOSQL

chk_ora_err

rm $SQLRESULT 2>/dev/null
Bmsg -l $LOGFILE -m "CMDB table '${CMDB_TABLE}' updated."
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: change db password
#-----------------------------------------------------------------------------------------------------------------
set_passwords()
{
MESSAGE="Das Setzen des Passworts fuer $ACCOUNT ist fehlgeschlagen!"
SQLRESULT=/tmp/result_sql1.lst
#mpils, 04.01.17, ">/dev/null" hinzugefuegt, damit bei Fehlern mit dem Kommando nicht auch das Passwort ausgegeben wird.
${ORACLE_HOME}/bin/sqlplus -s /nolog  <<EOSQL >/dev/null
connect / as sysdba
set termout off;
set feed off;
spool $SQLRESULT;
alter user $ACCOUNT identified by "$PWD_STRING";
exit
EOSQL

chk_ora_err
rm $SQLRESULT 2>/dev/null

Bmsg -gl $LOGFILE -m "Passwort fuer $ACCOUNT erfolgreich geaendert!"
update_cmdb

echo
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check ssh connection (dataguard)
#-----------------------------------------------------------------------------------------------------------------
check_ssh_connectivity()
{
#echo "HOST: `hostname`"
#echo "STBY_HOST: $STBY_HOST"
SSH_STATUS=`(ssh -q -o "StrictHostKeyChecking=no" -o "BatchMode=yes" -o "ConnectTimeout=3" $STBY_HOST "echo 2>&1" && echo SSH_OK || echo SSH_NOK)|tail -1`
#echo "SSH_STATUS: $SSH_STATUS"
if [ "$SSH_STATUS" != "SSH_OK" ]
then
   Bmsg -rl $LOGFILE -m "ERR: Es besteht keine SSH-Vertrauensstellung zu >$STBY_HOST<!"
   Bmsg -rl $LOGFILE -m "ERR: "
   Bmsg -rl $LOGFILE -m "ERR: Das Oracle-Passwort-File kann nicht auf >$STBY_HOST< kopiert werden!"
   exit_script 40
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: copy db password file to standby host (dataguard)
#-----------------------------------------------------------------------------------------------------------------
copy_orapwd()
#dabei wird davon ausgegangen, dass $ORACLE_HOME auf beiden DataGuard-Maschinen gleich sind!
{
determine_secondary
check_ssh_connectivity
ORAPWDFILE="$ORACLE_HOME/dbs/orapw${ORACLE_SID}"
scp $ORAPWDFILE ${STBY_HOST}:$ORAPWDFILE >/dev/null 2>&1
if [ $? -ne 0 ]
then
   Bmsg -rl $LOGFILE -m "ERR: Die Datei >$ORAPWDFILE< konnte nicht auf die >${STBY_HOST}< kopiert werden!"
   exit_script 50
else
   Bmsg -gl $LOGFILE -m "Die Datei >$ORAPWDFILE< wurde auf >$STBY_HOST< kopiert!"
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: copy .pwdfile_db_* to /app/oracle/bin (local and remote [dataguard])
#-----------------------------------------------------------------------------------------------------------------
sync_pwdfile2bin()
{
#lokaler sync
cp $DBPWDFILE $PWDDIR/

#remoter sync
if [ $DGUARD -eq 1 ]; then #DataGuard!!!
   if [ $IS_PRIMARY -eq 1 ]; then #primary site
   scp $DBPWDFILE ${STBY_HOST}:$PWDDIR/
   if [ $? -ne 0 ]
   then
      Bmsg -rl $LOGFILE -m "ERR: Die Datei >$DBPWDFILE< konnte nicht auf die >${STBY_HOST}< kopiert werden!"
      exit_script 70
   else
      Bmsg -gl $LOGFILE -m "Die Datei >$DBPWDFILE< wurde auf >$STBY_HOST< kopiert!"
   fi
   fi
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     Check if user is oracle, otherwise abort
#-----------------------------------------------------------------------------------------------------------------
if [ `id -un` != "oracle" ]; then
  Bmsg -rm "Script may not run as user `id -un`, it must be started and run as oracle"
  RC=255
  Bmsg -rm "Error Code: ${RC}"
  exit $RC
fi

#-----------------------------------------------------------------------------------------------------------------
#     Get Parameter
#-----------------------------------------------------------------------------------------------------------------
while true; do
  case "$1" in
    -sid | --oracle_sid ) ORACLE_SID="$2";sid=1; shift 2 ;;
    -acc | --account_name ) ACCOUNT="$2";acc=1; shift 2 ;; #wird mit kaschiertem $-Zeichen uebergeben
    -h | --help ) usage ; exit 0;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

#-----------------------------------------------------------------------------------------------------------------
#     test to see if they gave the options
#-----------------------------------------------------------------------------------------------------------------
if [ "x" == "x$sid" ]; then
  Bmsg -rm "-sid | --oracle_sid [option] is required"|tee -a $LOGFILE; echo ""; usage
  exit 1
fi

if [ "x" == "x$acc" ]; then
  Bmsg -rm "-acc | --account_name [option] is required"|tee -a $LOGFILE; echo ""; usage
  exit 1
fi

check_oratab
. /app/oracle/bin/dbset $ORACLE_SID >/dev/null 2>&1

#-----------------------------------------------------------------------------------------------------------------
#     Check if database environment is set
#-----------------------------------------------------------------------------------------------------------------
if [ "x$DBNAME" == "x" ] || [ "x$DBUNAME" == "x" ]; then
  Bmsg -rm "Database environment is not set (DBNAME, DBUNAME, ...)"
  Bmsg -rm "Set it with '. dbset <database>' first!"
  RC=255
  Bmsg -rm "Error Code: ${RC}"
  exit $RC
fi

#-----------------------------------------------------------------------------------------------------------------
#     read passwords
#-----------------------------------------------------------------------------------------------------------------
#echo "ACCOUNT: $ACCOUNT"
FILEACC_LC=$(echo $ACCOUNT|tr [A-Z] [a-z]|sed 's/\$//g') #im Passwortfile-Namen sind die Accountnamen immer lowercase und beinhalten kein $-Zeichen
FILEACC_UC=$(echo $FILEACC_LC|tr [a-z] [A-Z]) #im Passwortfile sind die Accountnamen immer UPPERCASE und beinhalten kein $-Zeichen
#echo "FILEACC_UC: $FILEACC_UC"
DBPWDFILE=`grep -il "PWD${FILEACC_UC}=" $NFSPWDDIR/.pwdfile*|head -1`
#echo "DBPWDFILE: $DBPWDFILE"
   if [ "${DBPWDFILE}x" == "x" ]
   then
      echo "kein passendes Passwortfile gefunden!" |tee -a $RXCLOGFILE
      exit 1
   fi

PWD_STRING=`cat $DBPWDFILE| awk -F\' '{print $2}'`
#echo "PWD_STRING: $PWD_STRING"

#-----------------------------------------------------------------------------------------------------------------
#     Main program - start
#-----------------------------------------------------------------------------------------------------------------
check_instance
check_primary
if [ $DGUARD -eq 1 ]; then #DataGuard!!!
   if [ $IS_PRIMARY -eq 1 ]; then #primary site
      set_passwords
      copy_orapwd
   else # standby site
      Bmsg -bm "STANDBY-Site: no actions!"
      Bmsg -bm "Please change passwords at primary site and copy oracle password file!"
   fi
else #single instance
   set_passwords
fi

sync_pwdfile2bin

#-----------------------------------------------------------------------------------------------------------------
#     Main program - end
#-----------------------------------------------------------------------------------------------------------------
exit_script 0

