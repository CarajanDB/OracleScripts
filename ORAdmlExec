#!/bin/bash
# @(#) ================================================================================================================
# @(#) File        : ORAdmlExec
# @(#) Author      : Dieter Smets
# @(#) Modified    :
# @(#)
# @(#) Description : This script does run the given File by SQL/Plus as described here:
# @(#)               Description:   http://lxwiki.unix.lan/wiki_root/dokuwiki/dokumentationen/doku.php?id=datenbanken:oracle:oradmlexec
# @(#)
# @(#) Version     : 2.13
# @(#) Datum       : 09.04.2024
# @(#)
# @(#) Presumption :
# @(#)
# @@(#) Change History:
# @@(#)
# @@(#) 1.0  2018-01-09  Smets       Created
# @@(#) 1.1  2018-01-11  Smets       Logger aktualisiert, Anmeldung mit AD User implementiert
# @@(#) 1.2  2018-01-12  Smets       Fehler korrigiert: Aendern Ownership der Log-Files
# @@(#) 1.3  2018-02-28  Smets       Remove Tmp-Files.
# @@(#) 1.4  2018-04-11  Smets       SQLPlus "Set Define off" vor Ausfuehrung Skript gesetzt.
# @@(#) 1.5  2018-06-05  Smets       -dump Option added to optionally printout the SQL SYSOUT file.
# @@(#) 1.6  2018-08-29  Voss        #!/bin/bash
# @@(#) 1.7  2018-09-20  Smets       Warnungsmeldung nach SQLPLUS SP2-Fehler: COMMIT wurde durchgefuehrt
# @@(#) 1.8  2018-09-24  Smets       Handling SQLPLUS SP2-Fehler geaendert: via Procedure CHECK_SPERRORLOG
# @@(#) 1.9  2018-10-22  Smets       Korrigiert: Berechnung Skript-Elapsed-Zeiten.
# @@(#) 1.10 2018-11-12  Smets       Erweitert: Journal-Eintrag in BVDBS @ DBAP
# @@(#)                              neuer optionaler Parameter fuer Ticket zum Jounaleintrag
# @@(#) 1.11 2018-11-16  Smets       ReportSafe Link in Journaleintrag, statt Folder Text
# @@(#) 1.12 2018-11-16  Smets       Erweitert um Spalte EXECUTION_TYPE in Journaltabelle
# @@(#)      2018-11-23  Smets       Aufruf Function get_dml_file auskommentiert (wg. Syntaxfehler)
# @@(#) 1.13 2018-12-05  Smets       Neue Function get_dml_file: handle Input files from Windows Share
# @@(#) 1.14 2018-12-07  Smets       Schreiben nach ReportSafe fuer alle Stages, Aufbewahrung fuer Non-P-Stages: 3 Tage
# @@(#)                              Speichern Ticket URL zur Anzeige im Journal
# @@(#) 1.15 2019-01-14  Smets       Direktes Schreiben des Jira Ticket Kommentars, sowie abschliessen, falls Ticket spezifiert wurde.
# @@(#) 1.16 2019-01-14  Smets       Jira Ticket Kommentar erweitert um Inputfile-Name (mehrere Files pro Ticket).
# @@(#) 1.17 2019-01-16  Smets       Zwang zur Eingabe eines Tickets fuer P-Stage unter Control-M aufgehoben (zyklische Jobs).
# @@(#) 2.00 2019-01-30  Smets       Aenderung: Pruefung Control-M Modus via Parameter (-ctm) statt via ps Command.
# @@(#)                              Neu: Flowster Modus via neuer Option -FS mit Flowster Ausfuehrungs User.
# @@(#)                              Ticket-Kommentar um DB und Schema erweitert.
# @@(#) 2.01 2019-02-01  Smets       diverse kleine Aenderungen bzgl. FlowsterModus.
# @@(#) 2.02 2019-02-11  Smets       Speziellert techn. User BVBTDUSR (statt BVBTCUSR) fuer FlowsterModus (wg. Privilegien).
# @@(#) 2.03 2019-04-08  Smets       Ticket-Angabe via Flowster optional mueglich, jedoch keine Pruefung, nur Kommentar schreiben.
# @@(#) 2.04 2019-04-10  Smets       Fehlerkorrektur zur Ticket-Angabe via Flowster.
# @@(#) 2.05 2019-04-26  Smets       Fehlerkorrektur: Stage Ermittlung korrigiert, wenn DBNAME 2 '-' enthuelt (evb-vwbtest-f)
# @@(#) 2.06 2019-07-01  Smets       Ticket CHMGT-1613 / TADBA-1213: ReportSafe goes https://
# @@(#) 2.07 2019-08-13  Smets       Erweiterung Timestamp in Filenamen (Variable FILETS) um Nanosekunden. Zeitgleiche Ausfuehrungen
# @@(#)                              via Scheduler fuehren zu ueberschreibungen in Log-Files und ReportSafe.
# @@(#) 2.08 2019-10-16  Smets       Ermitteln Password fuer BVBTDUSR aus eigenem Password-File.
# @@(#) 2.09 2021-01-04  Smets       chgrp to oinstall for LOG-Files in usage Function.
# @@(#) 2.10 2021-05-26  Smets       JIRAHOST URL wurde geuendert.
# @@(#) 2.11 2021-05-22  Smets       Minor Change
# @@(#) 2.12 2022-02-02  Smets       grep Pruefung des SQLPLUS SP2-Fehlers wieder aktiviert, zus. zu CHECK_SPERRORLOG,
# @@(#)                              da mit neuem Client auf DBAHOST manche SP2-Fehler nicht protolliert werden.
# @@(#) 2.13 2024-04-09  MPils       "" fuer Oracle Passwort hinzugefuegt
# @@(#)
# @(#) ================================================================================================================
set +x
#-----------------------------------------------------------------------------------------------------------------
#     Global script environment
#-----------------------------------------------------------------------------------------------------------------
#
SCRIPTNAME=$(basename $0)
SCRIPTDIR=/app/oracle/bin
SCRIPTSHORTDESC="This script runs the given File by SQL/Plus as described here:
                             http://lxwiki.unix.lan/wiki_root/dokuwiki/dokumentationen/doku.php?id=datenbanken:oracle:oradmlexec
"
FILETS=`date +%Y%m%d_%H%M%S%N`
DML_EXEC_SYSOUT=/app/oracle/admin/log
SYSOUT=${DML_EXEC_SYSOUT}/${SCRIPTNAME}-SYSOUT-${FILETS}.log
#echo ${SYSOUT}

source /app/oracle/bin/ORAlib
PWDDIR=/app/oracle/admin/etc/pwddir


#JIRAHOST='https://jira0.barmenia24.de'
JIRAHOST='https://jira.barmenia24.de'
USRTECDBAJIRA="tec-dba-jira"
source $PWDDIR/.pwdfile_jira_tec-dba-jira
#  PWDTECDBAJIRA

#-----------------------------------------------------------------------
# Logger Script
#-----------------------------------------------------------------------

Logger

LOGFILE="${SYSOUT}"
logger_info "All actions are logged in $LOGFILE!"

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Help routine
#-----------------------------------------------------------------------------------------------------------------
function usage()
{
if [ $help -eq 1 ]
then
   RC=0
else
   RC=1
fi

echo ""
echo "  Command     : $SCRIPTNAME $DB_OS OID $S_OS SCHEMA $I_OS INPUTFILE [$DUMP_OS] [$T_OS TICKET]"
echo "  Description : $SCRIPTSHORTDESC"
echo ""
echo "  Parameters  : $DB_OPT,        Oracle TNS Service Name"
echo "                $S_OPT,          Schema Name"
echo "                $I_OPT,          Input DML File (complete Path) to execute"
echo "                $DUMP_OPT,                  Optional, to print out (cat) the SQL SYSOUT file "
echo "                $T_OPT,          Optional, corresponding Jira Ticket number "
echo ""
echo "  Example     : ${SCRIPTNAME} $DB_OS psh-f $S_OS bvpshadm $I_OS \"/oranfs/share/ora_admin/ORAdmlExec/sss/filename\" -dump -t tadba-nnn"
echo ""
echo "" Spezielle Parameter zur Ausfuehrung des Skripts aus Control-M oder Flowster heraus:
echo ""
echo "                $CTM_OPT,      Optional, identifiziert den Execution-Type CTM. Nur aus Control-M heraus spezifizieren!"
echo "                $FS_OPT,       Optional, identifiziert den Execution-Type FSS (Flowster). Wird aus dem Flowster Service heraus spezifiziert!"
echo ""

# Change Ownership of Log-Files to "oinstall":
for LOGFILES in `find ${DML_EXEC_SYSOUT} -name "${SCRIPTNAME}*" -user "$USER" -group barmstaf`
do
chgrp oinstall $LOGFILES
done

exit $RC
}
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Detect File Encoding
#-----------------------------------------------------------------------------------------------------------------
function det_sql_file_encoding
{
#set -x
if [ $(hostname -s) = 'lx0wj' ]
then
   ENCODING=`file -bi $FILENAME|awk -F= '{print $2}'`
else
   ENCODING=`uchardet $FILENAME`
fi
ENCODING=$( echo "$ENCODING" | tr '[:lower:]' '[:upper:]' )

if [ "$ENCODING" != 'UTF-8' ]
then
   NLS_LANG_VAR=AMERICAN_AMERICA.WE8MSWIN1252
else
   NLS_LANG_VAR=AMERICAN_AMERICA.UTF8
fi
NLS_LANG=${NLS_LANG_VAR}
export NLS_LANG
#echo "("`date +%Y%m%d_%H%M%S`")   File:   ${FILENAME}   -   NLS_LANG set to: ${NLS_LANG_VAR}"
logger_info "File:   ${FILENAME}   -   NLS_LANG set to: ${NLS_LANG_VAR}";
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Check if Script is started by Control-M
#-----------------------------------------------------------------------------------------------------------------
#function check_if_started_by_ctm
#{
##set -x
#PSOUT=`ps -ef|grep ${PPID}|awk -v ppid=$PPID '{if($2==ppid){print $0}}'`
#CTMRUN=0
##echo $PSOUT
#echo $PSOUT|grep -e 'ctms-' -e 'ctm_ag'  >/dev/null 2>&1
#if [ $? -eq 0 ]
#then
#   CTMRUN=1
#fi
##if [ $CTMRUN -eq 1 ]
##then
##   echo "von Control-M gestartet"
##else
##   echo "manuell gestartet"
##fi
#}

function manage_ticket_handling
{
if [ "x" == "x$ticket" ];        # wenn kein Ticket spezifiziert, dann ...
#  then :
   then
     if [[ $STAGE_UC == 'P' || $STAGE_UC == 'PDMZ' ]]
        then
          if [ "x$ctmrun" == "x" ] && [ "x$flowster" == "x" ]   # Kein Ticket ist auch fuer P-Stages OK fuer Control-M und Flowster Ausfuehrungen!
             then
               logger_error "*************************************************************"
               logger_error "* Ticket muss fuer die P-Stage spezifiziert werden!"
               RC=1
               logger_error "* RC=$RC"
               logger_error "*************************************************************"
               exit ${RC}
          fi
     fi
   else
     TICKET=$( echo "$TICKET" | tr '[:lower:]' '[:upper:]' )
     TICKET_NO=${TICKET}
     TICKET_LINK="https://jira.barmenia.lan/browse/${TICKET_NO}"

# Skript-Anpassung: Angabe Ticket ueber Flowster optional mueglich, jedoch nur zum Schreiben des Ticket-Kommentars.
#                   Jegliche Pruefung des eingegeben Tickets unterbleibt jedoch.
     if [ "x" == "x$flowster" ]; then
        jira_ticket_check
     fi

fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Get User/Password depending on Run-Environment (Control-M or Foreground)
#-----------------------------------------------------------------------------------------------------------------
function get_user_and_pwd
{
set +x     # suppress PWD listing
#if [ $CTMRUN -eq 1 ]
if [[ "x$ctmrun" == "x1" || "x$flowster" == "x1" ]]  # If started by Control-M or Flowster:
then                                                 #    take Technical DBA User and Passw
   # Get Password from PasswordFile:
   DBAUSER=BVBTCUSR
   source $PWDDIR/.pwdfile_db_bvbtcusr
   DBAPASS=${PWDBVBTCUSR}
   if [ "x$flowster" == "x1" ]                       # If started by Flowster take alternate User BVBTDUSR with restricted privileges:
      then
        DBAUSER=BVBTDUSR
        source $PWDDIR/.pwdfile_db_bvbtdusr
        DBAPASS=${PWDBVBTDUSR}
      fi
else                                                 #    ask for (User) and /or Password
   TIMEOUT=30
   if [ $USER == "oracle" ]
   then
     logger_error "* Scipt has been started by User oracle. Not allowed!"
     echo "Enter your AD Account: "; read -t $TIMEOUT DBAUSER
     USRTECDBAJIRA=$DBAUSER
    else
      DBAUSER=$USER
      USRTECDBAJIRA=$USER
    fi
    echo "Enter ${DBAUSER}'s Password within $TIMEOUT seconds: "; stty -echo; read -t $TIMEOUT DBAPASS; stty echo
    PWDTECDBAJIRA=${DBAPASS}
fi

if [ -z "${DBAUSER}" ] || [ -z "${DBAPASS}" ]
   then
   logger_error "*************************************************************"
   logger_error "* AD Account and/or Password not entered."
   RC=1
   logger_error "* RC=$RC"
   logger_error "*************************************************************"
   exit ${RC}
fi

# Check Password and build ReportSave TITLE:
sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@${DBNAME}
select 'PROD Update to ${DBSCHEMA}@${DBNAME} - Dieser Output dient lediglich der Zuordnung im ReportSafe.' from dual ;
quit;
EOT
RC1=$?
grep -Ec "ORA-[0-9][0-9][0-9][0-9][0-9]" ${SYSOUT} >/dev/null 2>&1
if [ $? -eq 0 ] || [ $RC1 -gt 0 ]
   then
     logger_error "* Fehler bei SQL-Plus Ausfuehrung!"
     cat ${SYSOUT}
     RC=1
     logger_error "* RC=$RC"
     exit ${RC}
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Get (and Copy) DML Input File
#-----------------------------------------------------------------------------------------------------------------
function get_dml_file
{
PRINT_INFILE_ORG=${INPUTFILE}
SET_INDIR_WIN="H:/Datenbank/IT-Betrieb/uebergabe"
SET_INDIR_LX="/oranfs/share/ora_admin/ORAdmlExec/uebergabe"

echo $INPUTFILE|sed 's#\\#/#g' >/tmp/${SCRIPTNAME}_${DBNAME}_${FILETS}.infile   # Change "\" to "/"
TMPINSTRING=` cat /tmp/${SCRIPTNAME}_${DBNAME}_${FILETS}.infile`
DML_INFILE=`basename $TMPINSTRING`                                              # Strip Filename ...
DML_INDIR_WIN=`dirname ${TMPINSTRING}`;                                         # ... and Directory Name
rm /tmp/${SCRIPTNAME}_${DBNAME}_${FILETS}.infile;

TMPMKDIR=`echo ${DML_INDIR_WIN}|sed s#"${SET_INDIR_WIN}/"##`;                   # Build LinuxHost Directory Name ...
DML_INDIR_LX="${SET_INDIR_LX}/${TMPMKDIR}";                                     # ... Windows Name
PRINT_INFILE_LX=${DML_INDIR_LX}/${DML_INFILE}

if [[ ${DML_INDIR_WIN} =~ "${SET_INDIR_WIN}" ]]   # Is the Windows Directory specified?
   then
     DML_INDIR_LX="${SET_INDIR_LX}/${TMPMKDIR}"   # THEN use the corresponding Linux File Nmae
   else                                           #
     DML_INDIR_LX="${DML_INDIR_WIN}"              # ELSE use the originally given File Name
fi
PRINT_INFILE_LX=${DML_INDIR_LX}/${DML_INFILE}

if ! [ -e ${DML_INDIR_LX}/${DML_INFILE} ]         # check ob INPUTFILE existiert!
then
     logger_error "*************************************************************"
     logger_error "* DML Inputfile existiert nicht: $PRINT_INFILE_ORG"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
     exit ${RC}
fi

INPUTFILE=${DML_INDIR_LX}/${DML_INFILE}
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Execute DML-Files
#-----------------------------------------------------------------------------------------------------------------
function execute_dml_file
{
#START_TIME_SCRIPT=$(date +%Y%m%d%H%M%S);

sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@${DBNAME}

set feedback off;
SPOOL OFF;
set serveroutput on;
set echo on;
set heading off ;
whenever sqlerror exit failure rollback;
whenever oserror exit failure rollback;
set sqlblanklines on;
set trimspool on;

-- Configure SPERRORLOGging to handle SP2 Errors:
column c1 new_value SPERRORLOG_ID NOPRINT;
select 'ORAdmlExecSid'||SYS_CONTEXT('userenv','sid') as c1 from dual;
set errorlogging on table BV\$DBA.SPERRORLOG truncate identifier &SPERRORLOG_ID;

-- Dieser SELECT dient lediglich des Prints ins LOG, da SQLPlus nur das Ergebnis des Statements an-printed:
select 'alter session set current_schema = "${DBSCHEMA}"' from dual;
alter session set current_schema = "${DBSCHEMA}" ;

select 'Database: ' || NAME from V\$DATABASE union all
select 'Schema:   ' || sys_context( 'userenv', 'current_schema' ) from dual union all
select 'DB User:  ' || sys_context('userenv','AUTHENTICATED_IDENTITY') from dual union all
select 'OS User:  ' || sys_context( 'userenv', 'os_user' ) from dual;

set define off;
set timing on;
set feedback on;

start ${FILENAME} ${DBSCHEMA};

-- Check SPERRORLOGging:
set define on;
set echo off;
set verify off;
set feedback off;
Begin
BV\$DBA.CHECK_SPERRORLOG(SPERRORLOG_ID=>'&SPERRORLOG_ID') ;
End;
/

quit;
EOT
RC1=$?

if [ ${RC1} -gt 0 ]
   then
     cat ${SYSOUT}
     logger_error "*************************************************************"
     if [ "x$flowster" == "x1" ]
        then
          logger_error "* Fehler bei SQL Ausfuehrung!"
        else
          logger_error "* Fehler bei SQL Ausfuehrung! Skript: ${FILENAME}"
          logger_error "* Siehe ${SYSOUT}"
     fi
     RC=1
     logger_error "* RC=$RC"
     logger_error "* ROLLBACK wurde durchgefuehrt"
     logger_error "*************************************************************"
     exit ${RC}
fi

#   wurde eliminiert durch SPERRORLOGging
#   02.02.2022: wieder aktiviert:
#      Bei Ausfuehrung auf neuem DBAHOST mit neuem Oracle Client werden nicht alle SP2-Fehler gehandelt
#      (z.B. SP2-0341: line overflow during variable substitution (>3000 characters at line 10) )
#      Damit diese Fehler das Skript zum Abbruch bringen, wird dieses Fehler-Handling zusaetzlich aktiviert.
grep -Ec "SP2-[0-9][0-9][0-9][0-9]" ${SYSOUT} >/dev/null 2>&1
if [ $? -eq 0 ]
   then
     cat ${SYSOUT}
     logger_error "*************************************************************"
     logger_error "* Fehler bei SQL-Plus Ausfuehrung! SQL/Plus SP2 Fehler"
     logger_error "* Siehe ${SYSOUT}"
     RC=2
     logger_error "* RC=$RC"
     logger_error "* ACHTUNG, ACHTUNG, ACHTUNG: nach SQLPLUS SP2-Fehler wurde ein COMMIT durchgefuehrt. Bitte weiteres Vorgehen ueberpruefen/abstimmen!"
     logger_error "*************************************************************"
     exit ${RC}
fi

#END_TIME_SCRIPT=$(date +%Y%m%d%H%M%S);
#ELAPSED_TIME_SCRIPT=$(($END_TIME_SCRIPT-$START_TIME_SCRIPT));
#echo "Elapsed Time ${FILENAME} is: "${ELAPSED_TIME_SCRIPT}" seconds";
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: LOG in Report-Safe sichern:
#-----------------------------------------------------------------------------------------------------------------
function save_log_2_reportsafe
{
HOSTNAME=`hostname`
#ERRFIL=/tmp/${SCRIPTNAME}_${DBNAME}_${FILETS}.err
ERRFIL="/tmp/${SCRIPTNAME}_RepSafeError_${DBNAME}_${DBVER_APPL}_${FILETS}.err"

if [[ $STAGE_UC == 'P' || $STAGE_UC == 'PDMZ' ]]
   then
     JOBNAME="DB_PROD_Update-${FILETS}"
     REPSAFE_JOBNAME="DB_PROD_Update_${FILETS}"
#     JOBNAME="DB_TEST_Update-${FILETS}"
#     REPSAFE_JOBNAME="DB_TEST_Update_${FILETS}"
   else
     JOBNAME="DB_TEST_Update-${FILETS}"
     REPSAFE_JOBNAME="DB_TEST_Update_${FILETS}"
fi
logger_info "$SCRIPTNAME Output wird nach ReportSafe geschrieben."

#JOBNAME="DB_TEST_Update-${FILETS}"
# in ReportSafe wird anscheinend der '-' in einen '_' umgewandelt. Daher:
#REPSAFE_JOBNAME="DB_TEST_Update_${FILETS}"
# zur Speicherung der ReportSafe-URL zum Job:
REPSAFE_JOURNAL="https://repsafe2.idm.lan.local/rsWeb.ASP?m=rswReport&QD=true&style=2&mode=tree&folderframe=no&filterform=yes&JobName=${REPSAFE_JOBNAME}*&showgroup=true&showarchive=both&gen=1"

lpr  -P REPLOG -J ${JOBNAME} ${SYSOUT} >$ERRFIL 2>&1
#echo "*************************************************************"
#echo "* Folgende Zeile in Jira-Ticket als Bemerkung eintragen:"
#REPSAFE_JOURNAL="Folder: PublicFolder/Project_Sysout/DBA_PROD, Report = ${JOBNAME}"
#echo "* Protokollierung in ReportSafe: ${REPSAFE_JOURNAL}"
#echo "*************************************************************"
#logger_info "*Protokollierung in ReportSafe: ${REPSAFE_JOBNAME}"
if [ -s $ERRFIL ]
then
ERROUT=`cat $ERRFIL`
mail -s "ProdUpdate Logfilesicherung" unix-dba\@barmenia.de <<EOT
Das nachfolgend genannte Logfile konnte nicht nach ReportSafe uebertragen werden!

Hostname: $HOSTNAME
Logfile:  ${JOBNAME}

die Fehlermeldung ist:
$ERROUT

Wenn der Fehler behoben ist kann das Logfile mittels

lpr  -P REPLOG -J ${JOBNAME} ${SYSOUT}

manuell nach ReportSafe uebertragen werden!
EOT
logger_info "SYSOUT konnte nicht nach ReportSafe geschrieben werden; siehe Mail an unix-dba!";
fi
if [ -f "$ERRFIL" ]; then rm  "$ERRFIL";
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Write Record to Jounal Table BVDBS.TDBS_ORADMLEXEC_PROTOKOLL @ DBAP:
#-----------------------------------------------------------------------------------------------------------------
function write_jounal_table
{
HOSTNAME=`hostname`
MESSAGE="Write entry to Journal Table BVDBS.TDBS_ORADMLEXEC_PROTOKOLL@DBAP"
#logger_info "${MESSAGE}"

EXECUSER="${DBAUSER}"
if [ "x$flowster" == "x1" ]; then
   EXECUSER=${FLOWSTER_USER}
fi

cat > /tmp/ORAdmlexec_${DBNAME}_${STAGE_UC}_${FILETS}.sql <<EOF
set pagesize 0 heading off feedback off verify off echo off trimspool on timing off define off
INSERT INTO BVDBS.TDBS_ORADMLEXEC_PROTOKOLL (
   DBNAME,
   DBSTAGE,
   "SCHEMA",
   INPUT_FILENAME,
   EXECUTION_USER,
   EXECUTION_TS,
   EXECUTION_RUNTIME,
   EXECUTION_HOST,
   EXECUTION_LOGFILE,
   EXECUTION_TYPE,
   TICKET_NO,
   TICKET_LINK,
   REPORTSAFE_DOK)
VALUES ( '${DBNAME}',
         '${STAGE_UC}',
         '${DBSCHEMA}',
         '${PRINT_INFILE_ORG}',
         '${EXECUSER}',
         sysdate,
         '${ELAPSED_TIME_ALL}',
         '${HOSTNAME}',
         '${LOGFILE}',
         '${EXECUTION_TYPE}',
         '${TICKET_NO}',
         '${TICKET_LINK}',
         '${REPSAFE_JOURNAL}'
         );
EOF

sqlplus -S /nolog <<EOT 2>&1
connect ${DBAUSER}/"${DBAPASS}"@DBA-P

@/tmp/ORAdmlexec_${DBNAME}_${STAGE_UC}_${FILETS}.sql

EOT
RC4=$?
if [ ${RC4} -gt 0 ]
   then
     logger_error "*************************************************************"
     logger_info "* Fehler beim Schreiben des Journal-Eintrags"
     logger_info "* Siehe ${SYSOUT}"
     logger_info "* Verarbeitung wird ordnungsgemaess beendet."
fi
rm /tmp/ORAdmlexec_${DBNAME}_${STAGE_UC}_${FILETS}.sql
}

# ################################################################################################################
#     M A N A G E   J I R A   T I C K E T S   Functions
# ################################################################################################################
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Check, if given Jira-Ticket exists:
#-----------------------------------------------------------------------------------------------------------------
function jira_ticket_check
{
#USRTECDBAJIRA=testuser
#PWDTECDBAJIRA=testuser

JIRAFUNCURL="rest/api/latest/issue/${TICKET}"
FILTER="?fields=status"
CMD="curl -u $USRTECDBAJIRA:$PWDTECDBAJIRA -X GET -H \"Accept: application/json\" ${JIRAHOST}/${JIRAFUNCURL}${FILTER} 2>/dev/null"
#echo $CMD
RCJ=`bash -c "$CMD"`
#    unterstuetze Jira Spracheinstellung "Englisch" und "Deutsch":
echo $RCJ|grep errorMessages|grep -e "Issue Does Not Exist" -e "DER VORGANG EXISTIERT NICHT." >/dev/null
if [ $? -eq 0 ] # Suchtext gefunden ==> Ticket existiert nicht
then
     RC=1
     logger_error "*************************************************************"
     logger_error "* Ticket wurde spezifiziert, existiert aber nicht - ${TICKET}"
     logger_error "* RC=$RC"
     logger_error "* ROLLBACK wurde durchgefuehrt"
     logger_error "*************************************************************"
     exit ${RC}
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Write Comment to Jira Ticket after successful Execution of Script
#-----------------------------------------------------------------------------------------------------------------
function jira_ticket_comment
{
#USRTECDBAJIRA=testuser
#PWDTECDBAJIRA=testuser

JIRAFUNCURL="rest/api/2/issue/${TICKET}/comment"
REPSAURL="Reportsafe|${REPSAFE_JOURNAL}"
REPSAAUTHURL='Anleitung|http://wsv-muv.unix.lan/mediawiki/index.php/DBA-Dev-SST-Reports#Oracle_DB_Daten.C3.A4nderungen'
JIRACOMFILE=${PRINT_INFILE_ORG}
JIRACOMFILE=$(echo "$JIRACOMFILE"|sed 's/\\/\\\\/g')
#JIRACOMFILE='H:\\Datenbank\\IT-Betrieb\\uebergabe\\dba\\ORAdmlExec\\TestSkripte\\ORAdmlExecTestScript.sql'

COMMENT="*INFILE=${JIRACOMFILE}* \\\\\\\\"
COMMENT="$COMMENT Ausgefuehrt an DB: *${DBNAME}* in Schema: *${DBSCHEMA}* von User: *${FLOWSTER_USER}*. \\\\\\\\ \\\\\\\\"
COMMENT="$COMMENT (y) Das angeforderte Skript wurde erfolgreich ausgefuehrt! \\\\\\\\"
COMMENT="$COMMENT Das Ausfuehrungsprotokoll kann hier eingesehen werden: [$REPSAURL] \\\\\\\\ \\\\\\\\"
COMMENT="$COMMENT _+Anmerkungen zum ReportSafe:+_ \\\\\\\\"
COMMENT="$COMMENT _Die Ausfuehrungsprotokolle sind fuer die Stages E-I (LocalDev-PP) 3 Tage, fuer die Stage P 10 Jahre verfuegbar._ \\\\\\\\"
COMMENT="$COMMENT _Zur Ansicht des ReportSafe bedarf es Berechtigungen. Falls kein Output angezeigt wird:_ [$REPSAAUTHURL] "

JSON_COMMENT="{\"body\": \"$COMMENT\"}"
CMD="curl -u ${USRTECDBAJIRA}:${PWDTECDBAJIRA} -X POST --data '$JSON_COMMENT' -H \"Content-Type: application/json\" ${JIRAHOST}/${JIRAFUNCURL} 2>/dev/null"
#echo "CMD: $CMD#"
#RCJ=`bash -c "$CMD" |jq -a '' 2>/dev/null|grep '\"updated\"'|awk '{print $2}'`
RCJ=`bash -c "$CMD"`
echo $RCJ|grep '\"updated\":' >/dev/null
if [ $? -eq 0 ] # Suchtext gefunden ==> Kommentartext erfolgreich eingefuegt.
then
     logger_info "Jira Ticket Kommentar zu ${TICKET} wurde hinzugefuegt."
     if [[ "x$flowster" == "x" ]]  # If not started by Flowster:
     then
         jira_ticket_close
     fi
else
     logger_warn "************************************************************************"
     logger_warn "* Ticket-Kommentar ${TICKET} konnte nicht nach Jira geschrieben werden."
     logger_warn "*"
     logger_warn "* >>>>>>>>>> Ticket ${TICKET} muss manuell bearbeitet werden! <<<<<<<<<<"
     logger_warn "*"
     logger_warn "************************************************************************"
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Close Ticket
#-----------------------------------------------------------------------------------------------------------------
function jira_ticket_close
{
#USRTECDBAJIRA=
#PWDTECDBAJIRA=

JIRAFUNCURL="rest/api/2/issue/${TICKET}/transitions"
CMD="curl -u ${USRTECDBAJIRA}:${PWDTECDBAJIRA} -X GET -H \"Content-Type: application/json\" ${JIRAHOST}/${JIRAFUNCURL} 2>/dev/null"
#echo "CMD: $CMD#"
TRANS_ID=`bash -c "$CMD"|jq -a '.transitions[]|select(.name | contains("Vorgang abschlie"))|.id'|sed s/\"//g`
#echo "TRANS_ID: $TRANS_ID#"

JIRAFUNCURL="rest/api/2/resolution"
CMD="curl -u ${USRTECDBAJIRA}:${PWDTECDBAJIRA} -X GET -H \"Content-Type: application/json\" ${JIRAHOST}/${JIRAFUNCURL} 2>/dev/null"
#echo "CMD: $CMD#"
RES_ID=`bash -c "$CMD"|jq '.[]|select(.name | contains("erledigt"))|.id'|sed s/\"//g`
if [ -z "${RES_ID}" ]
   then
     RES_ID=`bash -c "$CMD"|jq '.[]|select(.name | contains("Done"))|.id'|sed s/\"//g`
fi
#echo "RES_ID: $RES_ID#"

JIRAFUNCURL="rest/api/2/issue/${TICKET}/transitions"
JSON_CLOSE="{\"fields\":{\"resolution\":{\"id\":\"$RES_ID\"}},\"transition\":{\"id\":\"$TRANS_ID\"}}"
CMD="curl -u ${USRTECDBAJIRA}:${PWDTECDBAJIRA} -X POST --data '$JSON_CLOSE' -H \"Content-Type: application/json\" ${JIRAHOST}/${JIRAFUNCURL} 2>/dev/null"
#echo "CMD: $CMD#"
RCJ=`bash -c "$CMD"; echo $?`
#echo "RC: $RCJ#"

if [ "${RCJ}" = "0" ]
then
     logger_info "Jira Ticket ${TICKET} wurde mit Loesung "'"erledigt"'" geschlossen."
else
     logger_warn "****************************************************************************"
     logger_warn "* Ticket ${TICKET} konnte nicht auf erledigt gesetzt und geschlossen werden."
     logger_warn "*"
     logger_warn "* >>>>>> Ticket ${TICKET} muss manuell bearbeitet/ueberprueft werden! <<<<<<"
     logger_warn "*"
     logger_warn "****************************************************************************"
fi
}
#-----------------------------------------------------------------------------------------------------------------
#     END of FUNCTION SECTION
#-----------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------
#     Get Parameter
#-----------------------------------------------------------------------------------------------------------------
PRINTOUT=0   # Default DUMP Option
DB_OS="-db"; DB_OL="--db_name";     DB_OPT="$DB_OS[|$DB_OL]"
S_OS="-s"; S_OL="--schema";         S_OPT="$S_OS[|$S_OL]"
I_OS="-i"; I_OL="--infile";         I_OPT="$I_OS[|$I_OL]"
DUMP_OS="-dump";                    DUMP_OPT="$DUMP_OS"
FS_OS="-FS"; FS_OL="--FLOWSTER";    FS_OPT="$FS_OS[|$FS_OL]"
T_OS="-t"; T_OL="--ticket";         T_OPT="$T_OS[|$T_OL]"
CTM_OS="-ctm"; CTM_OL="--controlm"; CTM_OPT="$CTM_OS[|$CTM_OL]"
H_OS="-h"; H_OL="-?";               H_OPT="$H_OS[|$H_OL]"
help=0
if [ $# -eq 0 ]
then
   usage
else
   while [ $# -gt 0 ]; do
     case "$1" in
         $DB_OS | $DB_OL ) DBNAME="$2"
                           DBNAME=`echo $DBNAME|tr [a-z] [A-Z]`
                           DBNAME_LC=`echo $DBNAME|tr [A-Z] [a-z]`
                           dbname=1
                           shift 2;;
         $S_OS | $S_OL )   DBSCHEMA="$2"
                           DBSCHEMA=`echo $DBSCHEMA|tr [a-z] [A-Z]`
                           dbschema=1
                           shift 2;;
         $I_OS | $I_OL )   INPUTFILE="$2"
                           inputfile=1
                           shift 2;;
         $DUMP_OS      )   PRINTOUT=1
                           shift 1;;
         $FS_OS | $FS_OL ) flowster=1
                           FLOWSTER_USER="$2"
                           shift 2;;
         $T_OS | $T_OL )   TICKET="$2"
                           ticket=1
                           shift 2;;
         $CTM_OS | $CTM_OL) ctmrun=1
                            shift 1;;
         $H_OS | $H_OL )   help=1
                           usage;;
         * )               echo "*************************************************************"
                           echo "* Parameter Error at '$1'"
                           echo "*************************************************************"
                           usage;;
     esac
   done
fi
#-----------------------------------------------------------------------------------------------------------------
#     test to see if they gave the mandatory options
#-----------------------------------------------------------------------------------------------------------------
if [ "x" == "x$dbname" ]; then
  MESSAGE="$DB_OPT Option is required!"
  logger_error "$MESSAGE"
  exit 1
fi
if [ "x" == "x$dbschema" ]; then
  MESSAGE="$S_OPT Option is required!"
  logger_error "$MESSAGE"
  exit 1
fi
if [ "x" == "x$inputfile" ]; then
  MESSAGE="$I_OPT Option is required!"
  logger_error "$MESSAGE"
  exit 1
fi

get_dml_file

#-----------------------------------------------------------------------------------------------------------------
#     build STAGE from DBNAME (TNS-Service Name)
#-----------------------------------------------------------------------------------------------------------------
#STAGE_UC=`echo $DBNAME|rev|cut -c 1`
#STAGE_UC=`echo $DBNAME|cut -d "-" -f 2`
STAGE_UC=`echo $DBNAME| rev |cut -d "-" -f 1 | rev`
STAGE_UC=$( echo "$STAGE_UC" | tr '[:lower:]' '[:upper:]' )
STAGE_LC=$( echo "$STAGE_UC" | tr '[:upper:]' '[:lower:]' )

#-----------------------------------------------------------------------------------------------------------------
#     evaluate conditional options
#-----------------------------------------------------------------------------------------------------------------

if [ "x$flowster" == "x1" -a "x$ctmrun" == "x1" ]
then
     RC=1
     logger_error "*************************************************************"
     logger_error "* -FS Option und -ctm Option wurden spezifiziert. Diese Optionen schliessen sich aus."
     logger_error "* RC=$RC"
     logger_error "* ROLLBACK wurde durchgefuehrt"
     logger_error "*************************************************************"
     exit ${RC}
fi

TICKET_NO=""
TICKET_LINK=""

# Skript-Anpassung: Ticket-Angabe ueber Flowster mueglich, jedoch nur zum  Schreiben des Ticket-Kommentars.
#if [ "x" == "x$flowster" ]; then
   manage_ticket_handling
#fi

#-----------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------
#     Main Processing
#-----------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------

#test exit

logger_info "Input File:       ${PRINT_INFILE_ORG}";
logger_info "Database:         ${DBNAME}  ";
logger_info "Stage:            ${STAGE_UC}";
logger_info "Schema:           ${DBSCHEMA}";
if [ "x" == "x$ticket" ];
   then :
   else
     logger_info "Ticket:           ${TICKET}";
fi

if [ "x$ctmrun" == "x1" ]
   then logger_info "Script wurde aus Control-M heraus gestartet.";EXECUTION_TYPE="CTM";
   elif [ "x$flowster" == "x1" ]
     then logger_info "Script wurde per Flowster Self Service gestartet.";EXECUTION_TYPE="FSS";
     else logger_info "Script wurde manuell gestartet.";EXECUTION_TYPE="Man";
fi
echo " "

rm -f ${SYSOUT}
RC=0

get_user_and_pwd

# Change Ownership of Log-Files to "oinstall":
for LOGFILES in `find ${DML_EXEC_SYSOUT} -name "${SCRIPTNAME}*" -user "$USER" -group barmstaf`
do
chgrp oinstall $LOGFILES
done

START_TIME_ALL=$(date +%s);

#-----------------------------------------------------------------------------------------------------------------
#-- Execute given File by SQL/Plus:
#-----------------------------------------------------------------------------------------------------------------
#set -x

FILENAME=$INPUTFILE

det_sql_file_encoding

execute_dml_file

#-----------------------------------------------------------------------------------------------------------------
#-- End-Processing
#-----------------------------------------------------------------------------------------------------------------

# Set ToDo Swiches:
SW_REPSAFE=1
SW_TICKET=0
SW_SYSOUT=0

REPSAFE_JOURNAL=""

# If Ticket is specified, write to ReportSafe and Ticket Comment
if ! [ "x" == "x$ticket" ];
   then
     SW_REPSAFE=1
     SW_TICKET=1
fi

if [ $PRINTOUT -eq 1 ]
   then
     SW_SYSOUT=1
fi
# Do End-Processing depending on ToDo-Switches:
if [ $SW_REPSAFE = 1 ]
 then
  save_log_2_reportsafe
 fi
if [ $SW_TICKET = 1 ]
 then
  jira_ticket_comment
fi
if [ $SW_SYSOUT = 1 ]
 then
  cat ${SYSOUT}
fi

# Write Message with Elapsed Execution Time:
END_TIME_ALL=$(date +%s)
ELAPSED_TIME_ALL=$(($END_TIME_ALL-$START_TIME_ALL))
((sec=ELAPSED_TIME_ALL%60, ELAPSED_TIME_ALL/=60, min=ELAPSED_TIME_ALL%60, hrs=ELAPSED_TIME_ALL/60))
ELAPSED_TIME_ALL=$(printf "%d:%02d:%02d" $hrs $min $sec)

echo "Elapsed Time over all is: "${ELAPSED_TIME_ALL}"."
logger_info "$SCRIPTNAME beendet: RC=${RC}";

# Write Record to Journal Table BVDBS.TDBS_ORADMLEXEC_PROTOKOLL @ DBAP:

write_jounal_table


## Cleanup log-files older than DELDAY days:
DELDAY="+7"        # Anzahl Tage fuers loeschen alter log Daten
find ${DML_EXEC_SYSOUT}/ -name "${SCRIPTNAME}*.*" -mtime ${DELDAY} -type f -exec rm -f {} \;

exit ${RC}
