# @(#) ============================================================================================
# @(#) Filename    : ORACDBlib
# @(#) Author      : Johannes Ahrends, CarajanDB GmbH
# @(#) Version     : 2.42
# @(#) Date        : 2024-09-10
# @(#) Description : Library mit allen Multitenant Funktionen, wird aus oralib gesourced
# @(#)               not directly startable
# @(#)
# @@(#)  Change History:
# @@(#)  Version  Date        Author        Description
# @@(#)  ------------------------------------------------------------------------------------------
# @@(#)  1.0      2024-02-05  jahr     Uebernahme aus ORAbaselib, ORAquerylib,
# @@(#)                                ORAcreatelib, ORAalterlib, ORAdeletelib
# @@(#)  1.1      2024-02-14  jahr     aufraeumen
# @@(#)  1.2      2024-02-19  jahr     Check auf /app Filesystem (war /app/oracle)
# @@(#)  1.3      2024-02-20  jahr     CreatePDB
# @@(#)  1.4      2024-02-21  jahr     Fehlerbehebung bei Mandatory PDB Skripts
# @@(#)  1.5      2024-02-22  jahr     Nutzung ORAeusreg zur Registrierung
# @@(#)  1.6      2024-03-15  jahr     RunRemoteSQL, RemoteInstanceState, GetStage,
# @@(#)                                GetServicename, GetDBsize, GetFRAsize
# @@(#)  1.7      2024-03-18  jahr     ModifyProfiles changed RunStageSQL
# @@(#)  1.8      2024-03-18  jahr     Added bvverifypw.sql
# @@(#)  1.9      2024-03-19  jahr     Added restart capability
# @@(#)  2.0      2024-03-20  jahr     CheckNumber, ConfigOEM, SetPasswords,
# @@(#)                                RotateSYSpw,CheckVersion,InstallSW
# @@(#)  2.1      2024-04-02  jahr     Cohesity Registration, Block Change Tracking
# @@(#)  2.2      2024-04-03  jahr     Added Check Instance to CreateDB
# @@(#)  2.3      2024-04-04  jahr     Added CreatePDB
# @@(#)  2.4      2024-04-09  jahr     Error Correction FRASIZE
# @@(#)  2.5      2024-04-10  jahr     Error correction in RunMandatoryPDB
# @@(#)  2.6      2024-05-21  mpils    shorten intentation from 3 to 2 spaces
# @@(#)                                added or updated function description
# @@(#)                                added local for local function variables
# @@(#)                                replaced IgnoreStep() by [Check/Update]RestartFile() and
# @@(#)                                and fixed RERUNFILE management
# @@(#)                                added function CreateDBFilesDir()
# @@(#)                                replaced exit by return inside functions
# @@(#)                                fixed several functions and added list of functions
# @@(#)                                renamed PortRunnig to PortIsFree
# @@(#)                                set success return value to 0 (bash default) if possible
# @@(#)                                changed return values e.g. PDBExists, ServiceExists,
# @@(#)                                ListenerUp, DirExists, InstanceUp, TnsadminFileExists
# @@(#)                                and fixed several functions used for CDB/PDB deployment
# @@(#)  2.7      2024-05-21  mpils    fixed escape of v$ view
# @@(#)  2.8      2024-05-22  mpils    fixed functions Parameter, CreateCDB, CreateDBServiceSQL,
# @@(#)                                CreateDBServiceSQL, RegsiterDB, DatabaseChecks
# @@(#)  2.9      2024-05-22  mpils    fixed some tee outputs
# @@(#)  2.10     2024-05-27  mpils    renamed CreateService to CreateDBService
# @@(#)                                renamed ServiceExists to DBServiceExists
# @@(#)                                renamed GetServicename to GetTnsServicename
# @@(#)  2.11     2024-06-03  mpils    fixed RunSingleSQL, DBRecompile, RunRemoteSQL, GetFRAsize
# @@(#)  2.12     2024-06-05  mpils    fixed CheckDBFilesystem
# @@(#)  2.13     2024-06-07  jahr     added CreateLogicalVolume
# @@(#)  2.14     2024-06-11  jahr     Changed max_pdbs to 1
# @@(#)  2.15     2024-06-13  jahr     Added SUDODIR Variable and uncomment DATAFILEDEST and FRAFILEDEST
# @@(#)                                Added Function ConfigureHugepages
# @@(#)  2.16     2024-06-14  jahr     Error correction ORAlvcreate
# @@(#)  2.17     2024-06-24  mpils    Added IsElementInList
# @@(#)  2.18     2024-06-27  jahr     added RunQualifiedSQL for BV$CMDB
# @@(#)  2.19     2024-07-01  jahr     Removed .sh from COHrunOrabackup and COHrmantab
# @@(#)  2.20     2024-07-01  mpils    Added NCHAR_SET to CreateCDB, fixed exec ORAlvcreate and CheckDBFilesystem()
# @@(#)                                Added DEFAULTNCHARSET, [DATA,FRA]FILEDEST, ORABINDIR, DBABINDIR
# @@(#)  2.21     2024-07-03  mpils    Changed SOFTWAREDIR to /oranfs/software/vendorsw
# @@(#)                                Changed CMD output like this "$CMD 2>&1|tee >(logger_debug)"
# @@(#)                                Fixes and cleanups in RunMandatory{CDB,PDB}()
# @@(#)                                Fixed DBRecompile() output, enhanced DatabaseChecks()
# @@(#)  2.22     2024-07-08  mpils    Added pdb_plug_in_violations to DatabaseChecks()
# @@(#)  2.23     2024-07-08  jahr     Scripts for unified auditing in CDB
# @@(#)  2.24     2024-07-09  jahr     Scripts for unified auditing in PDB, removed dbset
# @@(#)  2.25     2024-07-17  mpils    Changed pdb_admin to pdbadmin, enhanced DatabaseChecks()
# @@(#)  2.26     2024-07-19  mpils    Added GetCtmEnv()
# @@(#)  2.27     2024-07-22  mpils    Fixed DatabaseChecks()
# @@(#)  2.28     2024-07-23  mpils    Fixed ConfigOEM, GetCtmEnv and added ConfigFoglight
# @@(#)  2.29     2024-07-24  jahr     Using new Database template (BARM_CDB_19c_general.dbt)
# @@(#)  2.30     2024-07-24  mpils    added DBMONUSER to ConfigFoglight()
# @@(#)                                added GetCtmHostGroups() and ConfigCtmHostGroups()
# @@(#)                                comment out not used BARM_CDB_19c_general, COMPATDEFAULT
# @@(#)  2.31     2024-07-26  jahr     New Functions InstallSoftware and NewTNSADMIN
# @@(#)  2.32     2024-07-29  jahr     Changes because of using Read only Oracle Home
# @@(#)  2.33     2024-08-01  jahr     Changed Listener Configuration (delete if exists)
# @@(#)  2.34     2024-08-06  jahr     changed Unprotect Command and added ReadOnlyTNSadmin
# @@(#)  2.35     2024-08-07  jahr     Use original data and fra sizes
# @@(#)  2.36     2024-08-12  jahr     Removed Function CreateFilesystem because CreateLogicalVolume is better
# @@(#)  2.37     2024-08-22  mpils    Fixes and enhancements to DatabaseChecks, DBrecompile
# @@(#)                                Fixed RunMandatoryPDB()
# @@(#)  2.38     2024-09-02  jahr     new functions ListSWVersion and CheckSWVersion
# @@(#)  2.39     2024-09-05  mpils    Fixed RunMandatoryCDB()
# @@(#)  2.40     2024-09-10  jahr     New Functions LockUsersExcept KillSessionsExcept
# @@(#)  2.41     2024-09-10  jahr     New Function UnlockUsersExcept
# @@(#)  2.42     2024-09-10  jahr     Removed Function UnlockUsersExcept
# @(#) ============================================================================================
#
# List of functions:
#   Function                  Description
#   ------------------------- ---------------------------------------------------------------------
#   Parameter                 Define default paramater required for database management
#   CheckTemplate             Check DBTEMPLATE for specified ORACLE_VERSION and availability
#   CreateDirectory           Create a directory
#   CreatePDB                 Create a PDB in specified database
#   RegisterDB                Register pluggable database with OUD directory service
#   DeleteCDB                 Delete Oracle database using dbca
#   CleanupCDB                Delete CDB and cleanup environment
#   CreateDBFilesDir          Create database data or fra directory
#   CreateCDB                 Create a CDB database
#   RunMandatoryCDB           Run mandatory CDB scripts
#   RunMandatoryPDB           Run mandatory PDB scripts
#   CopyPasswords             Copy password files from nfs to pwd direcrtory
#   CreateDBService           Create database service
#   CreateDBServiceSQL        Create database service sql commands
#   CreateOratab              Create oratab entry
#   CreateFS                  Create filesystems for data and fra
#   AddOratab                 Add /etc/oratab entry
#   CreatePWFile              Create database password file
#   CreatePFile               Create PFile from SPFile
#   CreateUpgradeConfig       Create config file for datbase upgrade
#   AddMemlock                Add os memlock limit
#   OracleHome                Set Oracle home
#   DirExists                 Check if directory exists and some directory properties
#   TnsAdmin                  Check and set TNS_ADMIN variable
#   SetPath                   Set correct PATH variable
#   OracleEnvironment         Set Oracle database environment based on oratab
#   InstanceUp                Check if Oracle instance is running
#   NumberOfPDBS              Get number of PDBs from database
#   PDBExists                 Check if pluggable database exists
#   PDBConnect                Check if users are still connected to PDB
#   ListenerUp                Check if Oracle listener is up
#   PortIsFree                Check if port is in use
#   GetListenerPort           Checks if listener is running with the correct port
#   ListenerPort              Checks if listener is running on specified port
#   ListenerFileExists        Lookup listener entry in listener.ora
#   ListenerInTnsnamesora     Lookup listener entry in tnsnames.ora
#   CheckDBFilesystem         Check filesystem size
#   GetDBTemplate             Lookup matching Oracle database template from template directory
#   IsValidFile               Check if specified file is a valid file
#   RunQualifiedCDBSQL        Run SQL Script on CDB using user and password
#   RunQualifiedSQL           Run SQL Script on PDB using user and password
#   RunSingleSQL              Run SQL script on CDB or PDB
#   RunAllSQL                 Run all SQL scripts from specified directory on CDB or PDB
#   RunStageSQL               Run $SQLSCRIPTDIR/run.sql for db stage on CDB or PDB
#   DBServiceExists           Check if database service exists
#   SetOracleSID              Set ORACLE_SID using oraenv
#   CheckArchiving            Check if archiving is enabled
#   ListenerStart             Start Oracle listener
#   ListenerStop              Stops running Oracle listener
#   AlterPasswordCDB          Alter sys and system password for CDB using .pwdfile_db_sys[tem]
#   AlterPassword             Alter common database user password
#   SwitchLogfile             Switch database redolog file
#   StopInstance              Shutdown the Oracle database instance if still running
#   StartInstance             Startup the Oracle database instance if not running
#   DeleteFiles               Delete files with given name pattern
#   DeleteDirectory           Delete a directory
#   RemoveOratab              Remove an entry from oratab
#   DeletePDB                 Remove PDB from database
#   ListenerDown              Checks if listener is running and stop it using stop or kill
#   RemoveTnsnamesEntry       Remove a tnsnames entry using RestoreOldFile function
#   RemoveListenerEntry       Remove a listener entry using RestoreOldFile function
#   DeleteDBService           Remove a database service from pdb
#   DeleteDBServiceSQL        Remove a database service from pdb using SQLs
#   UnregisterPDB             Unregister Pluggable Database with Directory Service
#   UnregisterPDBalt          Unregister Pluggable Database with Directory Service
#   DeleteListener            Remove Oracle listener
#   CreateListener            Creates an Oracle listener and configure ldap.ora and sqlnet.ora
#   CreateTNSalias            Creates a TNS Alias
#   ConfigOratab              Change /etc/oratab entry (set :N to :Y)
#   ValidStages               Check if provided stage shortcut is valid
#   DBRecompile               Runs recompilation of all database objects using utlrp.sql
#   DatabaseChecks            Runs several sql based cehcks on database
#   GetStage                  Get stage from DBNAME
#   GetTnsServicename         Generate tns service name based on DBNAME
#   RemoteInstanceState       Check if instance is in OPEN mode using a remote connection
#   RunRemoteSQL              Run sql file on database using a remote connection
#   GetDBsize                 Get size of database (data and temp files) in mb
#   GetFRAsize                Get size of fast recovery area in mb
#   ModifyProfiles            ALTER PROFILE for database
#   CheckRestartFile          Restart capability function - Check if step already done
#   UpdateRestartFile         Restart capability function - Update step status
#   CheckNumber               Validate if parameter $1 is a number
#   ConfigOEM                 Run configuration for Oracle Cloud Control
#   SetPasswords              Set passwords for important accounts
#   RotateSYSpw               Runs password rotation for sys and system
#   GetOracleHomeFromVersion  Helper function for CheckVersion()
#   CheckVersion              Get software version numbers and set ORACLE_HOME path
#   InstallSoftware           Clone Oracle database software
#   ProtectDatabase           Add Database to Cohesity protection group
#   BlockChangeTracking       Enables database block change tracking
#   BackupDatabase            Runs a Cohesity Oracle database backup
#   CreateLogicalVolume       Create Logical Volumes
#   ConfigureHugepages        Configure Hugepages
#   IsElementInList           Lookup for element in list of elements
#   GetCtmEnv                 Get CTM environment from CTM config data
#   GetCtmHostGroups          Get CTM hostgroups from cmdb for specified group identifier
#   ConfigCtmHostGroups       Add host to CTM host groups defined for specific group identifier
#   ConfigFoglight            Add a create/delete entry for db to cmdb for Foglight integration
#   InstallSoftware           Use Oracle Goldenimage and Read Only Oracle Home
#   MewTNSADMIN               Make use of Read Only Oracle Home
#   ReadOnlyTNSAdmin          Initial sqlnet.ora and ldap.ora in Read Only Oracle Homes

# =================================================================================================
set -o pipefail   # required for error escalation through pipes

# =================================================================================================
# Parameter
#   - Define default paramater required for database management
# Input parameter:
#   - none
# Required variables:
#   - several variables used (see function code)
# Set variables:
#   - several variables used (see function code)
# =================================================================================================

Parameter() {
  logger_debug "--> Function $FUNCNAME"

  ORABASEDIR="${ORABASEDIR:-/app/oracle}"
  DBABINDIR="${DBABINDIR:-/app/dbacommon/bin/}"
  ORABINDIR="${ORABINDIR:-/app/oracle/bin}"
  SCRIPTDIR="$ORABINDIR"  # can be removed in future when replaced by ORABINDIR in all scripts
  logger_debug "ORABASEDIR=$ORABASEDIR"
  logger_debug "DBABINDIR=$DBABINDIR"
  logger_debug "ORABINDIR=$ORABINDIR"
  logger_debug "SCRIPTDIR=$SCRIPTDIR"

  ETCDIR="${ORABASEDIR}/admin/etc"
  PWDDIR="${ETCDIR}/pwddir"
  NFSPWDDIR="/oranfs/share/ora_admin/SYSTEM/pwddir"
  DEFAULTPWD="BarDB2020_abcdefg12345"
  SQLBASEDIR="${ORABINDIR}/sql"
  BACKUPDIR="${ORABASEDIR}/admin/backup"
  RMANTAB="${BASEDIR}/config/backup/rmantab"
  ORATAB="/etc/oratab"
  ORACLE_SID="${ORACLE_SID:-NONE}"
  ORACLE_BASE="${ORACLE_BASE:-/app/oracle}"
  ORACLE_HOME="${ORACLE_HOME:-NONE}"
  [ `echo $ORACLE_HOME | grep "agent" | wc -l` -eq 0 ] || ORACLE_HOME="NONE"
  DBNAME="${DBNAME:-NONE}"
  DBUNAME="${DBUNAME:-NONE}"
  PDBNAME="NONE"
  DGSIDE1="S1"
  DEFAULTCHARSET="WE8ISO8859P15"      # barm supported unicode  cs: AL32UTF8
  DEFAULTNCHARSET="AL16UTF16"         # barm supported unicode ncs: AL16UTF16 (except UTF8 for DMS)
  SERVICENAME="NONE"
  SQLNAME="NONE"
  DBUNAMEPOSTFIX="S1"
  PORT=1601
  OLDHOME="NONE"
  NEWHOME="NONE"
  OLDHOST="NONE"
  PROTECTIONGROUP="NONE"
  # DATAFILEDEST="${DATAFILEDEST:-/app/oracle/data}"
  # FRAFILEDEST="${FRAFILEDEST:-/app/oracle/fra}"
  # DATAFILEDEST="${DATAFILEDEST:-/oradata}"
  # FRAFILEDEST="${FRAFILEDEST:-/orafra}"
  DATAFILEDEST="/oradata"
  FRAFILEDEST="/orafra"
  DEFAULTDATASIZEMB=10000     # used for lv/fs creation
  DEFAULTFRASIZEMB=3000       # used for lv/fs creation
  MINDATASIZEMB=3000
  MINFRASIZEMB=3000
  DEFAULTSGATARGET=2000
  DEFAULTPGATARGET=1000
  # BARMDEFAULTTEMPLATE="BARM_CDB_19c_general.dbt"    # not used in any script!
  # COMPATDEFAULT="19.10.0.0.0"         # not used in any script!
  TEMPLATEDIR="$ORABINDIR/templates/dbca"
  DEFAULTTEMPLATE="$TEMPLATEDIR/BARM_CDB_19c_general.dbt"
  ORAPRODDIR="${ORABASEDIR}/product"
  # SOFTWAREDIR="/app/oracle/software/vendorsw"
  SOFTWAREDIR="/oranfs/software/vendorsw"
  DBSOFTWAREDIR="/misc/oracle/linux/GoldenImage"
  AUTOUPGRADEDIR="/app/logs/autoupgrade"
  SUDODIR="/app/oracle/bin/init"
  TEMPLATECDB="NONE"
  LISTENER="LISTENER"
  RUNNINGPORT=0
  CLEANUP=0
  START=0
  STOP=0
  CREATE=0
  DELETE=0
  FORCE=0
  ANALYZE=0
  DEPLOY=0
  ACTIVATE=0
  MAXPDBS=4
  SKIP=0
  JUMP=0
  RESTART=0
  LISTJOBS=0
  WARN=0
  INSTALLSW=0
  DATUM=`date "+%y%m%d"`
  TIMESTAMP=`date "+%y%m%d_%H%M%S"`
  SQLFILE="/tmp/statement${DATUM}.sql"

  # RESTARTFILE name default ..
  # If you like:
  # - You can overwrite this variable using your own name convention
  # - The content will be evaluates by 'eval echo $RESTARTFILE'
  #   So you can define a dynamic content like next example.
  #   e.g. RESTARTFILE="$ORABASEDIR/admin/log/`basename $0`\${MYVAR1/#/_}\$([ -z \"\${MYVAR2}\" ] || echo \${MYVAR2/#/_}).lck"
  RESTARTFILE=$ORABASEDIR/admin/log/`basename $0`.lck

  #
  #  Database Parameter
  #
  DBDOMAIN="unix.lan"
  HOSTDOMAIN="barmenia.lan"
  STORAGETYPE="FS"
  #
  #  Network Parameter
  #
  TNS_ADMIN="/app/oracle/admin/dbhome/network/admin"
  LDAPORAFILE="$ORABINDIR/templates/netca/BARM_ldap.ora"
  NETCARESPONSEFILE="$ORABINDIR/templates/netca/BARM_netca.rsp"
  SQLNETORAFILE="$ORABINDIR/templates/netca/BARM_sqlnet.ora"
  NETCALOGFILE="${ORABASEDIR}/admin/log/${SCRIPTNAME}_netca.`date +%Y%m%d%H%M%S`.log"
  #
  # Mail
  #
  if [ "$SCRIPTDIR" != "/app/oracle/bin" ]; then
    MAILTO="unix-dba@barmenia.de"
    BARMLANMAILTO="johannes.ahrends@barmenia.de"
    UNIXLANMAILTO="johannes.ahrends@barmenia.de"
    NBUMAILTO="johannes.ahrends@barmenia.de"
    CTMMAILTO="johannes.ahrends@barmenia.de, johannes.ahrends@barmenia.de"
    SENDER="johannes.ahrends@barmenia.de"
  else
    MAILTO="unix-dba@barmenia.de"
    BARMLANMAILTO="linux-support@barmenia.de"
    UNIXLANMAILTO="dns-admins@barmenia.de"
    NBUMAILTO="storagebackup-support@barmenia.de"
    CTMMAILTO="Dezentrale-Produktion@barmenia.de, unix-pv@barmenia.de"
    SENDER="unix-dba@barmenia.de"
  fi
  SENDMAIL="/usr/sbin/sendmail"

  logger_debug "<-- Function $FUNCNAME"
  return 0
}

# =================================================================================================
# CheckTemplate
#   - Check specified db template for availability and specified Oracle version
#   - An Oracle version matching template will be fetched if no template was specified.
# Input parameter:
#   - $1: Oracle software version
#   - $2: DB template file (full path qualified)
#   - $3: DB template directory for GetDBTemplate function (optional)
# Required variables:
#   - $DBTEMPLATE
# Set variables:
#   - $DBTEMPLATE (set in function GetDBTemplate)
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CheckTemplate() {
  logger_debug "--> Function $FUNCNAME"
  local ORA_VER=$1
  local ORA_TPL=$2
  local TPL_DIR=${3:-$TEMPLATEDIR}
  local RC=0
  local SWVERSION=""
  local DBVERSION=""

  if [ -n "$ORA_TPL" ]; then
    if [ -r "$ORA_TPL" ]; then
      SWVERSION=`echo $ORA_VER | cut -c 1-2`
      logger_debug "SWVERSION=$SWVERSION"
      DBVERSION=`fgrep 'version=' "$ORA_TPL"|rev|cut -d. -f5|cut -d'"' -f1|rev`
      logger_debug "DBVERSION=$DBVERSION"
      if [ "$SWVERSION" != "$DBVERSION" ]
      then
        logger_error "Template $ORA_TPL and Software $SWVERSION are incompabible"
        RC=1
      fi
    else
      logger_error "Not a valid Template $ORA_TPL"
      RC=2
    fi
  else
    GetDBTemplate "$ORA_VER" "$TPL_DIR"
    RC=$?
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreateDirectory
#   - Create a directory
# Input parameter:
#   - $1: Directory
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CreateDirectory() {
  logger_debug "--> Function $FUNCNAME"
  local DIRECTORY="$1"
  local RC=0
  local TOPDIR=""
  DirExists $DIRECTORY
  if [ $? -ne 10 ]; then
    logger_error "Directory $DIRECTORY already exists"
    RC=10
  else
    TOPDIR=`dirname $DIRECTORY`
    DirExists $TOPDIR
    if [ $? -ne 2 ]; then
      logger_error "Directory $TOPDIR does not exist or is not writable"
      RC=10
    else
      mkdir -p $DIRECTORY
      if [ $? -eq 0 ]; then
        logger_info "Directory $DIRECTORY created"
      else
        logger_error "Unable to Create Directory $DIRECTORY"
        RC=10
      fi
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreatePDB
#   - Create a PDB in specified database
# Input parameter:
#   - $1: StepID for using restartfile (optional)
#   - $2: CDB name
#   - $3: PDB name
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID, $MAXPDBS
# Set variables:
#   - $DBSIZEMB
# Return Values
#   -   0: Successful
#   -   1: PDB already exist
#   -  10: Unsuccessful
#   - 255: Error in sql execution
# =================================================================================================

CreatePDB() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local DBNAME="$2"
  local PDBNAME="$3"
  local RC=0
  local S=0
  local CREATEPDB=""

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  for S in {1..4}
  do
    if [ "$RC" -ne 0 ]; then
      break   # Skip all steps if an error has occurred
    fi
    case $S in
      1) # check if PDB exists
        PDBExists $PDBNAME
        if [ $? -eq 0 ]; then
          logger_error "Pluggable Database $PDBNAME already exists"
          RC=1
        fi
      ;;
      2) # Check if Maximum Number of PDBs has been reached
        NumberOfPDBS
        RC=$?
        if [ "$RC" -ne 0 -o -z "$NUMPDBS" ]; then
          RC=10
        elif [ $NUMPDBS -ge $MAXPDBS ]; then
          logger_error "Maximum Number of PDBs reached"
          RC=10
        fi
      ;;
      3) #  Create PDB
        CREATEPDB="$($ORACLE_HOME/bin/sqlplus -s / as sysdba <<EOSQL # 2>/dev/null
          WHENEVER OSERROR EXIT 255
          WHENEVER SQLERROR EXIT SQL.SQLCODE
          SET heading off feedback off pages 0
          CREATE PLUGGABLE DATABASE $PDBNAME ADMIN USER pdbadmin
            IDENTIFIED BY "$DEFAULTPWD" DEFAULT TABLESPACE users;
          ALTER PLUGGABLE DATABASE $PDBNAME OPEN INSTANCES=ALL;
          ALTER PLUGGABLE DATABASE $PDBNAME SAVE STATE INSTANCES=ALL;
EOSQL
)"
        RC=$?
        if [ "$RC" -ne 0 ]; then
          logger_error "Unable to create Pluggable Database $PDBNAME (RC=$RC)"
          logger_error "$CREATEPDB"
          RC=255
        fi
      ;;
      4) # check if PDB exists
        PDBExists $PDBNAME
        RC=$?
        if [ "$RC" -ne 0 ]; then
          logger_error "Unable to create Pluggable Database $PDBNAME"
          RC=10
        fi
      ;;
      *) ;;
    esac
  done

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RegisterDB
#   - Register pluggable database with OUD directory service
#   - Register CDB if no PDB is specified otherwise a PDB
# Input parameter:
#   - $1: StepID for using restartfile (optional)
#   - $2: CDB or PDB name (optional, default CDB$ROOT)
# Required variables:
#   - several variables (see function code)
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RegisterDB() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local CONNAME="${2:-CDB\$ROOT}"
  local PDBNAME=""
  local RC=0
  local CMD=""

  # Set PDBNAME for CheckRestartFile
  if [ -n "$CONNAME" -a "$CONNAME" != "NONE" -a "$CONNAME" != "CDB\$ROOT" ]; then
    PDBNAME="$CONNAME"
  fi

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  logger_debug "DBNAME=$DBNAME"
  logger_debug "DBUNAME=$DBUNAME"
  logger_debug "ORACLE_SID=$ORACLE_SID"
  logger_debug "ORACLE_HOME=$ORACLE_HOME"
  logger_debug "ORACLE_BASE=$ORACLE_BASE"
  logger_debug "PDBNAME=$PDBNAME"
  # NewTNSADMIN
  if [ -n "$PDBNAME" ]; then
    CMD="$SCRIPTDIR/ORAeusreg -opt add -sid $DBNAME -pdb $PDBNAME"
  else
    CMD="$SCRIPTDIR/ORAeusreg -opt add -sid $DBNAME"
  fi
  logger_debug "$CMD"
  $CMD 2>&1 | tee >(logger_debug)
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_error "Could not register database for OUD (RC=$RC)"
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# DeleteCDB
#   - Delete Oracle database using dbca.
#   - If database is in open mode the database will not be deleted
#   - In all other states database will be aborted
#     and started in restricted mount mode for running dbca -deleteDatabase
#   - If FORCE=1 then database files will be removed regardless of the current state.
# Input parameter:
#   - $1: ORACLE_SID
# Required variables:
#   - $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

DeleteCDB() {
  logger_debug "--> Function $FUNCNAME"
  local ORACLE_SID="$1"
  local RC=0
  local S=0
  local FORCE="${FORCE:-0}"
  logger_debug "ORACLE_HOME=$ORACLE_HOME"
  logger_debug "ORACLE_SID=$ORACLE_SID"

  for S in {1..6}
  do
    if [ "$RC" -ne 0 ]; then
      logger_error "Unable to delete Database $ORACLE_SID"
      break   # Skip all steps if an error has occurred
    fi
    case $S in
      1) # Check database instance mode
        InstanceUp $ORACLE_SID
        RC=$?
        if [ "$RC" -lt 4 -a "$FORCE" -eq 0 ]; then
          #  Database is open mode
          logger_debug "Instance running (RC=$RC) and FORCE=$FORCE"
          RC=10
        fi
      ;;
      2) # check if spfile exist
        if [ ! -r $ORACLE_HOME/dbs/spfile${ORACLE_SID}.ora ]; then
          logger_error "No spfile found for Instance $ORACLE_SID"
          RC=11
        fi
      ;;
      3) # database will be crashed and started in mount mode
        ${ORACLE_HOME}/bin/sqlplus -s / as sysdba <<EOSQL
        shutdown abort
        startup mount restrict
EOSQL
        RC=$?
        if [ "$RC" -ne 0 ]; then
          logger_error "Error while startup mount restrict (RC=$RC)"
          RC=12
        fi
      ;;
      4) # Check instance status
        InstanceUp $ORACLE_SID
        RC=$?
        if [ "$RC" -eq 2 ]; then
          # db in mounted mode
          RC=0
        else
          logger_error "Database instance not mounted (RC=$RC)"
          RC=13
        fi
      ;;
      5) # Delete database using dbca
        source $PWDDIR/.pwdfile_db_sys
        CMD="$ORACLE_HOME/bin/dbca -silent -deleteDatabase -sourceDB $ORACLE_SID -sysDBAUserName sys -sysDBAPassword $PWDSYS -forceArchiveLogDeletion -sid $ORACLE_SID"
        logger_debug "$CMD"
        $CMD 2>&1 | tee >(logger_debug)
        RC=$?
        if [ "$RC" -ne 0 ]
        then
          logger_error "Error in command 'dbca -deleteDatabase' (RC=$RC)"
          logger_error "Please check $ORACLE_BASE/cfgtoolslog/$ORACLE_SID files"
          RC=14
        fi
      ;;
      6) logger_info "Database $ORACLE_SID deleted" ;;
      *) ;;
    esac
  done

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CleanupCDB
#   - Delete CDB and cleanup environment
# Input parameter:
#   - none
# Required variables:
#   - $ORACLE_SID, $DBNAME, $DBUNAME, $FORCE
#   - $ORACLE_BASE, $ORACLE_HOME, $DATAFILEDEST, $FRAFILEDEST
# Set variables:
#   - $DBSIZEMB
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CleanupCDB() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local ADRDBNAME=""
  DeleteCDB $ORACLE_SID
  RC=$?
  if [ "$RC" -ne 0 -a "$FORCE" -eq 0 ]
  then
    logger_error "Unable to delete a running database"
    RC=12
  else
    logger_debug "DBUNAME=$DBUNAME"
    RemoveOratab /etc/oratab ${ORACLE_SID}:
    if [ -n "$DBUNAME" ]
    then
      DeleteDirectory ${DATAFILEDEST}/$DBUNAME
      DeleteDirectory ${FRAFILEDEST}/$DBUNAME
      DeleteDirectory ${ORACLE_BASE}/admin/$DBUNAME
    fi
    if [ -n "$DBNAME" ]
    then
      DeleteDirectory ${ORACLE_BASE}/admin/$DBNAME
      DeleteFiles $ORACLE_HOME/dbs $ORACLE_SID
    fi
    ADRDBNAME=`echo ${DBUNAME}|tr "A-Z" "a-z"`
    logger_debug "ADRDBNAME=$ADRDBNAME"
    if [ -n "$ADRDBNAME" ]
    then
      DeleteDirectory ${ORACLE_BASE}/diag/rdbms/$ADRDBNAME
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreateDBFilesDir
#   - Create database data or fra directory
# Input parameter:
#   - $1: Directory for data or fra
#   - $2: Filesystem free space MB required
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CreateDBFilesDir() {
  logger_debug "--> Function $FUNCNAME"
  local DIRECTORY="$1"  # data or fra directory
  local FREEMB="$2"
  local FORCE=${FORCE:-0}
  local RC=0
  local S=0
  logger_debug "DIRECTORY=$DIRECTORY"
  logger_debug "FREEMB=$FREEMB"

  for S in {1..3}
  do
    if [ "$RC" -ne 0 ]; then
      break   # Skip all steps if an error has occurred
    fi
    case $S in
      1) # Ensure directory exist
        mkdir -p "$DIRECTORY" 2>/dev/null
        chmod 755 $DIRECTORY 2>/dev/null
      ;;
      2) # Check if directory is empty
        DirExists $DIRECTORY
        RC=$?
        if [ $RC -eq 4 ]; then
          logger_error "Directory $DIRECTORY is not empty (RC=$RC)"
          # Delete database leftovers if FORCE=1
          if [ "$FORCE" -eq 0 ]; then
            RC=10
          else
            logger_debug "Run CleanupCDB for directory cleanup"
            CleanupCDB
            RC=$?
            if [ $RC -ne 0 ]; then
              logger_error "Unable to cleanup old Database (RC=$RC)"
              RC=11
            fi
          fi
        fi
      ;;
      3) # Check directory, filesystem and size
        CheckDBFilesystem $DIRECTORY $FREEMB
        RC=$?
        logger_debug "RC1=$RC"
        if [ $RC -ne 0 ]; then
          RC=12
        fi
      ;;
      *) ;;
    esac
  done

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreateCDB
#   - Create a CDB database
# Input parameter:
#   - $1: StepID for using restartfile (optional)
#   - $2: ORACLE_SID
#   - $3: CHARSET
#   - $4: NCHARSET
#   - $5: ORACLE_HOME
#   - $6: DBTEMPLATE
# Required variables:
#   - $ORACLE_BASE
#   - $DBNAME, $DBUNAMEPOSTFIX, $DBDOMAIN, $PORT
#   - $DATAFILEDEST, $DATASIZEMB, $FRAFILEDEST $FRASIZEMB
#   - $DBTEMPLATE, $STORAGETYPE, $DEFAULTPWD
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CreateCDB() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local ORACLE_SID="$2"
  local CHARSET="$3"
  local NCHARSET="$4"
  local ORACLE_HOME="$5"
  local DBTEMPLATE="$6"
  local RC=0
  local S=0
  local DBUNAME=""
  local TOTALMEMORY=""
  local SGATARGET=""
  local PGATARGET=""
  local FRASIZE=""
  local GDBNAME=""
  local LOCAL_LISTENER="(ADDRESS=(PROTOCOL=TCP)(HOST=$(hostname -f))(PORT=${PORT}))"
  local INITPARAMS=""
  local CMD=""
  local SQLOUT=""

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  # Build db unique name
  if [ -z "$DBUNAMEPOSTFIX" ]
  then
    DBUNAME=${ORACLE_SID}
  else
    DBUNAME=${ORACLE_SID}_$DBUNAMEPOSTFIX
  fi
  logger_debug "DBUNAME=$DBUNAME"

  for S in {1..7}
  do
    if [ "$RC" -ne 0 ]; then
      break   # Skip all steps if an error has occurred
    fi
    case $S in
      1) # Check if the Instance is already up and running
        if [ `InstanceUp $DBNAME;echo $?` -ne 4 ]; then
          logger_error "Instance $DBNAME is already running"
          RC=10
        fi
      ;;
      2) # Create data directory
        CreateDBFilesDir "${DATAFILEDEST}/$DBUNAME" "$DATASIZEMB"
        if [ "$RC" -ne 0 ]; then
          logger_error "Could not create sufficient sized data directory (RC=$RC)"
          RC=20
        fi
      ;;
      3) # Create fra directory
        CreateDBFilesDir "${FRAFILEDEST}/$DBUNAME" "$FRASIZEMB"
        if [ "$RC" -ne 0 ]; then
          logger_error "Could not create sufficient sized data directory (RC=$RC)"
          RC=30
        fi
      ;;
      4) # Some calculations and preparations

        # Calculate Memory Usage as 50% of total memory for sga and 20 % for pga
        TOTALMEMORY=`free -g |grep Mem |awk '{ print $2 }'`000
        if [ "$TOTALMEMORY" -lt 5000 ]
        then
          SGATARGET=$DEFAULTSGATARGET
          PGATARGET=$DEFAULTPGATARGET
        else
          SGATARGET=`expr ${TOTALMEMORY} / 2`
          PGATARGET=`expr $TOTALMEMORY / 5`
        fi
        logger_debug "SGATARGET=$SGATARGET"
        logger_debug "PGATARGET=$PGATARGET"

        # Calculate db_recovery_file_dest_size as 80% of available space in FRA Filesystem (FRAFILEDEST)
        if [ ! -d ${FRAFILEDEST}/${DBUNAME} ]
        then
          logger_error "Unable to create Filesystem $FRAFILEDEST"
          exit 5
        fi
        FRASIZE=`df -m ${FRAFILEDEST}/${DBUNAME} | tail -1 | awk '{ print $4 }'`
        logger_debug "FRASIZE=$FRASIZE"
        FRASIZE=`expr $FRASIZE \* 8 / 10`   # 80% of fra lv
        logger_debug "FRASIZE=$FRASIZE"
        GDBNAME="${ORACLE_SID}.${DBDOMAIN}"
        INITPARAMS="
         db_unique_name=$DBUNAME
        ,db_recovery_file_dest_size=${FRASIZE}M
        # ,local_listener='${LOCAL_LISTENER}'     # dbca ignores local_listener in -initParams or dbTemplate
        ,enable_pluggable_database=true
        ,max_pdbs=1
        ,sga_target=${SGATARGET}M
        ,pga_aggregate_target=${PGATARGET}M
        # ,audit_file_dest='${ORACLE_BASE}/admin/${ORACLE_SID}/adump'
        "
        INITPARAMS="$(echo "$INITPARAMS"|grep -v -e '^[ ]*#' -e '^[ ]*$')"
        INITPARAMS="$(echo $INITPARAMS|sed 's/ ,/,/g')"
        logger_debug "INITPARAMS:$INITPARAMS"

        # logger_debug "PWDDIR=$PWDDIR"
        # source $PWDDIR/.pwdfile_db_sys
        # source $PWDDIR/.pwdfile_db_system
      ;;
      5) # Create database
        CMD="${ORACLE_HOME}/bin/dbca -silent -ignorePreReqs -createDatabase
  -templateName $DBTEMPLATE -gDbName $GDBNAME -sid $ORACLE_SID
  -sysPassword $DEFAULTPWD -systemPassword $DEFAULTPWD
  -createAsContainerDatabase true
  -UseLocalUndoForPDBs true
  -storageType $STORAGETYPE
  -datafileDestination $DATAFILEDEST
  -recoveryAreaDestination $FRAFILEDEST
  -characterSet $CHARSET
  -nationalCharacterSet $NCHARSET
  -useOMF true -numberOfPDBs 0
  -initParams $INITPARAMS"
        logger_debug "$CMD"
        logger_info "Creating Database ${ORACLE_SID}. This might take around 30 minutes."
        # logger_info "> Current state can be found here /tmp/createdb_${ORACLE_SID}.${DATUM}"
        logger_info "> Database logfile can be found here $ORACLE_BASE/diag/rdbms/${DBUNAME,,}/${ORACLE_SID}/trace/alert_${ORACLE_SID}.log"
        logger_info "> DBCA logs are created here $ORACLE_BASE/cfgtoollogs/dbca/${DBUNAME}/"
        logger_info "> e.g. $ORACLE_BASE/cfgtoollogs/dbca/${DBUNAME}/${DBUNAME}.log"
        # $CMD > /tmp/createdb_${ORACLE_SID}.$DATUM 2>&1
        $CMD 2>&1 | tee >(logger_debug)
        RC=$?
        if [ $RC -ne 0 ]; then
          logger_error "Unable to create database $ORACLE_SID (RC=$RC)"
          logger_error "Please check $ORACLE_BASE/cfgtoollogs/dbca/$DBUNAME/* Files"
          RC=50
        fi
      ;;
      6) # Set local_listener parameter
        # Workaround for dbca doesn't use specified local_listener from -initParams
        # see https://community.oracle.com/mosc/discussion/4270694
        logger_info "Set local_lister parameter "
        export ORACLE_SID
        SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL 2>&1
        WHENEVER SQLERROR EXIT SQL.SQLCODE
        CONNECT / AS SYSDBA
        SET heading off feedback off pages 0
        alter system set local_listener='${LOCAL_LISTENER}' scope=both;
        select 'local_listener='||value from v\$parameter where name='local_listener';
EOSQL
)"
        RC=$?
        if [ $RC -ne 0 ]; then
          logger_error "Unable to set local_listener parameter (RC=$RC)"
          logger_debug "LOCAL_LISTENER=$LOCAL_LISTENER"
          RC=60
        fi
        logger_debug "SQLOUT=$SQLOUT"
      ;;
      7) logger_info "Database $ORACLE_SID successfully created" ;;
      *) ;;
    esac
  done

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RunMandatoryCDB
#   - Run mandatory CDB scripts
#   - Minimal script error handling implemented yet!
# Input parameter:
#   - $1: StepID for using restartfile (optional)
#   - $2: Default script error return code, default: 0 (optional)
# Required variables:
#   - $PWDDIR, $SCRIPTDIR, $SQLBASEDIR
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RunMandatoryCDB() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local DC=${2:-0}      # default: 0 means no script error handling
  local RC=0

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  # Minimal script error handling implemented yet!

  source $PWDDIR/.pwdfile_db_bvaud || RC=$DC
  # source $PWDDIR/.pwdfile_db_pwdadm || RC=$DC
  source $PWDDIR/.pwdfile_db_bvbtcusr || RC=$DC
  source $PWDDIR/.pwdfile_db_sysmgmnt || RC=$DC
  source $PWDDIR/.pwdfile_db_dbsnmp || RC=$DC
  source $PWDDIR/.pwdfile_db_paomon || RC=$DC
  source $PWDDIR/.pwdfile_db_system || RC=$DC
  source $PWDDIR/.pwdfile_db_sys || RC=$DC

  RunSingleSQL 'CDB$ROOT' "$SCRIPTDIR/plsql/bvverifypw.sql" || RC=$DC
  RunStageSQL  'CDB$ROOT' "$SQLBASEDIR/ORAconfigCDB/1_profiles" || RC=$DC
  RunStageSQL  'CDB$ROOT' "$SQLBASEDIR/ORAconfigCDB/2_accounts" "$PWDSYSMGMNT" || RC=$DC

  RunStageSQL  'CDB$ROOT' "$SQLBASEDIR/ORAconfigCDB/6_allg_monitoring" "$PWDPAOMON" "$PWDDBSNMP" || RC=$DC
  RunStageSQL  'CDB$ROOT' "$SQLBASEDIR/ORAconfigCDB/8_UnifiedAuditing" "$PWDBVAUD" || RC=$DC
  RunStageSQL  'CDB$ROOT' "$SQLBASEDIR/ORAconfigCDB/9_AlterUsers" || RC=$DC

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RunMandatoryPDB
#   - Run mandatory PDB scripts
#   - Minimal script error handling implemented yet!
# Input parameter:
#   - $1: StepID for using restartfile (optional)
#   - $2: PDB name (optional)
#   - $3: Default script error return code, default: 0 (optional)
# Required variables:
#   - $PWDDIR, $SCRIPTDIR, $SQLBASEDIR
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RunMandatoryPDB() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local PDBNAME="${2:-NONE}"
  local DC=${3:-0}  # default: 0 means no script error handling
  local RC=0

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  PDBExists "$PDBNAME"
  if [ $? -ne 0 ]
  then
    logger_fatal "PDB $PDBNAME does not exist"
    RC=100
  else
    # Minimal script error handling implemented yet!

    source $PWDDIR/.pwdfile_db_bvbtcusr || RC=$DC
    source $PWDDIR/.pwdfile_db_bvbtdusr || RC=$DC
    source $PWDDIR/.pwdfile_db_bvent || RC=$DC
    # BV$AUD user pwd for dblink to DBAP
    source $PWDDIR/.pwdfile_db_bvaud || RC=$DC
    source $PWDDIR/.pwdfile_db_bvcmdb || RC=$DC

    #  Generic Procedures and Functions
    RunSingleSQL    "$PDBNAME" "$SCRIPTDIR/plsql/bvverifypw.sql" || RC=$DC
    RunStageSQL     "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/1_profiles" || RC=$DC
    # RunStageSQL     "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/1_passwordmgmt" || RC=$DC      #### old stuff
    RunStageSQL     "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/2_users" "$PWDBVBTCUSR" "$PWDBVBTDUSR" "$PWDBVCMDB" || RC=$DC
    RunQualifiedSQL "$PDBNAME" 'BV$CMDB' "$PWDBVCMDB"  "$SQLBASEDIR/ORAconfigPDB/2_users/create_cmdb_dblink.sql" "$PWDBVCMDB" || RC=$DC
    RunSingleSQL    "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/2_users/lock_cmdb_user.sql" || RC=$DC
    RunStageSQL     "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/3_procs" || RC=$DC
    RunStageSQL     "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/5_directories" || RC=$DC

    # Schemasave
    RunSingleSQL    "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/3a_schema_save/0_create_user.sql" "$PWDBVENT" || RC=$DC
    RunQualifiedSQL "$PDBNAME" 'BV$ENT' "$PWDBVENT" "$SQLBASEDIR/ORAconfigPDB/3a_schema_save/1_create_dblink.sql" "$PWDBVENT" || RC=$DC
    RunStageSQL     "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/3a_schema_save" || RC=$DC

    # Auditing
    # RunStageSQL     "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/8_AuditingAndOUD" "$PWDBVAUD_DEF" "$PWDBVAUD" || RC=$DC    #### old stuff
    RunStageSQL     "$PDBNAME" "$SQLBASEDIR/ORAconfigPDB/8_UnifiedAuditing" "$PWDBVAUD" || RC=$DC

    #  Run all Scripts in PDB directory
    #
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CopyPasswords
#   - Copy password files from nfs to pwd direcrtory
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Required variables:
#   - $PWDDIR
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CopyPasswords() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local RC=0
  local DirRC=0
  local SKIP=0
  local CMD=""

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  if [ -z "$PWDDIR" ]; then
    logger_error "Variable PWDDIR not defined"
    RC=100
  else
    DirExists $PWDDIR
    DirRC=$?
    if  [ "$DirRC" -eq 4 ]; then
      # Directory exists and is not empty
      SKIP=1
      logger_info "Directory $PWDDIR is not empty. Skip function $FUNCNAME now."
    elif [ "$DirRC" -eq 10 ]; then
      # Directory doesnt exist
      CMD="mkdir -p $PWDDIR"
      logger_debug "$CMD"
      $CMD 2>&1 | logger_debug
      RC=$?
      if [ "$RC" -ne 0 ]; then
        logger_error "Command '$CMD' failed with RC=$RC"
        RC=1
      fi
      CMD="chmod 750 $PWDDIR"
      logger_debug "$CMD"
      $CMD 2>&1 | logger_debug
      RC=$?
      if [ "$RC" -ne 0 ]; then
        logger_error "Command '$CMD' failed with RC=$RC"
        RC=2
      fi
    fi
    if [ "$RC" -eq 0 -a "$SKIP" -ne 1 ]; then
      CMD="cp $NFSPWDDIR/.??* $PWDDIR"
      logger_debug "$CMD"
      $CMD 2>&1 | logger_debug
      RC=$?
      if [ "$RC" -ne 0 ]; then
        logger_error "Command '$CMD' failed with RC=$RC"
        RC=3
      fi
    fi
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreateDBService
#   - Create database service in CDB or PDB
# Input parameter:
#   - $1: StepID for using restartfile (optional, default: 0)
#   - $2: CDB or PDB Name (optional, default: CDB$ROOT)
#   - $3: Servicename
# Required variables:
#   - $DBNAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CreateDBService() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local CONNAME="${2:-CDB\$ROOT}"
  local SERVICENAME="$2"
  local PDBNAME=""

  if [ -n "$CONNAME" -a  "$CONNAME" != "NONE" -a "$CONNAME" != "CDB\$ROOT" ]; then
    PDBNAME="$CONNAME"
  fi
  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  logger_debug "CONNAME=$CONNAME"
  logger_debug "PDBNAME=$PDBNAME"
  logger_debug "SERVICENAME=$SERVICENAME"
  local RC=0
  [ -z "$PDBNAME" ] || PDBExists $PDBNAME
  if [ $? -ne 0 ]; then
    logger_error "PDB $PDBNAME does not exist or has errors"
    RC=10
  else
    # Create Services in Database
    DBServiceExists $SERVICENAME
    if [ $? -eq 0 ]; then
      logger_warn "Service $SERVICENAME already exists in Database $DBNAME"
    else
      CreateDBServiceSQL $CONNAME $SERVICENAME
      RC=$?
      DBServiceExists $SERVICENAME
      if [ $? -ne 0 ]; then
        logger_error "Unable to create service $SERVICENAME in Database $DBNAME"
        RC=10
      fi
    fi
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreateDBServiceSQL
#   - Create database service sql commands
# Input parameter:
#   - $1: CDB or PDB Name (optional, default: CDB$ROOT)
#   - $2: Servicename
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# Parameter:
#   1: PDB Name
#   2: Servicename
# =================================================================================================

CreateDBServiceSQL() {
  logger_debug "--> Function $FUNCNAME"
  local CONNAME="${1:-CDB\$ROOT}"
  local SERVICENAME="$2"
  local RC=0
  local SQLOUT=""

  logger_debug "CONNAME=$CONNAME"
  logger_debug "SERVICENAME=$SERVICENAME"

  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL # 2>/dev/null
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    DEFINE servicename=$SERVICENAME
    CONNECT / AS SYSDBA
    SET heading off feedback off pages 0
    ALTER SESSION SET CONTAINER=${CONNAME};
    execute dbms_service.create_service('&servicename.','&servicename.');
    execute dbms_service.start_service('&servicename.');
    WHENEVER SQLERROR CONTINUE
    ALTER PLUGGABLE DATABASE SAVE STATE;
EOSQL
)"
  RC=$?
  logger_debug "RC=$RC"
  if [ $RC -ne 0 ]
  then
    logger_debug "$SQLOUT"
    logger_error "Unable to create Service $SERVICENAME in container $CONNAME"
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreateOratab
#   - Create oratab entry
#   - Same like AddOratab() ?
# Input parameter:
#   - none
# Required variables:
#   - $ORATAB, $ORACLE_HOME, $DBNAME
# =================================================================================================

CreateOratab() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  if [ `grep "$DBNAME" "$ORATAB"|wc -l` -eq 0 ]; then
    echo "${DBNAME}:${ORACLE_HOME}:Y" >> $ORATAB
  else
    logger_warn "Entry for $DBNAME already exists in $ORATAB, please check for consistency or remove"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# AddOratab
#   - Add /etc/oratab entry
#   - Same like CreateOratab() ?
# Input parameter:
#   - none
# Required variables:
#   - $ORACLE_HOME, $DBNAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

AddOratab() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  if ! [ -w /etc/oratab ]; then
    logger_error "Can not write /etc/oratab"
    RC=1
  else
    if [ `grep $DBNAME /etc/oratab |wc -l` -eq 0 ]; then
      echo "$DBNAME:$ORACLE_HOME:Y" >> /etc/oratab
      RC=$?
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreatePWFile
#   - Create database password file
# Input parameter:
#   - none
# Required variables:
#   - $ORACLE_HOME, $DBNAME, $PWDDIR
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CreatePWFile() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  source $PWDDIR/.pwdfile_db_sys
  logger_debug "orapwd file=$ORACLE_HOME/dbs/orapw${DBNAME} password=$PWDSYS force=y"
  orapwd file=$ORACLE_HOME/dbs/orapw${DBNAME} password=$PWDSYS force=y
  RC=$?
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreatePFile
#   - Create PFile from SPFile
# Input parameter:
#   - $1: Pfile name (Default: init${DBNAME}.ora)
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CreatePFile() {
  logger_debug "--> Function $FUNCNAME"
  local FILENAME=${1:-init${ORACLE_SID}.ora}
  local RC=0
  local SQLOUT=""
  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL # 2>/dev/null
  WHENEVER OSERROR EXIT 255
  WHENEVER SQLERROR EXIT SQL.SQLCODE
  CONNECT / AS SYSDBA
  CREATE pfile='${ORACLE_HOME}/dbs/${FILENAME}' FROM spfile;
EOSQL
)"
  RC=$?
  logger_debug "RC=$RC"
  logger_debug "$SQLOUT"
  if [ $RC -ne 0 ]; then
    logger_error "Unable to create Pfile"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreateUpgradeConfig
#   - Create config file for datbase upgrade
# Input parameter:
#   - none
# Required variables:
#   - several variables (see function code)
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CreateUpgradeConfig() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0

  mkdir -p $UPGRADELOG
  if [ ! -d ${UPGRADELOG} ]; then
    logger_error "Unable to create log directory $UPGRADELOG"
    logger_debug "<-- Function $FUNCNAME (RC=$RC)"
    return 10
  else
    logger_info "Log Directory=$UPGRADELOG"
  fi
  #
  #  Create config file
  #
  cat <<EOCAT > $CONFIGFILE
global.autoupg_log_dir=$AUTOUPGRADEDIR
upg1.dbname=$DBNAME
upg1.start_time=NOW
upg1.source_home=$OLDHOME
upg1.target_home=$NEWHOME
upg1.sid=$ORACLE_SID
upg1.log_dir=$UPGRADELOG
upg1.upgrade_node=$HOSTNAME
upg1.target_version=$NEWBASEVERSION
upg1.run_utlrp=yes
EOCAT

  SetOracleSID $ORACLE_SID
  CheckArchiving
  local RET=$?
  logger_debug "Archiving Return Code=$RET"
  if [ $RET -eq 0 ]; then
    echo "global.restoration=no" >> $CONFIGFILE
    logger_debug "Do not set Guaranteed Restore Point"
  fi
  Delete2PCPending

  logger_info "Config File ${UPGRADELOG}/config${ORACLE_SID}.cfg created"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# AddMemlock
#   - Add os memlock limit
# Input parameter:
#   - none
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

AddMemlock() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local FILE="/etc/security/limits.conf"
  grep memlock /etc/security/limits.conf | grep -v \#
  RC=$?
  logger_debug "RC=$RC"
  if [ "$RC" -eq 0 ]; then
    logger_debug "Memlock parameter already set in $FILE"
  else
    sudo su - -c "echo oracle - memlock unlimited >> $FILE" 2>/dev/null
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_error "Could not set memlock parameter in $FILE"
    else
      logger_debug "Memlock parameter set in $FILE"
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# OracleHome
#   - Validate defined Oracle home and export ORACLE_HOME and ORACLE_VERSION
#   - Get newest supported ORACLE_HOME version if no ORACLE_HOME is set or defined
# Input parameter:
#   - $1: Oracle home path (optional), default: $ORACLE_HOME
# Set variables:
#   - $ORACLE_HOME, $ORACLE_VERSION
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

OracleHome() {
  logger_debug "--> Function $FUNCNAME"
  local OHPATH=${1:-$ORACLE_HOME}
  local OHVERSION=""
  local RC=0
  logger_debug "OHPATH=$OHPATH"
  if [ -d "$OHPATH" ]; then
    # Validate defined Oracle home
    if [ `find ${OHPATH}/bin/oradism| wc -l` -eq 0 ]; then
      logger_fatal "$OHPATH is not a valid ORACLE_HOME"
      RC=3
    else
      ORACLE_HOME="$OHPATH"
      ORACLE_VERSION=`$OHPATH/OPatch/opatch lspatches 2>/dev/null |awk '/;Database / { print $5 }' |tr -d "."`
    fi
  else
    # Get newest supported Oracle home
    local MAXVERSION=0
    local MAXORACLEHOME=""
    local OH=""
    unset ORACLE_HOME
    unset ORACLE_VERSION
    logger_debug "unset ORACLE_HOME"
    logger_debug "unset ORACLE_VERSION"
    for OH in `find /app/oracle/product -name oradism |rev|cut -d"/" -f 3-|rev`
    do
      if [ -e "$OH/OPatch/opatch" ]; then
        # OHVERSION=`$OH/OPatch/opatch lspatches 2>/dev/null |awk '/;Database / { print $5 }' |tr "." "\0" 2>/dev/null`
        OHVERSION=`$OH/OPatch/opatch lspatches 2>/dev/null |awk '/;Database / { print $5 }' |tr -d "."`
        logger_debug "OHVERSION=$OHVERSION"
        if [ -n "$OHVERSION" ]; then
          if [ "$OHVERSION" -gt "$MAXVERSION" ]; then
            MAXVERSION=$OHVERSION
            MAXORACLEHOME=$OH
          fi
        fi
      fi
    done
    ORACLE_HOME=$MAXORACLEHOME
    ORACLE_VERSION=$MAXVERSION
  fi

  # Set Oracle environment
  if [ "$RC" -eq 0 ]; then
    SetPath $ORACLE_HOME
    logger_debug "ORACLE_VERSION=$ORACLE_VERSION"
    logger_debug "ORACLE_HOME=$ORACLE_HOME"
    if [ -z "$ORACLE_HOME" ]; then
      logger_error "No valid Oracle-Home found"
      RC=1
    else
      export ORACLE_HOME ORACLE_VERSION
      logger_debug "exported ORACLE_HOME=$ORACLE_HOME"
      logger_debug "exported ORACLE_VERSION=$ORACLE_VERSION"
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# DirExists
#   - Check if directory exists and some directory properties
# Input parameter:
#   - $1: Directory
# Return Values
#   -  0: Directory exists
#   -  1: Directory exists and is readable (has xr permissons)
#   -  2: Directory exists and writeable (has xw permissions)
#   -  3: Directory exists and is writeable but a mount-point
#   -  4: Directory exists and is writeable but not empty
#   -  5: Directory exists but is not writable
#   - 10: Directory does not exist
# =================================================================================================

DirExists() {
  logger_debug "--> Function $FUNCNAME"
  local DIR="$1"
  logger_debug "DIR=$DIR"
  local RC=10
  if [ -d "$DIR" ]; then
    RC=0  # Directory exists
    if [ -x "$DIR" -a -r "$DIR" ]; then
      RC=1  # Directory is readable
    fi
    if [ -x "$DIR" -a -w "$DIR" ]; then
      RC=2  # Directory is writable
      if [ `findmnt $DIR >/dev/null 2>&1;echo $?` -eq 0 ]; then
        RC=3  # Directory is a mount point
        logger_debug "Directory $DIR is a mountpoint"
      fi
      if [ `ls $DIR |grep -v lost | wc -l` -gt 0 ]; then
        RC=4  # Directory is not empty
        logger_debug "Directory $DIR is not empty"
      fi
    else
      RC=5  # Directory is not writable
    fi
  else
    RC=10 # Directory does not exist
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# TnsAdmin
#   - Check and set TNS_ADMIN variable
# Input parameter:
#   - $1: ORACLE_SID
# Required variables:
#   - $ORACLE_HOME
# Set variables:
#   - $TNS_ADMIN
# Return Values
#   -  0: TNS_ADMIN directory exists
#   - >0: TNS_ADMIN is not a valid directory
# =================================================================================================

TnsAdmin() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  logger_debug "TNS_ADMIN=$TNS_ADMIN"
  if [ "$TNS_ADMIN" == "NONE" -o -z "$TNS_ADMIN" ]
  then
    ORABASEHOME=`$ORACLE_HOME/bin/orabasehome`
    TNS_ADMIN="${ORABASEHOME}/network/admin"
  fi
  if [ ! -d "$TNS_ADMIN" ]
  then
    logger_error "Directory $TNS_ADMIN is not a valid directory"
    RC=10
  fi
  export TNS_ADMIN
  logger_info "exported TNS_ADMIN=$TNS_ADMIN"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# SetPath
#   - Set correct PATH variable
# Input parameter:
#   - $1: ORACLE_SID
# Required variables:
#   - $PATH
# Set variables:
#   - $PATH
# Return Values
#   -  0: Path Set
#   - >0: Unable to set Path
# =================================================================================================

SetPath() {
  logger_debug "--> Function $FUNCNAME"
  local ORACLE_HOME="$1"
  local RC=0
  local FIRSTPATH=""
  FIRSTPATH=`echo $PATH|cut -d":" -f1`
  logger_debug "FIRSTPATH=$FIRSTPATH"
  if [ `echo $FIRSTPATH| grep -c \/app\/oracle\/product` -eq 0 ]
  then
    PATH=${ORACLE_HOME}/bin:$PATH
  else
    PATH=`echo $PATH| sed "s;$FIRSTPATH;${ORACLE_HOME}/bin;"`
  fi
  export PATH
  logger_debug "exported PATH=$PATH"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# OracleEnvironment
#   - Set Oracle database environment based on oratab
# Input parameter:
#   - $1: ORACLE_SID
# Required variables:
#   - $ORATAB
# Return Values
#   -  0: Environment set
#   - >0: Unable to set environment
# =================================================================================================

OracleEnvironment() {
  logger_debug "--> Function $FUNCNAME"
  local ORACLE_SID="$1"
  logger_debug "ORACLE_SID=$ORACLE_SID"
  local RC=0
  local OH=""
  OH=`fgrep -i "${ORACLE_SID}:" $ORATAB | cut -d ":" -f 2`
  # OH="`find /app/oracle/product -name spfile${ORACLE_SID}.ora -print |cut -d"/" -f1-6`"
  logger_debug "OH=$OH"
  if [ -z "$OH" ]; then
    logger_error "No matching ORACLE_HOME for ORACLE_SID $ORACLE_SID"
    RC=10
  else
    # Check if more than 1 ORACLE_HOMES are fetched from oratab
    set $OH
    if [ ${#} -gt 1 ]
    then
      logger_error "More than one ORACLE_HOME are matching"
      logger_error "$OH"
      logger_error "Please specify valid ORACLE_SID"
      RC=10
    fi
  fi
  if [ "$RC" -eq 0 ]; then
    ORACLE_HOME=$OH
    logger_debug "ORACLE_HOME=$ORACLE_HOME"
    SetPath $ORACLE_HOME
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# InstanceUp
#   - Check if Oracle instance is running
# Input parameter:
#   - $1: ORACLE_SID
# Set variables:
#   - $ORACLE_HOME
# Return Values
#   -  0: open (instance is up and running)
#   -  1: open migrate
#   -  2: mounted
#   -  3: started (nomount)
#   -  4: not running
#   - >4: Something got wrong
# =================================================================================================

InstanceUp() {
  logger_debug "--> Function $FUNCNAME"
  local ORACLE_SID="$1"
  local RC=0
  logger_debug "ORACLE_SID=$ORACLE_SID"
  # Lookup smon process
  local INSTANCEUP=""
  local SQLOUT=""
  INSTANCEUP=`ps -ef|grep -i "ora_smon_${ORACLE_SID}\$"|grep -qv grep; echo $?`
  logger_debug "INSTANCEUP=$INSTANCEUP"
  if [ "$INSTANCEUP" -eq 1 ]; then
    logger_debug "Instance $ORACLE_SID is not running"
    RC=4
  else
    # Setup environment
    OracleEnvironment $ORACLE_SID
    if [ "$?" -ne 0 ]; then
      logger_error "Could not set Oracle environment"
      RC=100
    else
      # Lookup v$instance.status
      export ORACLE_HOME
      logger_debug "exported ORACLE_HOME=$ORACLE_HOME"
      export ORACLE_SID
      logger_debug "exported ORACLE_SID=$ORACLE_SID"
      SQLOUT="$($ORACLE_HOME/bin/sqlplus -s / as sysdba <<EOSQL # 2>/dev/null
        WHENEVER SQLERROR EXIT SQL.SQLCODE
        SET heading off feedback off pages 0
        SELECT decode(status,'STARTED','3','MOUNTED',2,'OPEN MIGRATE',1,'OPEN',0) FROM v\$instance;
EOSQL
)"
      RC=$?
      if [ "$RC" -ne 0 ]; then
        logger_error "Error in sql execution (RC=$RC)"
        logger_debug "$SQLOUT"
        RC=200
      else
        RC="$SQLOUT"
        logger_debug "Instance status:$RC (0=OPEN, 1=OPEN MIGRATE, 2=MOUNTED, 3=STARTED)"
      fi
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# NumberOfPDBS
#   - Get number of PDBs from database
# Input parameter:
#   - none
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Set variables:
#   - $NUMPDBS
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

NumberOfPDBS() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local SQLOUT=""
  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s / as sysdba <<EOSQL # 2>/dev/null
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    SET heading off feedback off pages 0
    SELECT count(*) FROM v\$pdbs;
EOSQL
)"
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_error "Error in sql execution (RC=$RC)"
    logger_debug "$SQLOUT"
  else
    NUMPDBS="$SQLOUT"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# PDBExists
#   - Check if pluggable database exists
# Input parameter:
#   - $1: PDB name
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Return Values
#   -  0: PDB exists
#   -  1: PDB does not exist
#   - >1: Something got wrong
# =================================================================================================

PDBExists() {
  logger_debug "--> Function $FUNCNAME"
  local PDBNAME="$1"
  logger_debug "PDBNAME=$PDBNAME"
  local RC=0
  local SQLOUT=""
  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s / as sysdba <<EOSQL # 2>/dev/null
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    SET heading off feedback off pages 0
    SET markup csv on delimiter ' ' quote off
    SELECT count(*) FROM v\$containers WHERE upper(name) = upper('$PDBNAME');
EOSQL
)"
  RC=$?
  logger_debug "RC=$RC"
  logger_debug "SQLOUT=$SQLOUT"
  if [ "$RC" -ne 0 ]; then
    logger_error "Error in sql execution (RC=$RC)"
    logger_debug "$SQLOUT"
    RC=255
  elif [ "$SQLOUT" -eq 0 ]; then
    RC=1
  elif [ "$SQLOUT" -eq 1 ]; then
    RC=0
  else
    logger_fatal "Invalid PDB Informationen for Database $ORACLE_SID"
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# PDBConnect
#   - Check if users are still connected to PDB
# Input parameter:
#   - $1: PDB name
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Return Values
#   -  0: No user are connected
#   -  1: User are connected
#   - >0: Somwthing got wrong
# =================================================================================================

PDBConnect() {
  logger_debug "--> Function $FUNCNAME"
  local PDBNAME="$1"
  local RC=0
  logger_debug "PDBNAME=$PDBNAME"
  local CONNECTS=""
  CONNECTS="$($ORACLE_HOME/bin/sqlplus -s / as sysdba <<EOSQL 2>/dev/null
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    SET heading off feedback off pages 0 trimspool on
    SET markup csv on delimiter ' ' quote off
    SELECT decode(count(1),0,0,1) FROM v\$session s, v\$containers c
      WHERE s.con_id = c.con_id
        AND s.username IS NOT NULL
        AND c.name = '$PDBNAME';
EOSQL
)"
  RC=$?
  logger_debug "RC=$RC"
  logger_debug "CONNECTS=$CONNECTS"
  if [ $RC -ne 0 ]
  then
    logger_fatal "Invalid session Informationen for Pluggable database $PDBNAME in Database $ORACLE_SID"
    RC=255
  else
    RC=$CONNECTS
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ListenerUp
#   - Check if Oracle listener is up
# Input parameter:
#   - none
# Required variables:
#   - $LISTENER
# Return Values
#   -  0: Listener is running
#   -  1: Listener is not running
#   - >1: Something got wrong
# =================================================================================================

ListenerUp() {
  logger_debug "--> Function $FUNCNAME"
  local RC=1
  local LISTENERUP=""
  # Check if LISTENER is defined and a listener is running
  if [ -z "$LISTENER" ]; then
    logger_error "No LISTENER defined"
    RC=10
  elif [ `ps -ef|grep -i "tnslsnr listener"|grep -qv grep; echo $?` -eq 0 ]; then
    # A listener is running
    LISTENERUP=`ps -ef|grep -i "tnslsnr $LISTENER"|grep -v grep |awk '{ print $9 }'`
    if [ "$LISTENERUP" == "$LISTENER" ]; then
      # Running listener is the same like specified
      RC=0
    else
      logger_error "Listener is running with wrong name (lower / uppercase)"
      RC=2
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# PortIsFree
#   - Check if port is in use or not
# Input parameter:
#   - none
# Required variables:
#   - $PORT
# Return Values
#   -  0: Port is not used
#   -  1: Port is used
#   - 10: Something got wrong
# =================================================================================================

PortIsFree() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local PORTINUSE=""
  PORTINUSE=`netstat -ltnp 2>/dev/null | grep ":${PORT} " |wc -l`
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_fatal "Error in function $FUNCNAME (RC=$RC)"
    RC=10
  elif [ "$PORTINUSE" -ne 0 ]; then
    RC=1
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# GetListenerPort
#   - Checks if listener is running with the correct port
# Input parameter:
#   - none
# Required variables:
#   - $ORACLE_SID, $PORT
# Set variables:
#   - $RUNNINGPORT
# Return Values
#   -  0: Listener is running on correct port
#   - >0: Listener is not running or on wrong port
# =================================================================================================

GetListenerPort() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local S=0
  local LISTENER=""

  for S in {1..3}
  do
    if [ "$RC" -ne 0 ]; then
      break   # Skip all steps if an error has occurred
    fi
    case $S in
      1) # Get listener
        LISTENER=`ps -ef|grep -i "tnslsnr listener_$ORACLE_SID"|grep -v grep|awk '{ print $9 }'`
        if [ -z "$LISTENER" ]; then
          logger_error "Listener is not running"
          RC=5
        fi
      ;;
      2)
        if [ `echo $LISTENER | grep -i listener | wc -l` -ne 1 ]
        then
          logger_error "Unable to identify listener"
          RC=10
        fi
      ;;
      3) # Get Port
        ListenerPort
        RC=$?
      ;;
      *) ;;
    esac
  done

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ListenerPort
#   - Checks if listener is running on specified port
# Input parameter:
#   - none
# Required variables:
#   - $ORACLE_HOME, $LISTENER, $PORT
# Set variables:
#   - $RUNNINGPORT
# Return Values
#   - 0: Listener is running on correct port
#   - 1: Listener is not running or on wrong port
# =================================================================================================

ListenerPort() {
  logger_debug "--> Function $FUNCNAME"
  local RC=1
  RUNNINGPORT=`$ORACLE_HOME/bin/lsnrctl status $LISTENER |grep Connecting |cut -d"=" -f 6|rev |cut -c 4-|rev`
  logger_debug "RUNNINGPORT=$RUNNINGPORT"
  logger_debug "PORT=$PORT"
  if [ $RUNNINGPORT -eq $PORT ]; then
    RC=0
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ListenerInListenerora
#   - Lookup listener entry in listener.ora
# Input parameter:
#   - none
# Required variables:
#   - $LISTENERNAME, $ORACLE_HOME
# Return Values
#   - 0: Listener Entry exists
#   - 1: Listener Entry does not exist
# =================================================================================================

ListenerFileExists() {
  logger_debug "--> Function $FUNCNAME"
  local RC=1
  if [ "$TNS_ADMIN" == "NONE" -o -z "$TNS_ADMIN" ]; then
#
# new with Read Only Oracle Home
#    TNS_ADMIN=$ORACLE_HOME/network/admin
    TNS_ADMIN="${ORABASEHOMENET}"
    export TNS_ADMIN
    logger_debug "exported TNS_ADMIN=$TNS_ADMIN"
  fi
  if [ -s $TNS_ADMIN/listener.ora ]; then
    if [ `fgrep -i $LISTENERNAME $TNS_ADMIN/listener.ora; echo $?` -eq 0 ]; then
      RC=0
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ListenerInTnsnamesora
#   - Lookup listener entry in tnsnames.ora
# Input parameter:
#   - none
# Required variables:
#   - $TNS_ADMIN, $LISTENERNAME
# Return Values
#   - 0: Listener Entry exists
#   - 1: Listener Entry does not exist
# =================================================================================================

ListenerInTnsnamesora() {
  logger_debug "--> Function $FUNCNAME"
  local RC=1
  if [ -s $TNS_ADMIN/tnsnames.ora -a -n "$LISTENERNAME" ]
  then
    if [ `fgrep -qi "$LISTENERNAME" $TNS_ADMIN/tnsnames.ora; echo $?` -eq 0 ]
    then
      RC=0
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CheckDBFilesystem
#   - Check filesystem size
# Input parameter:
#   - $1: Directory
#   - $2: Minimum available fs size (MB)
# Return Values
#   -   0: FS has sufficient size
#   -   1: FS is to small
#   -  10: Directory does not exist or is not writeable
#   -  11: FS not valid for data or fra
#   - 255: Any other error
# =================================================================================================

CheckDBFilesystem() {
  logger_debug "--> Function $FUNCNAME"
  local DIRECTORY="$1"
  local MIN_SIZE_MB="$2"
  logger_debug "DIRECTORY=$DIRECTORY"
  logger_debug "MINSIZE=$MINSIZE"
  local RC=0
  local S=0
  local FILESYSTEMINFO=""
  local FILESYSTEM=""
  local SIZE_MB=0

  for S in {1..4}
  do
    if [ "$RC" -ne 0 ]; then
      break   # Skip all steps if an error has occurred
    fi
    case $S in
      1) # Check directory
        if [ `DirExists $DIRECTORY; echo $?` -ge 5 ]; then
          logger_error "Directory $DIRECTORY does not exist or is not writable"
          RC=10
        fi
      ;;
      2) # Get fylesystem information
        FILESYSTEMINFO=`df -m $DIRECTORY 2>/dev/null |grep -v Filesystem`
        # logger_debug "FILESYSTEMINFO=$FILESYSTEMINFO"
        FILESYSTEM=`echo $FILESYSTEMINFO | awk '{ print $1 }'`
        logger_debug "FILESYSTEM=$FILESYSTEM"
        if [ -z "$FILESYSTEMINFO" -o -z "$FILESYSTEM" ]; then
          logger_error "Could not get required filesystem info"
          RC=255
        fi
      ;;
      3) # Check for valid filesystem (dbvg on oracle vm's | oradatavg and orafravg on sas blades)
        if ! [[ "$FILESYSTEM" =~ /dbvg- || "$FILESYSTEM" =~ /oradatavg- || "$FILESYSTEM" =~ /orafravg- ]]; then
          logger_error "Filesystem $FILESYSTEM is not valid for data or fra"
          RC=11
        fi
      ;;
      4) # Check size of the filesystem
        SIZE_MB=`echo $FILESYSTEMINFO |awk '{ print $4 }'`
        logger_debug "SIZE_MB=$SIZE_MB"
        if [ "$SIZE_MB" -lt $MIN_SIZE_MB ]; then
          logger_error "Filesystem $FILESYSTEM to small"
          logger_error "Required size (MB) ${MIN_SIZE_MB}"
          logger_error "Actual size (MB) ${SIZE_MB}"
          RC=1
        else
          RC=0
        fi
      ;;
      *) ;;
    esac
  done

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# GetDBTemplate
#   - Lookup matching Oracle database template from template directory
# Input parameter:
#   - $1: Oracle home software version
#   - $2: DBCA templates directory (optional)
# Set variables:
#   - $DBTEMPLATE
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

GetDBTemplate() {
  logger_debug "--> Function $FUNCNAME"
  local ORA_VER=$1
  local TPL_DIR=${2:-/app/oracle/bin/templates/dbca}
  local RC=0
  local SWVERSION=""
  local DBVERSION=""
  local TEMPLATE=""
  local TEMPLATEFILE=""

  SWVERSION=`echo $ORA_VER | cut -c 1-2`
  logger_debug "SWVERSION=$SWVERSION"=`echo $ORA_VER | cut -c 1-2`
  logger_debug "SWVERSION=$SWVERSION"
  for TEMPLATEFILE in `find $TPL_DIR -name "*.dbt"`
  do
    # DBVERSION=`fgrep "version=" $TEMPLATE |rev|awk -F\" '{ print $2 }' |rev`
    # DBVERSION=`fgrep "version=" $TEMPLATE |rev|cut -d. -f5 |cut -d\" -f1|rev`
    DBVERSION=$(VER=`fgrep "version=" $TEMPLATEFILE`; VER="${VER#*version=\"}"; echo $VER | cut -d. -f1)
    logger_debug "TEMPLATEFILE=$TEMPLATEFILE"
    logger_debug "DBVERSION=$DBVERSION"
    if [ "$SWVERSION" == "$DBVERSION" ]; then
      TEMPLATE=$TEMPLATEFILE
      break
    fi
  done
  if [ -n "$TEMPLATE" ]; then
    DBTEMPLATE=$TEMPLATE
  else
    logger_error "Unable to find a valid Oracle Database Template for Software Version $SWVERSION"
    DBTEMPLATE=NoTemplateFound
    RC=10
  fi
  logger_info "Using Database Template $DBTEMPLATE"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# IsValidFile
#   - Check if specified file is a valid file
#   - Lookup in directory SQLBASEDIR if no path is specified
#   - For current working directory specify ./filename
# Input parameter:
#   - $1: File
# Required variables:
#   - $SQLBASEDIR
# Set variables:
#   - $FILENAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

IsValidFile() {
  logger_debug "--> Function $FUNCNAME"
  local FNAME="$1"
  local RC=0
  local HASPATH=""

  # Check if parameter 1 is set
  if [ -z "$FNAME" ]; then
    logger_error "No File specified"
    RC=10
  fi
  if [ -z "$SQLBASEDIR" ]; then
    logger_error "No SQLBASEDIR specified"
    RC=20
  fi
  if [ "$RC" -eq 0 ]; then
    HASPATH=`echo "$FNAME"|grep -q '/'; echo $?`
    if [ "$HASPATH" -eq 1 ]; then
      # No file path specified
      FNAME="$SQLBASEDIR/$FNAME"
    fi
    # Check if file is readable
    if [ -r "$FNAME" ]; then
      FILENAME=$FNAME
    else
      logger_error "Filename $FNAME is not a valid file"
      FILENAME=NotValidFile
      RC=100
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RunQualifiedCDBSQL
#   - Run SQL Script on CDB using user and password
# Input parameter:
#   - $1: Username
#   - $2: Password
#   - $3: SQL script
#   - $4-N: SQL script parameter
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Set variables:
#   - $SQLOUTPUT
# Return Values
#   -   0: Successful
#   -  10: Unsuccessful
#   - 255: Error in sql execution
# =================================================================================================

RunQualifiedCDBSQL() {
  logger_debug "--> Function $FUNCNAME"
  if  [ ${#} -lt 3 ]; then
    logger_error "Please specify Username, Password and SQLScript"
    logger_debug "<-- Function $FUNCNAME (RC=$RC)"
    return 10
  fi
  local USERNAME="$1"
  local USERPWD="$2"
  local SQLSCRIPT="$3"
  # shift params 1-4 away from $@
  shift 3
  # copy remaining params to SQLPARAMS enclosed in single quotes
  # e.g. "'par1' 'par2' 'par3'"
  local SQLPARAMS=$(for i in "$@"; do l="${l/%/ }'$i'"; done; echo $l);

  logger_debug "USERNAME=$USERNAME"
  # logger_debug "USERPWD=$USERPWD"
  logger_debug "SQLSCRIPT=$SQLSCRIPT"
  logger_debug "SQLPARAMS=$SQLPARAMS"
  local RC=0
  local SQLLOG="$(mktemp -u -t sql_XXXXXXXXXX.log)"

  # Check sql file
  IsValidFile $SQLSCRIPT
  if [ $? -ne 0 ]; then
    logger_error "File $SQLSCRIPT is not a valid File"
    RC=10
  else
    SQLSCRIPT=$FILENAME
    logger_debug "ExecSQL: $SQLSCRIPT $SQLPARAMS"
    logger_debug "SqlLog:  $RUNLOG"
    SQLOUTPUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL | tee $SQLLOG # 2>/dev/null
      WHENEVER OSERROR EXIT 255
      WHENEVER SQLERROR EXIT SQL.SQLCODE
      CONNECT ${USERNAME}/"${USERPWD}"
      -- DEFINE pwd=$USERPWD
      SET heading off feedback off pages 0
      -- set verify off ensure not printing out password variables
      SET verify off
      @$SQLSCRIPT $SQLPARAMS
EOSQL
)"
    RC=$?
    logger_debug "$SQLOUTPUT"
    if [ $RC -ne 0 ]; then
      logger_fatal "Error running Skript $SQLSCRIPT (RC=$RC)"
      logger_fatal "$SQLOUTPUT"
      RC=255
    fi
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RunQualifiedSQL
#   - Run SQL Script on PDB using qualified connection string
# Input parameter:
#   - $1: PDB name
#   - $2: DB user name
#   - $3: DB user password
#   - $4: SQL script
#   - $5-N: SQL script parameter
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID, $DBDOMAIN, $PORT
# Set variables:
#   - $RUNNINGPORT, $SQLOUTPUT
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RunQualifiedSQL() {
  logger_debug "--> Function $FUNCNAME"
  if  [ ${#} -lt 4 ]; then
    logger_error "Please specify PDBNAME, Username, Password and SQLScript"
    logger_debug "<-- Function $FUNCNAME (RC=$RC)"
    return 10
  fi
  local PDBNAME="$1"
  local USERNAME="$2"
  local USERPWD="$3"
  local SQLSCRIPT="$4"
  # shift params 1-4 away from $@
  shift 4
  # copy remaining params to SQLPARAMS enclosed in single quotes
  # e.g. "'par1' 'par2' 'par3'"
  local SQLPARAMS=$(for i in "$@"; do l="${l/%/ }'$i'"; done; echo $l);

  logger_debug "PDBNAME=$PDBNAME"
  logger_debug "USERNAME=$USERNAME"
  # logger_debug "USERPWD=$USERPWD"
  logger_debug "SQLSCRIPT=$SQLSCRIPT"
  logger_debug "SQLPARAMS=$SQLPARAMS"
  local RC=0
  local TNS=""
  local SQLLOG="$(mktemp -u -t sql_XXXXXXXXXX.log)"

  IsValidFile $SQLSCRIPT
  if [ $? -ne 0 ]; then
    logger_error "File $SQLSCRIPT is not a valid File"
    logger_debug "<-- Function $FUNCNAME (RC=$RC)"
    return 10
  else
    SQLSCRIPT=$FILENAME
    logger_debug "SQLSCRIPT=$SQLSCRIPT"
  fi

  # Check if listener is running
  GetListenerPort
  RC=$?
  logger_debug "Listener running on port $RUNNINGPORT"

  if ! [ "$RUNNINGPORT" -gt 0 -a "$RC" -eq 0 ]
  then
    logger_error "No valid Port found for listener"
    RC=10
  else
    # Run SQL on database using a full qualified db connection string
    TNS=`hostname`:${PORT}/${PDBNAME}.${DBDOMAIN}
    # logger_debug "${USERNAME}/${USERPWD}@$TNS"
    logger_debug "CONNECT=$TNS"
    logger_debug "ExecSQL: $SQLSCRIPT $SQLPARAMS"
    logger_debug "SqlLog:  $SQLLOG"
    SQLOUTPUT="$($ORACLE_HOME/bin/sqlplus -s /nolog 2>&1 <<EOSQL | tee $SQLLOG # 2>/dev/null
      WHENEVER OSERROR EXIT 255
      WHENEVER SQLERROR EXIT SQL.SQLCODE
      CONNECT ${USERNAME}/"${USERPWD}"@$TNS
      -- DEFINE pwd=$USERPWD
      SET heading off feedback off pages 0
      -- set verify off ensure not printing out password variables
      SET verify off
      @$SQLSCRIPT $SQLPARAMS
EOSQL
)"
    RC=$?
    logger_debug "$SQLOUTPUT"
    if [ $RC -ne 0 ]; then
      logger_error "Error running Skript $SQLSCRIPT"
      logger_error "$SQLOUTPUT"
    else
      logger_debug "SQLOUTPUT=$SQLOUTPUT"
    fi
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RunSingleSQL
#   - Run SQL script on CDB (CDB$ROOT) or PDB
# Input parameter:
#   - $1: CON_NAME
#   - $2: SQL script
#   - $3-N: SQL script parameter
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Set variables:
#   - $SQLOUTPUT
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RunSingleSQL() {
  logger_debug "--> Function $FUNCNAME"
  local PDBNAME="$1"
  local SQLSCRIPT="$2"
  # shift params 1&2 away from $@
  shift 2
  # copy remaining params to SQLPARAMS enclosed in single quotes
  # e.g. "'par1' 'par2' 'par3'"
  local SQLPARAMS="$(for i in "$@"; do l="${l/%/ }'$i'"; done; echo $l)";
  local RC=0
  local SQLLOG="$(mktemp -u -t sql_XXXXXXXXXX.log)"

  logger_debug "PDBNAME=$PDBNAME"
  logger_debug "SQLSCRIPT=$SQLSCRIPT"
  # cat $SQLSCRIPT | logger_debug
  IsValidFile "$SQLSCRIPT"
  if [ $? -ne 0 ]; then
    logger_error "File $SQLSCRIPT is not a valid File"
  else
    SQLSCRIPT="$FILENAME"
    logger_debug "ExecSQL: @$SQLSCRIPT $SQLPARAMS"
    logger_debug "SqlLog:  $SQLLOG"
    SQLOUTPUT="$($ORACLE_HOME/bin/sqlplus -s /nolog 2>&1 <<EOSQL | tee $SQLLOG
      WHENEVER OSERROR EXIT 255
      WHENEVER SQLERROR EXIT SQL.SQLCODE
      CONNECT / AS SYSDBA
      --SET heading off feedback off pages 0
      SET heading off pages 0
      -- set verify off ensure not printing out password variables
      SET verify off
      ALTER SESSION SET CONTAINER=$PDBNAME;
      show user con_name
      @$SQLSCRIPT $SQLPARAMS
EOSQL
)"
    RC=$?
    if [ $RC -ne 0 ]; then
      logger_error "Error running Skript $SQLSCRIPT (RC=$RC)"
      logger_error "$SQLOUTPUT"
    else
      logger_debug "SQLOUTPUT=$SQLOUTPUT"
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RunAllSQL
#   - Run all SQL scripts from specified directory on CDB (CDB$ROOT) or PDB
#   - If a script named "run.sql" exists it will be executed.
#   - Otherwise all scripts ending ".sql" will be executed.
# Input parameter:
#   - $1: CON_NAME
#   - $2: SQL script directory
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RunAllSQL() {
  logger_debug "--> Function $FUNCNAME"
  local PDBNAME="$1"
  local SQLSCRIPTDIR="$2"
  local RC=0
  local SQLSCRIPT=""

  logger_debug "$SQLSCRIPTDIR $PDBNAME"
  if [ -r "${SQLSCRIPTDIR}/run.sql" ]; then
    cd $SQLSCRIPTDIR
    RunSingleSQL" $PDBNAME" "run.sql"
    RC=$?
  else
    for SQLSCRIPT in `ls $1/*.sql`
    do
      RunSingleSQL "$PDBNAME" "$SQLSCRIPT"
      RC=$?
      if [ "$RC" -ne 0 ]; then
        break
      fi
    done
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RunStageSQL
#   - Execute $SQLSCRIPTDIR/run.sql for db stage on CDB (CDB$ROOT) or PDB
# Input parameter:
#   - $1: CON_NAME
#   - $2: SQL script directory
#   - $3-N: SQL script parameter
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RunStageSQL() {
  logger_debug "--> Function $FUNCNAME"
  local PDBNAME="$1"
  local SQLSCRIPTDIR="$2"
  # shift params 1&2 away from $@
  shift 2
  # copy remaining params to SQLPARAMS enclosed in single quotes
  # e.g. "'par1' 'par2' 'par3'"
  local SQLPARAMS=$(for i in "$@"; do l="${l/%/ }'$i'"; done; echo $l);
  local RC=0
  local SCRIPTNAME="run.sql"
  local SQLSCRIPT="$SQLSCRIPTDIR/$SCRIPTNAME"
  local RUNSCRIPT="$(mktemp -u -t run_XXXXXXXXXX.sql)"
  local RUNLOG="$(mktemp -u -t run_XXXXXXXXXX.log)"
  local DBSTAGE=""
  local RUNSTAGE=""
  local BEGIN=""
  local ENDE=""
  local SQLOUT=""

  echo "-- Generated Script" > /tmp/run.sql
  if [ ! -r "${SQLSCRIPT}" ]; then
    logger_fatal "Script $SQLSCRIPT missing or not readable!"
  else
    cd $SQLSCRIPTDIR
    logger_debug "$SQLSCRIPT $PDBNAME"
    #
    # Scripts for all Stages
    #
    DBSTAGE=`echo $ORACLE_SID |rev|cut -c 1`
    logger_debug "DBSTAGE=$DBSTAGE"
    # Stage A means ALL stages
    for RUNSTAGE in A $DBSTAGE
    do
      logger_debug "RUNSTAGE=$RUNSTAGE"
      BEGIN=`awk "/BEGINDBSTAGE $RUNSTAGE/ { print FNR }" run.sql`
      if [ -z "$BEGIN" ]; then
        continue
      fi
      ENDE=`awk "/ENDDBSTAGE $RUNSTAGE/ { print FNR }" run.sql`
      logger_debug "BEGIN=$BEGIN"
      logger_debug "ENDE=$ENDE"
      logger_debug "cat $SQLSCRIPT |sed -n "${BEGIN},${ENDE}p" >> $RUNSCRIPT"
      cat $SQLSCRIPT |sed -n "${BEGIN},${ENDE}p" | tee -a $RUNSCRIPT | logger_debug
    done
    logger_debug "ExecSQL: @$RUNSCRIPT $SQLPARAMS"
    logger_debug "SqlLog:  $RUNLOG"
    cat $RUNSCRIPT | logger_debug
    SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog 2>&1 <<EOSQL | tee $RUNLOG
    WHENEVER OSERROR EXIT 255
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    CONNECT / AS SYSDBA
    SET heading off feedback off pages 0
    -- set verify off ensure not printing out password variables
    SET verify off
    ALTER SESSION SET CONTAINER=$PDBNAME;
    show con_name
    @$RUNSCRIPT $SQLPARAMS
EOSQL
)"
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_error "Error running Skript ${SQLSCRIPT}"
      logger_error "$SQLOUT"
    else
      logger_debug "SQLOUT=$SQLOUT"
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# DBServiceExists
#   - Check if database service exists
#   - DB service names have to be unique for whole database (CDB and all PDBs)
# Input parameter:
#   - $1: Servicename
# Required variables:
#   - $ORACLE_HOME
# Return Values
#   -  0: Service exist
#   -  1: Service does not exists
#   - 10: Error identifying Service
# =================================================================================================

DBServiceExists() {
  logger_debug "--> Function $FUNCNAME"
  local SERVICENAME="$1"
  logger_debug "SERVICENAME=$SERVICENAME"
  local RC=0
  local SQLOUT=""

  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL # 2>/dev/null
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    SET heading off feedback off pages 0 verify off
    DEFINE servicename=$SERVICENAME
    CONNECT / AS SYSDBA
    SELECT count(*) FROM v\$services WHERE upper(name) = upper('&servicename.');
EOSQL
)"
  RC=$?
  logger_debug "SQLOUT==$SQLOUT"
  logger_debug "RC=$RC"
  if [ "$RC" -ne 0 -o "$SQLOUT" -gt 1 ]; then
    logger_debug "$SQLOUT"
    logger_error "Unable to query Services view"
    RC=10
  elif [ "$SQLOUT" -eq 0 ]; then
    RC=1
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# SetOracleSID
#   - Set ORACLE_SID using oraenv
# Input parameter:
#   - $1: ORACLE_SID
# Required variables:
#   - $ORACLE_HOME
# Set variables:
#   - $ORAENV_ASK
# =================================================================================================

SetOracleSID() {
  logger_debug "--> Function $FUNCNAME"
  ORACLE_SID="$1"   # have to be set as a non local variable!
  local RC=0
  logger_debug "ORACLE_SID=$ORACLE_SID"
  if [ `grep -c $ORACLE_SID /etc/oratab` -gt 0 ]; then
    ORAENV_ASK=NO
    . oraenv -s
    unset ORAENV_ASK
  else
    ORACLE_HOME=$ORACLE_HOME
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CheckArchiving
#   - Check if archiving is enabled
# Input parameter:
#   - none
# Required variables:
#   - $ORACLE_HOME
# Return Values
#   -  0: Archiving disabled
#   -  1: Archiving enabled
#   - >1: Something got wrong
# =================================================================================================

CheckArchiving() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local SQLOUT=""
  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL # 2>/dev/null
    CONNECT / AS SYSDBA
    set trimspool on heading off feedback off
    SELECT count(*) from v\$database WHERE log_mode = 'ARCHIVELOG';
EOSQL
)"
  RC=$?
  logger_debug "SQLOUT=$SQLOUT"
  if [ $RC -ne 0 ]; then
    logger_warn "Unable to determine Archivelog Mode (RC=$RC)"
    RC=10
  else
    RC="$SQLOUT"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ListenerStart
#   - Start Oracle listener
# Input parameter:
#   - none
# Required variables:
#   - $LISTENER, $ORACLE_HOME
# Set variables:
#   - $DBSIZEMB
# Return Values
#   -  0: Successful
#   - 10: Unsuccessful
# =================================================================================================

ListenerStart() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  ListenerUp
  if [ $? -ne 0 ]; then
    logger_debug "$ORACLE_HOME/bin/lsnrctl start $LISTENER"
    $ORACLE_HOME/bin/lsnrctl start $LISTENER >/dev/null 2>&1
    RC=$?; [ "$RC" -eq 0 ] || logger_debug "Could not start $LISTENER (RC=$RC)"
    ListenerUp
    if [ $? -ne 0 ]; then
      logger_error "Cannot Start listener $LISTENER"
      RC=10
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ListenerStop
#   - Stops running Oracle listener
#   - same function like ListenerDown() ?
# Input parameter:
#   - none
# Required variables:
#   - $LISTENER, $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - 10: Unsuccessful
# =================================================================================================

ListenerStop() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local PID=""
  ListenerUp
  if [ $? -eq 0 ]; then
    $ORACLE_HOME/bin/lsnrctl stop $LISTENER >/dev/null 2>&1
  fi
  ListenerUp
  if [ $? -eq 0 ]; then
    PID=`ps -ef|grep -i "tnslsnr $LISTENER" |grep -v grep |awk '{ print $2 }'`
    logger_debug "kill $PID"
    kill $PID
  fi
  ListenerUp
  if [ $? -eq 0 ]; then
    logger_error "Cannot Stop Listener $LISTENER"
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# AlterPasswordCDB
#   - Alter sys and system password for CDB using .pwdfile_db_sys[tem]
# Input parameter:
#   - $1: DBNAME
# Required variables:
#   - $PWDDIR, $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - 10: Unsuccessful
# =================================================================================================

AlterPasswordCDB() {
  logger_debug "--> Function $FUNCNAME"
  local DBNAME="$1"
  local RC=0
  local RC1=0
  local SQLOUT=""
  logger_debug "$DBNAME"
  InstanceUp $DBNAME
  if [ $? -ne 0 ]
  then
    logger_error "Instance $DBNAME is not open"
    RC=10
  fi

  source $PWDDIR/.pwdfile_db_sys
  [ $? -eq 0 ] || RC=10
  source $PWDDIR/.pwdfile_db_system
  [ $? -eq 0 ] || RC=10

  if [ "$RC" -eq 0 ]; then
    SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL # >/dev/null 2>&1
      CONNECT / AS SYSDBA
      ALTER USER sys IDENTIFIED BY \"$PWDSYS\" ;
EOSQL
)"
    RC1=`echo "$SQLOUT" |grep -i altered | wc -l`
    if [ "$RC1" -ne 1 ]
    then
      logger_error "Unable to change password for User sys"
      logger_error "$SQLOUT"
      RC=10
    fi

    SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL # >/dev/null 2>&1
      CONNECT / AS SYSDBA
      ALTER USER system IDENTIFIED BY \"$PWDSYSTEM\" ;
EOSQL
)"
    RC1=`echo "$SQLOUT" |grep -i altered | wc -l`
    if [ "$RC1" -ne 1 ]; then
      logger_error "Unable to change password for User sys"
      logger_error "$SQLOUT"
      RC=10
    fi
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# AlterPassword
#   - Alter common database user password
# Input parameter:
#   - $1: CON_NAME
#   - $2: Username
#   - $3: Password
# Required variables:
#   - $ORACLE_HOME
# Return Values
#   -   0: Successful
#   -  10: Unsuccessful
#   - 255: Error Executing SQL
# =================================================================================================

AlterPassword() {
  logger_debug "--> Function $FUNCNAME"
  local CONNAME="$1"
  local USERNAME="$2"
  local PASSWORD="$3"
  local RC=0
  local CONTAINERCLAUSE="ALL"
  local SQLOUT=""

  logger_debug "USERNAME=$USERNAME"
  # logger_debug "PASSWORD=$PASSWORD"
  logger_debug "CONNAME=$CONNAME"

  if [ ${#} -ne 3 ]; then
    logger_fatal "Please specify Username, Password and PDB Name"
    RC=10
  else
    if [ "$CONNAME" != "CDB\$ROOT" ]; then
      CONTAINERCLAUSE="CURRENT"
    fi
    logger_debug "CONTAINERCLAUSE=$CONTAINERCLAUSE"

    SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL 2>/dev/null
      WHENEVER SQLERROR EXIT SQL.SQLCODE
      CONNECT / AS SYSDBA
      ALTER SESSION SET CONTAINER=$CONNAME;
      -- MPils: Why we are using CONTINUE here?
      --        Added SQL.SQLCODE at first line and before DECLARE
      WHENEVER SQLERROR CONTINUE
      ALTER USER $USERNAME ACCOUNT UNLOCK;
      GRANT CREATE SESSION TO $USERNAME;
      WHENEVER SQLERROR EXIT SQL.SQLCODE
      DECLARE
        i_username cdb_users.username%TYPE := upper('$USERNAME');
        i_profile  cdb_users.profile%TYPE;
        i_password VARCHAR2(100) := '"$PASSWORD"';
        i_conname  VARCHAR2(30) := '$CONNAME';
        i_containerclause VARCHAR2(10) := '$CONTAINERCLAUSE';
        sql_stmt  VARCHAR2(1000);
      BEGIN
        SELECT u.profile
          INTO i_profile
          FROM cdb_users u, v\$containers c
        WHERE u.username = i_username
          AND u.con_id = c.con_id
          AND c.name = i_conname
          AND rownum < 2;
        sql_stmt := 'ALTER USER '||i_username ||' PROFILE DEFAULT CONTAINER='||i_containerclause;
        dbms_output.put_line(sql_stmt);
        EXECUTE IMMEDIATE sql_stmt;
        sql_stmt := 'ALTER USER '||i_username ||' IDENTIFIED BY '||i_password||' CONTAINER='||i_containerclause;
        dbms_output.put_line(sql_stmt);
        EXECUTE IMMEDIATE sql_stmt;
        sql_stmt := 'ALTER USER '||i_username ||' PROFILE '||i_profile||' CONTAINER='||i_containerclause;
        dbms_output.put_line(sql_stmt);
        EXECUTE IMMEDIATE sql_stmt;
      END;
      /
EOSQL
)"
    RC=$?
    [ "$RC" -eq 0 ] || RC=255
    logger_debug "$SQLOUT"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# SwitchLogfile
#   - Switch database redolog file
# Input parameter:
#   - none
# Required variables:
#   - $DBNAME, $ORACLE_HOME, $PWDSYS, $CONNECTSTRING
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

SwitchLogfile () {
  logger_debug "--> Function $FUNCNAME"
  local CONNECTSTRING="$1"
  local RC=0
  logger_debug "CONNECTSTRING=$CONNECTSTRING"
  local SQLOUT=""
  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s sys/\"${PWDSYS}\"@${CONNECTSTRING} as sysdba <<EOSQL 2>/dev/null
ALTER SYSTEM SWITCH LOGFILE;
ALTER SYSTEM SWITCH LOGFILE;
EOSQL
)"
  # RC=$?
  logger_debug "$SQLOUT"
  if [ `echo "$SQLOUT" | grep -i error |wc -l` -gt 0 ]
  then
    logger_error "Unable to switch logfile on source database using connect string $CONNECTSTRING"
    echo "$SQLOUT" | logger_error
    RC=10
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# StopInstance
#   - Shutdown the Oracle database instance if still running
# Input parameter:
#   - none
# Required variables:
#   - $DBNAME, $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

StopInstance() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local SQLOUT=""
  # Check if instance is running
  InstanceUp $DBNAME
  if [ $? -ne 4 ]; then
    SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog  <<EOSQL 2>/dev/null
      CONNECT / AS SYSDBA
      SHUTDOWN IMMEDIATE
EOSQL
)"
    logger_debug "${SQLOUT}"
  fi

  # Check if instance is still running
  InstanceUp $DBNAME
  if [ $? -ne 4 ]; then
    logger_error "Unable to stop instance $DBNAME"
    RC=10
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# StartInstance
#   - Startup the Oracle database instance if not running
# Input parameter:
#   - none
# Required variables:
#   - $DBNAME, $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

StartInstance() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local SQLOUT=""
  # Check if instance is already running
  InstanceUp $DBNAME
  if [ $? -ne 4 ]; then
    logger_error "Instance $DBNAME already started"
  else
    SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog  <<EOSQL 2>/dev/null
      CONNECT / AS SYSDBA
      STARTUP
EOSQL
)"
    logger_debug "$SQLOUT"
  fi

  # Check if instance is running now
  InstanceUp $DBNAME
  if [ $? -ne 0 ]; then
    logger_error "Unable to start instance $DBNAME"
    RC=10
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# DeleteFiles
#   - Delete files with given name pattern
# Input parameter:
#   - $1: files lookup directory
#   - $2: files name pattern (used for $1/*$2* lookup)
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

DeleteFiles() {
  logger_debug "--> Function $FUNCNAME"
  local DIRECTORY="$1"
  local FILE="$2"
  local RC=0
  if [ ! -z "FILE" -a ! -z "DIRECTORY" ]
  then
    rm $DIRECTORY/*${FILE}* >/dev/null 2>&1
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_error "Could not remove files $$DIRECTORY/*${FILE}*"
    else
      logger_info "Files $DIRECTORY/*${FILE}* removed"
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# DeleteDirectory
#   - Delete a directory
# Input parameter:
#   - $1: directory (full path qualified)
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

DeleteDirectory() {
  logger_debug "--> Function $FUNCNAME"
  local DIRECTORY="$1"
  local RC=0
  if [ -z "$DIRECTORY" ]
  then
    return 10
  fi
  DirExists $DIRECTORY
  if [ $? -eq 4 ]
  then
    CMD="rm -rf $DIRECTORY/* > /dev/null 2>&1"
    logger_debug "$CMD"
    $CMD 2>&1 | tee >(logger_debug)
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_error "Could not remove directory $DIRECTORY"
    else
      logger_info "Directory $DIRECTORY removed"
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RemoveOratab
#   - Remove an entry from oratab
# Input parameter:
#   - $1: oratab file (full path qualified)
#   - $2: oratab entry
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RemoveOratab() {
  logger_debug "--> Function $FUNCNAME"
  local FILE="$1"
  local ENTRY="$2"
  logger_debug "FILE=$FILE"
  logger_debug "ENTRY=$ENTRY"
  local TEMPFILE="/tmp/$(basename $FILE)_$DATUM"
  local RC=0

  if [ -z "$FILE" -o -z "$ENTRY" ]
  then
    RC=10
  elif [ `fgrep -i -c $ENTRY $FILE 2>/dev/null` -gt 0 ]
  then
    # No return code handling here!
    BackupFile $FILE
    cp $FILE $TEMPFILE
    CMD="sed -i '/${ENTRY}/d' $TEMPFILE"
    logger_debug "$CMD"
    eval $CMD 2>&1 | tee >(logger_debug)
    cp $TEMPFILE $FILE
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# DeletePDB
#   - Remove PDB from database
#   - NOT READY YET - work in progress!
# Input parameter:
#   - $1: DBNAME
#   - $2: PDBNAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
#
#   Returncode Values
#   0 : Pluggable Database successfully deleted
#   1 : Pluggable Database does not exis
#   10 : Error deleting Pluggable Database
#
# =================================================================================================

DeletePDB() {
  logger_debug "--> Function $FUNCNAME"
  local DBNAME="$1"
  local PDBNAME="$2"
  local RC=0
  local DELETEPDB=""

  # Remove Directory Entry

  UnregisterPDB $DBNAME $PDBNAME
  #  RC=$?      # No return code handling yet!

  # Drop Pluggable Database

#   DROPPDB="$($ORACLE_HOME/bin/sqlplus -s / as sysdba <<EOSQL # 2>/dev/null
#     WHENEVER SQLERROR EXIT SQL.SQLCODE
#     SET heading off feedback off pages 0
#     ALTER PLUGGABLE DATABASE $PDBNAME CLOSE INSTANCES=ALL;
#     DROP PLUGGABLE DATABASE $PDBNAME INCLUDING DATAFILES;
# EOSQL
# )"

  DELETEPDB="$(dbca -silent -deletePluggableDatabase -sourceDB $DBNAME -pdbName $PDBNAME)"
  logger_debug "$DELETEPDB"
  $DELETEPDB

  RC=$?
  if [ $RC -ne 0 ]; then
    logger_error "Unable to drop Pluggable Database $PDBNAME (RC=$RC)"
    logger_error "$DELETEPDB"
    RC=255
  fi

  # check if PDB exists
  PDBExists $PDBNAME
  RC=$?
  if [ $RC -eq 0 ]; then
    logger_error "Unable to drop Pluggable Database $PDBNAME"
    RC=10
  else
    RC=0
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ListenerDown
#   - Checks if listener is running and stop it using stop or kill command
#   - Same function like ListenerStop() ?
# Input parameter:
#   - none
# Required variables:
#   - $ORACLE_HOME, $LISTENER
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

ListenerDown() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local CMD=""
  ListenerUp
  if [ $? -eq 0 ]; then
    CMD="$ORACLE_HOME/bin/lsnrctl stop $LISTENER"
    logger_debug "$CMD"
    eval $CMD 2>&1 | logger_debug
    RC=$?
    if [ "$RC" -ne 0 ]; then
      CMD="kill -9 $(ps -ef|grep -i "tnslsnr $LISTENER"|grep -v grep |awk '{ print $2 }')"
      logger_debug "$CMD"
      eval $CMD 2>&1 | tee >(logger_debug)
      RC=$?
      [ "$RC" -eq 0 ] || logger_debug "Could not kill $LISTENER (RC=$RC)"
    fi
    ListenerUp
    if [ "$RC" -eq 0 ]; then
      logger_error "Error: could not stop $LISTENER"
      RC=1
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RemoveTnsnamesEntry
#   - Remove a tnsnames entry using RestoreOldFile function
# Input parameter:
#   - none
# Required variables:
#   - $TNS_ADMIN, $LISTENER
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RemoveTnsnamesEntry() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  if [ -e $TNS_ADMIN/tnsnames.ora ]
  then
    logger_debug "grep -i -c $LISTENER $TNS_ADMIN/tnsnames.ora"
    if [ `grep -i -c $LISTENER $TNS_ADMIN/tnsnames.ora` -gt 0 ]
    then
      RestoreOldFile $TNS_ADMIN/tnsnames.ora $LISTENER
      RC=$?
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RemoveListenerEntry
#   - Remove a listener entry using RestoreOldFile function
# Input parameter:
#   - none
# Required variables:
#   - $TNS_ADMIN, $LISTENER
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RemoveListenerEntry() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  if [ -e $TNS_ADMIN/listener.ora ]
  then
    if [ `grep -i -c $LISTENER $TNS_ADMIN/listener.ora` -gt 0 ]
    then
      RestoreOldFile $TNS_ADMIN/listener.ora $LISTENER
      RC=$?
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# DeleteDBService
#   - Remove a database service from pdb
#   - Check if the service exists before and after deletion of the service
# Input parameter:
#   - $1: PDB Name
#   - $2: Servicename
# Required variables:
#   - $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

DeleteDBService() {
  logger_debug "--> Function $FUNCNAME"
  local PDBNAME="$1"
  local SERVICENAME="$2"
  local RC=0

  # Check PDB
  PDBExists $PDBNAME
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_error "PDB $PDBNAME does not exist or has errors (RC=$RC)"
    logger_debug "<-- Function DeleteDBService"
    RC=10
  else
    # Delete Services in Database
    DBServiceExists $SERVICENAME
    RC=$?
    if [ "$RC" -eq 1 ]; then
      logger_error "Service $SERVICENAME does not exits in Database $PDBNAME"
    else
      DeleteDBServiceSQL $PDBNAME $SERVICENAME
      RC=$?
      if [ "$RC" -ne 0 ]; then
        logger_error "Unable to delete service $SERVICENAME in Database $PDBNAME"
        RC=10
      fi
      # Final check
      DBServiceExists $SERVICENAME
      RC=$?
      if [ "$RC" -eq 0 ]; then
        logger_error "Unable to delete service $SERVICENAME in Database $PDBNAME"
        RC=10
      fi
    fi
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# DeleteDBServiceSQL
#   - Remove a database service from pdb using SQLs
# Input parameter:
#   - $1: PDB Name
#   - $2: Servicename
# Required variables:
#   - $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

DeleteDBServiceSQL() {
  logger_debug "--> Function $FUNCNAME"
  local PDBNAME="$1"
  local SERVICENAME="$2"
  local RC=0
  local SQLOUT=""
  logger_debug "PDBNAME=$PDBNAME"
  logger_debug "SERVICENAME=$SERVICENAME"

  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL # 2>/dev/null
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    DEFINE servicename=$SERVICENAME
    CONNECT / AS SYSDBA
    SET heading off feedback off pages 0
    ALTER SESSION SET CONTAINER=${PDBNAME};
    WHENEVER SQLERROR CONTINUE
    execute dbms_service.stop_service('&servicename.');
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    execute dbms_service.delete_service('&servicename.');
    WHENEVER SQLERROR CONTINUE
    ALTER PLUGGABLE DATABASE SAVE STATE;
EOSQL
)"
  RC=$?
  logger_debug "RC=$RC"
  if [ $RC -ne 0 ]; then
    logger_debug "$SQLOUT"
    logger_error "Unable to create Service $SERVICENAME in PDB $PDBNAME (RC=$RC)"
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# UnregisterPDB
#   - Unregister Pluggable Database with Directory Service
# Input parameter:
#   - $1: DBNAME
#   - $2: PDBNAME
# Required variables:
#   - $SCRIPTDIR
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

UnregisterPDB() {
  logger_debug "--> Function $FUNCNAME"
  local DBNAME="$1"
  local PDBNAME="$2"
  local RC=0
  local CMD=""
  CMD="$SCRIPTDIR/ORAeusreg -opt remove -sid $DBNAME -pdb $PDBNAME"
  logger_debug "$CMD"
  $CMD 2>&1 | tee >(logger_debug)
  RC=$?
  if [ "$RC" -ne 0 ]
  then
    logger_error "Unable to unregister PDB $PDBNAME"
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# UnregisterPDBalt
#   - Unregister Pluggable Database with Directory Service
# Input parameter:
#   - $1: Name of PDB
# Required variables:
#   - $DBNAME, $ORACLE_BASE, $ORACLE_HOME, $ORACLE_SID
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

UnregisterPDBalt() {
  logger_debug "--> Function $FUNCNAME"
  local PDBNAME="$1"
  local RC=$?
  local RESPONSEFILE="/tmp/${DBNAME}_${PDBNAME}_${DATUM}.rsp"
  local DBCACMD=""
  source $PWDDIR/.pwdfile_oud_directorymanager # Password PWDDIRECTORYMANAGER
  source $PWDDIR/.pwdfile_eus_dbwallet # Password PWDDBWALLET
  logger_debug "PWDDIRECTORYMANAGER=$PWDDIRECTORYMANAGER"
  logger_debug "PDBDBWALLET=$PWDDBWALLET"
  cat <<EOCAT > $RESPONSEFILE
unregisterWithDirService=TRUE
dirServiceUserName=cn=Directory Manager
dirServicePassword=$PWDDIRECTORYMANAGER
walletPassword=$PWDDBWALLET
EOCAT
  DBCACMD="${ORACLE_HOME}/bin/dbca -configurePluggableDatabase -sourceDB $DBNAME -pdbName $PDBNAME -responseFile $RESPONSEFILE -silent"
  logger_debug "$DBCACMD"
  $DBCACMD > /tmp/unregisterdb_${ORACLE_SID}.$DATUM 2>&1
  RC=$?
  logger_debug "RC=$RC"
  if [ $RET -ne 0 ]
  then
    logger_error "Unable to Unregister Pluggable Database $PDBNAME with Directory Service"
    logger_error "Please check $ORACLE_BASE/cfgtoollogs/dbca/$ORACLE_SID Files"
    logger_error "and /tmp/unregisterdb_${ORACLE_SID}.$DATUM"
    logger_error "and $RESPONSEFILE"
    RC=10
  else
    # rm $RESPONSEFILE
    RC=0
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
# DeleteListener
#   - Remove Oracle listener
#   - Undo changes made by CreateListener function
# Input parameter:
#   - none
# Required variables:
#   - $LISTENER
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
#-----------------------------------------------------------------------------------------------------------------
DeleteListener() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local RC1=0
  local DATUM=`date "+%y%m%d"`
  local CMD=""
  local TMPPROCESS=""

  # Kill current Listener process
  TMPPROCESS=`ps -ef|grep -i "tnslsnr $LISTENER" |grep -v grep |awk '{ print $2 }'`
  if [ -n "$TMPPROCESS" ]; then
    CMD="kill -9 $TMPPROCESS"
    logger_debug "$CMD"
    $CMD 2>&1 | tee >(logger_debug)
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_error "Could not kill listener $LISTNER (RC=$RC)"
    fi
  fi

  if [ "$RC" -eq 0 ]; then
    # rename current listener.ora, sqlnet.ora and ldap.ora
    local NETFILE=""
    for NETFILE in listener sqlnet ldap
    do

      # local NETADMINFILE="${NETADMINDIR}/$NETFILE"
      # local NETADMINFILE="$ORACLE_HOME/network/admin/$NETFILE"
      ORABASEHOME=`${ORACLE_HOME}/bin/orabasehome`
      ORABASEHOMENET=${ORABASEHOME}/network/admin
      local NETADMINFILE=${ORABASEHOMENET}/${NETFILE}
      if [ -r "${NETADMINFILE}.ora" ]; then
        CMD="mv ${NETADMINFILE}.ora ${NETADMINFILE}_$DATUM.bak"
        logger_debug "$CMD"
        $CMD 2>&1 | tee >(logger_debug)
        RC1=$?
        if [ "$RC1" -ne 0 ]; then
          logger_error "Could not rename ${NETADMINFILE}.ora (RC=$RC1)"
          RC=$RC1
        fi
      fi
    done
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
# CreateListener
#   - Creates an Oracle listener and configure ldap.ora and sqlnet.ora
#   - Taken over from ORAcreateDB
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Required variables:
#   - $ORACLE_HOME, $LISTNER, $PORT
#   - $NETCARESPONSEFILE, $NETCALOGFILE, $LDAPORAFILE, $SQLNETORAFILE
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
#-----------------------------------------------------------------------------------------------------------------
CreateListener() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local RC=0
  local CMD=""
  ORABASEHOME=`${ORACLE_HOME}/bin/orabasehome`
  ORABASEHOMENET="${ORABASEHOME}/network/admin"
  logger_debug "ORABASEHOMENET=$ORABASEHOMENET"
  logger_debug TNS_ADMIN=$TNS_ADMIN
  local TNS_ADMIN_TMP=$TNS_ADMIN
  local TNS_ADMIN=$ORABASEHOMENET
  logger_debug TNS_ADMIN_TMP=$TNS_ADMIN_TMP
  logger_debug LISTENER=$LISTENER

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  if [ `ps -ef|grep "$LISTENER" |grep -v grep|wc -l` -gt 0 ]
  then
    logger_warn "Listener $LISTENER already running, will be removed"
    DeleteListener
  fi

  CMD="${ORACLE_HOME}/bin/netca -silent -responsefile ${NETCARESPONSEFILE} -instype custom -listener ${LISTENER} -lisport ${PORT} -insprtcl TCP,IPC -orahome ${ORACLE_HOME} -log $NETCALOGFILE"
  logger_debug "$CMD"
  $CMD 2>&1 | logger_debug
  RC=$?
  if [ $RC -ne 0 ]; then
    logger_error "Creating Listener $LISTENER failed with RC=$RC"
    logger_error "Please find details in $NETCALOGFILE"
  else
    logger_info "Listener $LISTENER successfully created"
    $ORACLE_HOME/bin/lsnrctl status $LISTENER|logger_debug
  fi
  #
  # Read Only Oracle Home
  #

  if [ "$RC" -eq 0 ]; then
    local NETFILE=""
    local TEMPLATE=""
    for NETFILE in sqlnet.ora ldap.ora shrept.lst
    do
      if [ "$NETFILE" == "shrept.lst" ]; then
        TEMPLATE="$ORACLE_HOME/network/admin/shrept.lst"
      else
        local FNAME=${NETFILE^^}  # to upper case
        FNAME=${FNAME//./}       # remove .
        TEMPLATE=`eval echo '$'${FNAME}FILE`
      fi
      #
      # Changed with Read Only Oracle Home
      # if [ ! -f $ORACLE_HOME/network/admin/$NETFILE ]; then
      if [ ! -f ${ORABASEHOMENET}/${NETFILE} ]; then
        CMD="cp $TEMPLATE ${ORABASEHOMENET}/$NETFILE"
        logger_debug "$CMD"
        $CMD 2>&1 | logger_debug
        RC=$?
        if [ "$RC" -ne 0 ]; then
          logger_error "Error in $NETFILE file creation (RC=$RC)!"
        else
          logger_info "$NETFILE file created"
        fi
      else
        logger_warn "$NETFILE file already exists"
      fi
    done
  fi
  TNS_ADMIN=$TNS_ADMIN_TMP
  logger_debug "TNS_ADMIN=$TNS_ADMIN"
  if [ -r "${TNS_ADMIN}/tnsnames.ora" -a ! -r ${ORABASEHOMENET}/tnsnames.ora ]
  then
    mv ${TNS_ADMIN}/tnsnames.ora $ORABASEHOMENET
  fi
  ln -sf ${ORABASEHOMENET}/*.ora $TNS_ADMIN
  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
# CreateTNSalias
#   - Creates a TNS Alias
#   - Do we realy need this function? We can also run ORAtnsService directly.
# Input parameter:
#   - $1: StepID for using restartfile (optional)
#   - $2: Name of tns alias
#   - $3: Name of db service used for db connect description
#   - $4: ORACLE_SID (optionial if set in env)
#   - $5: Hostname (optional)
#   - $6: Listener port (optional)
#   - $7: Description (optional, use 'DEFAULT' for db default service)
# Required variables:
#   - $SCRIPTDIR
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
#-----------------------------------------------------------------------------------------------------------------

CreateTNSalias() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local TNSALIAS="$2"
  local DBSRV="$3"
  local ORASID=${4:-$ORACLE_SID}
  local HOST=${5:-$(hostname -f)}
  local PORT=${6:-1601}
  local DESC="$7"
  local RC=0
  local CMD=""
  local CMDOUT=""

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  TNSALIAS=${TNSALIAS^^}  # to upper case
  ORASID=${ORASID^^}      # to upper case
  logger_debug "TNSALIAS=$TNSALIAS"

  # Do we realy need a description?
  [ "${DESC,,}" == "default" ] && DESC="database default tns-alias" || true
  [ -z "$DESC" ] || DESC="-desc  '$DESC'"

  # Check tns not exists in OUD
  CMDOUT="$($SCRIPTDIR/ORAtnsService -opt list -type tns -tnssrv '${TNSALIAS}' -dump 2>&1)"
  RC=$?
  if [ $RC -ne 0 ]; then
    logger_error "ORAtnsService script failed (RC=$RC)"
  elif [ `echo "$CMDOUT"|grep -iq "dn:cn=${TNSALIAS},"; echo $?` -eq 0 ]; then
    logger_info "TNS-Alias '$TNSALIAS' already exists"
    logger_debug "$CMDOUT"
  else
    # Add tns entry into OUD
    CMD="$SCRIPTDIR/ORAtnsService -opt add -type tns
      -sid '${ORASID}' -host '${HOST}' -port '${PORT}'
      -tnssrv '${TNSALIAS}' -dbsrv '${DBSRV}'
      $DESC -f"
    CMDOUT="$($CMD 2>&1)"
    RC=$?
    if [ $RC -ne 0 ]; then
      logger_warn "TNS-Alias creation failed with RC=$RC"
      logger_debug "$CMDOUT"
    else
      logger_info "TNS-Alias successfully created"
    fi
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
# ConfigOratab
#   - Change /etc/oratab entry (set :N to :Y)
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Required variables:
#   - $DBNAMEs
#-----------------------------------------------------------------------------------------------------------------

ConfigOratab() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local RC=0

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  grep -v $DBNAME /etc/oratab > /tmp/oratab
  grep $DBNAME /etc/oratab|sed s/:N$/:Y/ >>/tmp/oratab
  cat /tmp/oratab > /etc/oratab
  grep $DBNAME /etc/oratab |logger_debug

[ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
# ValidStages
#   - Check if provided stage shortcut is valid
# Input parameter:
#   - $1: Stage shortcut to be validated
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
#-----------------------------------------------------------------------------------------------------------------

ValidStages() {
  logger_debug "--> Function $FUNCNAME"
  local STAGE="$1"
  STAGE=$(echo $STAGE|tr '[:lower:]' '[:upper:]')
  local VALIDSTAGES=PIFKE
  local RC=0
  if [ `echo $VALIDSTAGES |grep -c $STAGE` -ne 1 ]
  then
    logger_error "Stage $STAGE is not valid"
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
# DBRecompile
#   - Runs recompilation of all database objects using utlrp.sql
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Required variables:
#   - $ORACLE_HOME, $ORACLE_SID
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
#-----------------------------------------------------------------------------------------------------------------

DBRecompile() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}  # 0 means it runs allways
  local CONNAME="${2:-CDB\$ROOT}"
  local RC=0
  local PDBNAME=""
  local SQLOUT=""
  local INVALID_OBJECTS=0

  # Set PDBNAME for CheckRestartFile
  if [ -n "$CONNAME" -a "$CONNAME" != "NONE" -a "$CONNAME" != "CDB\$ROOT" ]; then
    PDBNAME="$CONNAME"
  fi

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  if [ -n "$PDBNAME" ]; then
    # Check if PDB exists in database
    PDBExists $PDBNAME
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_fatal "PDB $PDBNAME does not exist"
      RC=100
    fi
  fi

  if [ "$RC" -eq 0 ]; then
    SQLOUT="$(${ORACLE_HOME}/bin/sqlplus -s / as sysdba <<EOF 2>&1
    WHENEVER OSERROR EXIT 255
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    set lines 500 pages 1000
    prompt ALTER SESSION SET CONTAINER=$CONNAME;
    ALTER SESSION SET CONTAINER=$CONNAME;
    PROMPT ### Utlrp.sql Recompile Run   ###
    col TIMESTAMP for a70
    @?/rdbms/admin/utlrp.sql
    select 'OBJECTS_WITH_ERRORS:'||count(1) as INVALID_OBJECTS_COUNT
      from dba_objects where status != 'VALID';
    prompt
EOF
)"
    RC=$?
    logger_debug "SQLOUT=$SQLOUT"
    if [ "$RC" -ne 0 ]; then
      logger_error "Database recompilation failed (RC=$RC)!"
    fi
    INVALID_OBJECTS=`echo "$SQLOUT" | grep 'OBJECTS_WITH_ERRORS:' | cut -d: -f2 | sed 's/ //g'`
    logger_debug "INVALID_OBJECTS=$INVALID_OBJECTS"
    if [ "$INVALID_OBJECTS" != "0" ]; then
      logger_warn "Database container '$CONNAME' has $INVALID_OBJECTS invalid objects!"
    else
      logger_info "All database objects are valid."
    fi
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
# DatabaseChecks
#   - Runs several sql based cehcks on database
# Input parameter:
#   - $1: StepID for using restartfile (optional)
#   - $2: Name ot PDB/CDB (default=CDB$ROOT)
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
#-----------------------------------------------------------------------------------------------------------------

DatabaseChecks() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}  # 0 means it runs allways
  local CONNAME="${2:-CDB\$ROOT}"
  local RC=0
  local PDBNAME=""
  local WHERECOND="and con_id < 3"

  # Set PDBNAME for CheckRestartFile
  if [ -n "$CONNAME" -a "$CONNAME" != "NONE" -a "$CONNAME" != "CDB\$ROOT" ]; then
    PDBNAME="$CONNAME"
  fi

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  if [ -n "$PDBNAME" ]; then
    WHERECOND=""

    # Check if PDB exists in database
    PDBExists $PDBNAME
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_fatal "PDB $PDBNAME does not exist"
      RC=100
    fi
  fi
  # logger_debug "WHERECOND=$WHERECOND"

  if [ "$RC" -eq 0 ]; then
    #
    # No script error handling implemented yet!
    #
    ${ORACLE_HOME}/bin/sqlplus -s / as sysdba <<EOF | logger_debug
    -- WHENEVER SQLERROR EXIT SQL.SQLCODE
      set lines 500 pages 1000
      prompt ALTER SESSION SET CONTAINER=$CONNAME;
      ALTER SESSION SET CONTAINER=$CONNAME;
      col con_id for 999999
      col con_name for a10

      PROMPT ### PDB_PLUG_IN_VIOLATIONS ###
      col time for a30
      col name for a10
      col cause for a20
      col message for a120
      col action for a120
      select time,con_id,name,cause,type,error_number,line,status,message,action
        from PDB_PLUG_IN_VIOLATIONS;
      -- where status = 'PENDING';

      PROMPT ### DBA_PDB_SAVED_STATES Content ###
      col instance for a8
      col con_name for a8
      col restricted for a10
      select instance_name as instance,con_id,con_name,state,restricted
      from dba_pdb_saved_states;

      PROMPT ### DBA_Registry Content ###
      col COMP_ID for a10
      col COMP_NAME for a40
      col SCHEMA for a20
      col VERSION for a15
      col status format a15
      SELECT COMP_ID,COMP_NAME,VERSION,STATUS,SCHEMA
      FROM dba_registry;

      PROMPT ### NLS_Database_Parameters ###
      col parameter format a30
      col value format a30
      SELECT * FROM nls_database_parameters;

      PROMPT ### Unified Auditing ###
      column parameter_name format a30
      column parameter_value format a20
      column audit_trail format a20
      select * from dba_audit_mgmt_config_params
      where audit_trail='UNIFIED AUDIT TRAIL' order by 1;

      PROMPT ### Auditing Tablespace Config ###
      col owner for a10
      col table_name for a30
      col column_name for a11
      col segment_name for a30
      col tablespace_name for a10
      select con_id,con_id_to_con_name(con_id) con_name,OWNER,TABLE_NAME,COLUMN_NAME,SEGMENT_NAME,TABLESPACE_NAME
      from cdb_lobs
      where ( table_name in ('AUD\$UNIFIED','AUD$','FGA_LOG$')
           or table_name like 'CLI_SWP%' )
      and column_name in ('RLS_INFO','RLS\$INFO','LOG_PIECE') $WHERECOND
      order by 1,3,4,5;

      PROMPT ### DATABASE Services ###
      col con_name for a10
      col name for a25
      col network_name for a25
      col active for a6
      select * from (
        select s.con_id,CON_ID_TO_CON_NAME(s.con_id) as con_name,
              s.name, s.NETWORK_NAME, nvl2(a.name,'YES','NO') as active
        from cdb_services s, v\$active_services a
        where s.con_id = a.con_id (+)
        and s.name = a.name (+)
      ) where 1=1 $WHERECOND
      order by 1;

      PROMPT ### Tablespaces ###
      col TABLESPACE format a15
      col status format a10
      col COMPRESS_FOR format a12
      col ENCRYPTED format a10
      col CONTENTS format a10
      --select con_id, con_id_to_con_name(con_id) as con_name,
      --       TABLESPACE_NAME as TABLESPACE,STATUS,CONTENTS,LOGGING,
      --       BIGFILE,ENCRYPTED,COMPRESS_FOR
      --  from cdb_tablespaces
      --  where 1=1 $WHERECOND
      --  order by con_id,tablespace_name;

      col mb format 9,999,999
      select * from (
      select t.con_id,CON_ID_TO_CON_NAME(t.con_id) as con_name,
            t.tablespace_name as TABLESPACE,t.status,t.contents,t.logging,
            nvl(f.cnt,0) as files,nvl(f.mb,0) as mb
        from cdb_tablespaces t, (
          select tablespace_name, count(1) cnt,round(sum(bytes)/1048576) mb
          from cdb_data_files
          group by tablespace_name
          union
          select tablespace_name, count(1) cnt,round(sum(bytes)/1048576) mb
          from cdb_temp_files
          group by tablespace_name
        ) f
        where t.tablespace_name = f.tablespace_name (+)
      ) where 1=1 $WHERECOND
      order by 1,5,3;

      PROMPT ### DB Directories ###
      col owner FORMAT a10
      col DIRECTORY_NAME FORMAT a30
      col DIRECTORY_PATH FORMAT a80
      select con_id, con_id_to_con_name(con_id) as con_name,
             owner, DIRECTORY_NAME, DIRECTORY_PATH
      from cdb_directories
      where con_id = origin_con_id
        and con_id = SYS_CONTEXT('USERENV', 'CON_ID') $WHERECOND
      order by 1,3,4;

      PROMPT ### DB Profiles ###
      col profile FORMAT A30
      col PASSWORD_VERIFY_FUNCTION FORMAT A30
      SELECT con_id, con_id_to_con_name(con_id) as con_name,
              profile, limit as PASSWORD_VERIFY_FUNCTION
      from cdb_profiles
      where RESOURCE_NAME='PASSWORD_VERIFY_FUNCTION' $WHERECOND
      order by 1,3,4;

      PROMPT ### DB Users (only created and altered user) ###
      col username for a20
      col account for a15
      col DEF_TBS for a10
      col TEMP_TBS for a10
      col AUTH_TYPE for a10
      col oracle for a6
      col profile for a20
      select con_id, con_id_to_con_name(con_id) as con_name,
             USERNAME,ACCOUNT_STATUS as account,
             AUTHENTICATION_TYPE as AUTH_TYPE,
             ORACLE_MAINTAINED as oracle,
             DEFAULT_TABLESPACE as DEF_TBS,
             TEMPORARY_TABLESPACE as TEMP_TBS,
             PROFILE
      from cdb_users
      WHERE ( oracle_maintained='N' or username in ('DBSNMP')) $WHERECOND
      order by 1,3;

      PROMPT ### DB Roles ###
      col role FORMAT A30
      SELECT con_id, con_id_to_con_name(con_id) as con_name, role
      FROM cdb_roles
      WHERE oracle_maintained='N' $WHERECOND
      order by 1,3;

      PROMPT ### Number invalid DB Objects ###
      SELECT count(1) from DBA_INVALID_OBJECTS;

      PROMPT ### Invalid DB Objects ###
      col owner for a10
      col OBJECT_NAME for a30
      col OBJECT_TYPE for a20
      col status for a10
      SELECT con_id, con_id_to_con_name(con_id) as con_name,
             status,owner,object_name,object_type
      from cdb_invalid_objects
      where 1=1 $WHERECOND
      order by 1,3,4,5,6;
EOF
    # RC=$?
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# GetStage
#   - Get stage from DBNAME
# Input parameter:
#   - $1: DBNAME of database
# Set variables:
#   - $STAGE
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

GetStage() {
  logger_debug "--> Function $FUNCNAME"
  local DBNAME="$1"
  local RC=0
  STAGE=`echo $DBNAME |rev|cut -c1`
  if [[ "$STAGE" != @(P|p|i|I|f|F|k|K|e|E) ]]
  then
    logger_error "Invalid Stage '$STAGE' for Database $1"
    RC=2
  else
    logger_debug "Valid Stage '$STAGE'"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# GetTnsServicename
#   - Generate tns service name for client connections based on DBNAME
# Input parameter:
#   - $1: DBNAME of database
# Set variables:
#   - $SERVICENAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

GetTnsServicename() {
  logger_debug "--> Function $FUNCNAME"
  local DBNAME="$1"
  local RC=0
  GetStage "$DBNAME"
  RC=$?
  SERVICENAME=""
  if [ "$RC" -eq 0 ]; then
    SERVICENAME="$(echo $1 |rev|cut -c2-|rev)-$STAGE"
  fi
  logger_debug "SERVICENAME=$SERVICENAME"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RemoteInstanceState
#   - Check if instance is in OPEN mode using a remote connection
# Input parameter:
#   - $1: TNS service name
# Required variables:
#   - $ORACLE_HOME, $PWDSYS
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RemoteInstanceState() {
  logger_debug "--> Function $FUNCNAME"
  local TNSSERVICE="$1"
  local RC=0
  local SQLFILE=`mktemp -u -t ${FUNCNAME}_XXXXXXXXXX.sql`
  cat <<EOCAT >$SQLFILE
    SET heading off feedback off pages 0
    SELECT decode(status,'STARTED','3','MOUNTED',2,'OPEN MIGRATE',1,'OPEN',0) FROM v\$instance;
EOCAT
  RunRemoteSQL sys $PWDSYS $TNSSERVICE $SQLFILE
  RC=$?

  if [ "$RC" -ne 0 ]; then
    logger_error "Could not get instance status (RC=$RC)"
  elif [ "$SQLOUTPUT" -ne 0 ]; then
    logger_error "Database not in correct state (status=$SQLOUTPUT)"
    RC=1
  else
    rm $SQLFILE
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RunRemoteSQL
#   - Run sql file on database using a remote connection
# Input parameter:
#   - $1: DB user name
#   - $2: DB user password
#   - $3: TNS service name
#   - $4: SQL file
# Required variables:
#   - $ORACLE_HOME
# Set variables:
#   - $SQLOUTPUT
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RunRemoteSQL() {
  logger_debug "--> Function $FUNCNAME"
  local USERNAME="$1"
  local PASSWORD="$2"
  local TNSSERVICE="$3"
  local SQLFILENAME="$4"
  local RC=0
  local CONNECT=""
  logger_debug "USERNAME=$USERNAME"
  logger_debug "PASSWORD=$PASSWORD"
  logger_debug "TNSSERVICE=$TNSSERVICE"
  logger_debug "SQLFILENAME=$SQLFILENAME"
  if [ "$USERNAME" == "sys" ]
  then
    CONNECT="CONNECT sys/\"${PASSWORD}\"@$TNSSERVICE AS SYSDBA"
  else
    CONNECT="CONNECT $USERNAME/\"${PASSWORD}\"@$TNSSERVICE"
  fi
  logger_debug "CONNECT=$CONNECT"
  SQLOUTPUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL # 2>/dev/null
    WHENEVER SQLERROR EXIT SQL.SQLCODE
    WHENEVER OSERROR EXIT 255
    $CONNECT
    -- SET heading off feedback off pages 0
    SET heading off pages 0
    SET markup csv on delimiter ' ' quote off
    @$SQLFILENAME
EOSQL
)"
  RC=$?
  logger_debug "SQLOUTPUT=$SQLOUTPUT"
  # if [ `echo "$SQLOUTPUT" |grep -c -i "error "` -gt 0 ]
  if [ "$RC" -ne 0 ]
  then
    logger_fatal "$SQLOUTPUT"
    [ "$RC" -ne 0 ] || RC=255
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# GetDBsize
#   - Get size of database (data and temp files) in mb.
# Input parameter:
#   - none
# Required variables:
#   - $PWDSYS $SERVICENAME
# Set variables:
#   - $DBSIZEMB
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

GetDBsize() {
  logger_debug "--> Function $FUNCNAME"
  DBSIZEMB=0
  local RC=0
  local SQLFILE=`mktemp -u -t ${FUNCNAME}_XXXXXXXXXX.sql`
  cat <<EOCAT >$SQLFILE
    SET heading off feedback off pages 0 trimspool on lines 1000  sqlblanklines on
    SELECT 'DBSIZEMB:'||round(sum(bytes)/1024/1024) as db_size_mb
      FROM (
        SELECT sum(bytes) as bytes FROM dba_data_files
        UNION
        SELECT sum(bytes) as bytes FROM dba_temp_files
    );
EOCAT
  RunRemoteSQL sys $PWDSYS $SERVICENAME $SQLFILE
  RC=$?
  logger_debug "SQLOUTPUT=$SQLOUTPUT"
  if [ "$RC" -gt 0 ]; then
    logger_error "Incorrect measurement (RC=$RC)"
  else
    DBSIZEMB="$(echo "$SQLOUTPUT"|grep 'DBSIZEMB:'|cut -d: -f2)"
    logger_debug "DBSIZEMB=$DBSIZEMB"
    rm $SQLFILE
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# GetFRAsize
#   - Get size of fast recovery area in mb.
# Input parameter:
#   - none
# Required variables:
#   - $PWDSYS $SERVICENAME
# Set variables:
#   - $FRASIZEMB
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

GetFRAsize() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  FRASIZEMB=0
  local SQLFILE=`mktemp -u -t ${FUNCNAME}_XXXXXXXXXX.sql`
  cat <<EOCAT >$SQLFILE
    SET heading off feedback off pages 0 trimspool on lines 1000  sqlblanklines on
    SELECT 'FRASIZEMB:'||round(sum(value)/1024/1024) as fra_size_mb
      FROM v\$spparameter
    WHERE name='db_recovery_file_dest_size';
EOCAT
  RunRemoteSQL sys $PWDSYS $SERVICENAME $SQLFILE
  RC=$?
  logger_debug "SQLOUTPUT=$SQLOUTPUT"
  if [ "$RC" -gt 0 ]
  then
    logger_error "Incorrect measurement (RC=$RC)"
  else
    FRASIZEMB="$(echo "$SQLOUTPUT"|grep 'FRASIZEMB:'|cut -d: -f2)"
    logger_debug "FRASIZEMB=$FRASIZEMB"
    rm $SQLFILE
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ModifyProfiles
#   - ALTER PROFILE for database.
# Input parameter:
#   - none
# Required variables:
#   - $PWDSYSTEM $SERVICENAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

ModifyProfiles() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local SQLFILE=`mktemp -u -t ${FUNCNAME}_XXXXXXXXXX.sql`
  cat <<EOCAT > $SQLFILE
    SET heading off feedback off pages 0 trimspool on lines 1000  sqlblanklines on
    BEGIN
      FOR c_rec in (
        SELECT DISTINCT profile FROM cdb_profiles
        WHERE profile NOT IN ('ORA_STIG_PROFILE')
          AND resource_name = 'PASSWORD_VERIFY_FUNCTION')
      LOOP
        BEGIN
          EXECUTE IMMEDIATE 'ALTER PROFILE '||c_rec.profile||' LIMIT PASSWORD_VERIFY_FUNCTION bv_verify_function';
        EXCEPTION
          WHEN OTHERS THEN
            dbms_output.put_line('Unable to alter Profile '||c_rec.profile||'  '||sqlerrm);
        END;
      END LOOP;
    END;
    /
EOCAT
  source $PWDDIR/.pwdfile_db_system
  RunRemoteSQL system $PWDSYSTEM $SERVICENAME $SQLFILE
  RC=$?
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CheckRestartFile
#   - Restart capability function
#   - To be used at begin of a function.
#   - Check if step can be ignored because already done.
#   - Otherwise write step to RESTARTFILE if Step ID >0
# Input parameter:
#   - $1: Step ID (JUMP parameter)
#   - $2: Return Code (for result update at end of function)
#   - $3: Executed function or script name (optional)
#        (default: called function or script name)
# Required variables:
#   - $RESTARTFILE, $RESTART
# Return Values
#   - 0: Step can be ignored because it hase already been done
#   - 1: Step has not yet been done
#   - >1: Something got wrong
# =================================================================================================

CheckRestartFile() {
  local SNUM="${1:-0}"   # Step ID (default: 0, invalid step number means skip function)
  local FNAME="$2"       # Function or script name (optional)
  local RC=0
  # logger_debug "Function $FUNCNAME (SNUM=$SNUM, FNAME=$FNAME)"
  RestartFile "CHK" "$SNUM" "0" "$FNAME"
  RC=$?
  return $RC
}


# =================================================================================================
# UpdateRestartFile
#   - Restart capability function
#   - To be used at end of a function.
#   - Update restartfile with return code
# Input parameter:
#   - $1: Step ID (JUMP parameter)
#   - $2: Return Code (for result update at end of function)
#   - $3: Function or script name (optional)
# Required variables:
#   - $RESTARTFILE
# Return Values
#   - 0: Successfull
#   - >0: Failed
# =================================================================================================

UpdateRestartFile() {
  local SNUM="${1:-0}"   # Step ID (default: 0, invalid step number means skip function)
  local SRET="${2:-0}"   # Step return value for TYPE=U (default: 0)
  local FNAME="$3"       # Function or script name (optional)
  local RC=0
  # logger_debug "Function $FUNCNAME (SNUM=$SNUM, SRET=$SRET, FNAME=$FNAME)"
  RestartFile "UPD" "$SNUM" "$SRET" "$FNAME"
  RC=$?
  return $RC
}

# =================================================================================================
# RestartFile
#   - Helper function for CheckRestartFile and UpdateRestartFile
#   - Do not use it in direct way.
# Input parameter:
#   - $1: Mode {CHK|UPD}
#   - $2: Step ID (JUMP parameter)
#   - $3: Return Code (for result update at end of function)
#   - $4: Executed function or script name (optional)
#        (default: caller function or script name)
# Required variables:
#   - $RESTARTFILE, $RESTART
# Return Values
#   - 0: Step can be ignored because it hase already been done
#   - 1: Step has not yet been done
#   - >1: Something got wrong
# =================================================================================================

RestartFile() {
  # This is a helper function used by CheckRestartFile|UpdateRestartFile
  # Do not use this function but its caller functions Check/UpdateRestartFile!
  local MODE=${1:-CHK}   # CHK=Check, UPD=Update restartfile
  local SNUM="${2:-0}"   # Step ID (default: 0, invalid step number means skip function)
  local SRET="${3:-0}"   # Step return value for TYPE=U (default: 0)
  local FNAME="$4"       # Function or script name (optional)
  local FTYPE=""
  local RC=0
  local SKIP=0
  local LOGDATUM=`date +"%Y-%m-%d %H:%M:%S"`
  local LNUM=""
  local LRET=""
  local RESTARTFILE=`eval echo $RESTARTFILE`
  local HELPER="${FUNCNAME[1]}"
  local CALLER="${FUNCNAME[2]}"

  # If RestarfFile was not called using Check/UpdateRestartFile function
  if ! [ "${FUNCNAME[1]}" == "UpdateRestartFile" -o "${FUNCNAME[1]}" == "CheckRestartFile" ]; then
    HELPER="$FUNCNAME"
    CALLER="${FUNCNAME[1]}"
  fi

  # Set FTYPE and FNAME for script or function
  if [ "$CALLER" == "main" ]; then
    FTYPE="Script"
    if [ -n "$FNAME" ]; then
      FNAME="`basename ${FNAME}`"
    else
      FNAME="`basename ${BASH_SOURCE[1]}`"
    fi
  else
    FTYPE="Function"
    [ -n "$FNAME" ] || FNAME="$CALLER"
  fi
  # logger_debug "Function $FUNCNAME (HELPER=$HELPER, CALLER=$CALLER, MODE=$MODE)"
  logger_debug "----> Function $HELPER ($FTYPE $FNAME: SNUM=$SNUM, SRET=$SRET)"

  # Validate step id
  if [ "$SNUM" -eq 0 ]; then
    logger_fatal "Invalid step number 0! It have to be >0!"
    RC=10
  fi
  # Validate RESTARTFILE variable
  if [ -z "$RESTARTFILE" ]; then
    logger_fatal "Environment variable RESTARTFILE missing!"
    RC=10
  fi
  if [ "$RC" -ne 0 ]; then
    logger_debug "<---- Function $HELPER skipped (RC=$RC)"
    return $RC
  fi

  # Create Restartfile if not exist
  if [ ! -r "$RESTARTFILE" ]; then
    local DIR=`dirname $RESTARTFILE`
    [ -d "$DIR" ] || mkdir -p "$DIR"
    echo "# Restartfile `basename $RESTARTFILE`" > $RESTARTFILE
    echo "# timestamp          id  rc type     name                " >> $RESTARTFILE
    echo "# ----------------- --- --- -------- --------------------" >> $RESTARTFILE
  fi

  #
  # For type == update
  #
  if [ "$MODE" == "UPD" ]; then
    echo "$LOGDATUM $(printf '%3d' $SNUM) $(printf '%3d' $SRET) $(printf '%-8s' ${FTYPE,,}) $FNAME" >> $RESTARTFILE
    logger_debug "<---- Function $HELPER (RC=$RC)"
    return $RC
  fi

  #
  # For type == check (check if step can be ignored)
  #
  RC=1  # Do not ignore this step by default.

  # # Get step entry from restartfile using last line
  # LNUM=`tail -1 "$RESTARTFILE"| grep -v '^#' | awk '{ print $4 }'`
  # LRET=`tail -1 "$RESTARTFILE"| grep -v '^#' | awk '{ print $5 }'`

  # Get step entry from restartfile using grep for step id with rc=0
  local LINE=`grep " $SNUM   0 " "$RESTARTFILE"|grep -v '^#'|tail -1`
  LNUM=`echo "$LINE" | awk '{ print $3 }'`
  LRET=`echo "$LINE" | awk '{ print $4 }'`
  logger_debug "SNUM=$SNUM, LNUM=$LNUM, LRET=$LRET"

  if [ -z "$LNUM" ]; then
    # no entry found in RESTARTFILE
    LNUM=0
  fi
  if [ -z "$LRET" ]; then
    # no return value set for last line in RESTARTFILE
    LRET=-1
  fi

  # write new values to the Restartfile
  # if current step not exist (SNUM > LNUM)
  # or current step exists but failed (SNUM == LNUM && LRET != 0)
  if [ "$SNUM" -gt "$LNUM" -o \( "$SNUM" -eq "$LNUM" -a "$LRET" -ne 0 \) ]; then
    # Run this step
    RC=1
    echo "$LOGDATUM $(printf '%3d' $SNUM) $(printf '%3s' ' ') $(printf '%-8s' ${FTYPE,,}) $FNAME" >> $RESTARTFILE
  else
    # Ignore this step
    RC=0
  fi

  # ignore restart file content and always run the step
  # if restart is not specified (RESTART=0)
  logger_debug "RESTART=$RESTART"
  if [ "$RESTART" -eq 0 ]; then
    RC=1
    # Should the restartfile updated now
    # or ignored by default (RESTART=0)?
    echo "$LOGDATUM $(printf '%3d' $SNUM) $(printf '%3s' ' ') $(printf '%-8s' ${FTYPE,,}) $FNAME" >> $RESTARTFILE
  fi

  # Final log message esp. for skip function
  if [ "$RC" -eq 0 ]; then
    logger_warn "Skip ${FTYPE,,} $FNAME"
    logger_debug "<---- Function $HELPER (RC=$RC)"
    logger_debug "<-- $FTYPE $FNAME (RC=$RC)"
  else
    logger_debug "<---- Function $HELPER (RC=$RC)"
  fi
  return $RC
}

# =================================================================================================
# CheckNumber
#   - Validate if parameter $1 is a number
# Input parameter:
#   - $1: value to be checked
# Return Values
#   - 0: Successful
#   - 1: Unsuccessful
# =================================================================================================

CheckNumber() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  if ! [ "$1" -eq "$1" ] 2> /dev/null
  then
    logger_error "$1 is not a valid number"
    RC=1
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ConfigOEM
#   - Run configuration for Oracle Cloud Control
# Input parameter:
#   - $1: Option (add|upd|del)
#   - $2: StepID for using restartfile (optional)
# Required variables:
#   - $DBNAME, $PORT, $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

ConfigOEM() {
  logger_debug "--> Function $FUNCNAME"
  local OPTION="${1,,}"   # add|upd|del
  local STEPID=${2:-0}
  local RC=0
  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  local HOST="$(hostname -f)"
  logger_debug "TNS_ADMIN=$TNS_ADMIN"
  export TNS_ADMIN
  case "$OPTION" in
    add) CMD="$SCRIPTDIR/ORAmakeEMconfig -a add -m $HOST -s $DBNAME -p $PORT -o $ORACLE_HOME" ;;
    upd) CMD="$SCRIPTDIR/ORAmakeEMconfig -a upd -m $HOST -s $DBNAME -p $PORT -o $ORACLE_HOME" ;;
    del) CMD="$SCRIPTDIR/ORAmakeEMconfig -a del" ;;
  esac
  eval "$CMD" 2>&1 | logger_debug
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_error "Creation of EM config file failed!"
    RC=0    # Set to OK until checked behavior and usage of ORAmakeEMconfig
  else
    logger_info "Successfully created EM config file"
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# SetPasswords
#   - Set passwords for important accounts
#   - Currently not in use !
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

SetPasswords() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local RC=0
  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  # $SCRIPTDIR/ORAsetpasswords -sid $DBNAME
  RC=$?
  if [ "$RC" -ne 0 ]
  then
    logger_error "Setting Initial Passwords Failed!"
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# RotateSYSpw
#   - Runs password rotation for sys and system
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Required variables:
#   - $DBNAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

RotateSYSpw() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  local RC=0
  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  for ACC in sys system
  do
    $SCRIPTDIR/ORArotate_pwd -sid $DBNAME -acc $ACC
    RC=$?
    if [ "$RC" -ne 0 ]
    then
      logger_error "rotating passwords for $ACC failed!"
      break
    fi
  done

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# GetOracleHomeFromVersion
#   - Helper function for "CheckVersion"
# -------------------------------------------------------------------------------------------------
# CheckVersion
#   - Get software version numbers and set ORACLE_HOME path
# Get Software Version
# Input parameter:
#   - none
# Required variables:
#   - $ORAVERSION e.g. 19000_230117
# Set variables:
#   - $MAINVERS, $MINORVERS, $ORACLE_HOME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

GetOracleHomeFromVersion() {
  # Helper function for "CheckVersion" funtion
  local VERS="$1"
  MAINVERS=`echo $VERS|cut -b -2`  # 1. - 2. Stelle
  MINORVERS=`echo $VERS|cut -b 3`  # 3. Stelle
  ORACLE_HOME="/app/oracle/product/${MAINVERS}.${MINORVERS}.0/db${VERS}"
  logger_debug "ORACLE_HOME=$ORACLE_HOME"
}
CheckVersion() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local VERS
  local VERSIONS
  logger_debug "ORAVERSION=$ORAVERSION"
  if [ -z "$ORAVERSION" ]; then
    # no version defined, get latest available version
    VERS="$($SCRIPTDIR/ORAclone_db -lv |tail -1)"
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_error "Could not retrieve ORACLE version!"
    else
      GetOracleHomeFromVersion "$VERS"
      RC=$?
    fi
  else
    VERSIONS="$($SCRIPTDIR/ORAclone_db -lv)"
    RC=$?
    if [ "$RC" -ne 0 ]; then
      logger_error "Could not retrieve available ORACLE versions!"
    else
      logger_debug "VERSIONS=$VERSIONS"
      for VERS in $VERSIONS
      do
        if [ "$VERS" == "$ORAVERSION" ]; then
          GetOracleHomeFromVersion VERS
          break
        fi
      done
    fi
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ProtectDatabase
#   - Add Database to Cohesity protection group
# Input parameter:
#   - $1: StepID for using restartfile (optional)
#   - $2: Cohesity protection group name e.g. ???
# Required variables:
#   - $DBNAME
# Set variables:
#   - $PROTECTIONGROUP
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

ProtectDatabase() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  export PROTECTIONGROUP="$2"
  logger_debug "exported PROTECTIONGROUP=$PROTECTIONGROUP"
  local RC=0
  local HOSTNAME=`hostname -s`
  local COHCLUSTER=""

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  logger_debug "PROTECTIONGROUP=$PROTECTIONGROUP"
  if [ `echo $PROTECTIONGROUP |fgrep -c BC` -eq 0 ]; then
    COHCLUSTER=cohclu21
  else
    COHCLUSTER=cohclu41
  fi
  CMD="$SCRIPTDIR/COHregisterORAserver --server $HOSTNAME --jobname $PROTECTIONGROUP --vip $COHCLUSTER"
  logger_debug "$CMD"
  eval $CMD 2>&1 | tee >(logger_debug)
  RC=$?

  if [ "$RC" -eq 0 ]; then
    # Eintrag in rmantab Datei
    # CMD="$SCRIPTDIR/COHrmantab -v $COHCLUSTER --sourcedb $DBNAME"
    CMD="$SCRIPTDIR/COHrmantab --server $HOSTNAME -v $COHCLUSTER --sourcedb $DBNAME"
    logger_debug "$CMD"
    $CMD 2>&1 | tee >(logger_debug)
    RC=$?
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# BlockChangeTracking
#   - Enables database block change tracking
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

BlockChangeTracking() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  local RC=0
  local SQLFILE=`mktemp -u -t ${FUNCNAME}_XXXXXXXXXX.sql`
  cat <<EOCAT > $SQLFILE
prompt ALTER DATABASE ENABLE BLOCK CHANGE TRACKING USING FILE '' ;
ALTER DATABASE ENABLE BLOCK CHANGE TRACKING USING FILE '' ;
EOCAT
  RunSingleSQL 'CDB$ROOT' "$SQLFILE"
  RC=$?
  if [ "$RC" -ne 0 ]; then
    if [ `echo "$SQLOUTPUT" |grep -c ORA-19752` -gt 0 ]; then
      logger_info "We can ignore ORA-19752 and set RC=0"
      RC=0  # Ignore this error!
    fi
  fi

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# BackupDatabase
#   - Runs a Cohesity Oracle database backup
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Required variables:
#   - $DBNAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

BackupDatabase() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }
  local RC=0

  CMD="$SCRIPTDIR/COHrunORAbackup --sourcedb $DBNAME"
  logger_debug "$CMD"
  `$CMD 2>&1` | tee >(logger_debug)
  RC=$?

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# CreateLogicalVolume
#   - Creates logical volume and filesystem
# Input parameter:
#   - $1: Volumenname (mostly data or fra)
# Required variables:
#   - $DBNAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

CreateLogicalVolume() {
  logger_debug "--> Function $FUNCNAME"
  local VOLUME="$1"
  local SIZEMB="$2"
  logger_debug "SIZEMB=$SIZEMB"
  # Check for FS already exist
  # CMD="sudo ${SUDODIR}/ORAlvcreate -c -l '${VOLUME,,}' -n '$DBNAME'"
  CMD="sudo ${SUDODIR}/ORAlvcreate -c -l '${VOLUME,,}'"
  logger_debug "$CMD"
  eval $CMD 2>&1 | tee >(logger_debug)
  RC=$?
  if [ $RC -ne 0 ]; then
    logger_warn "Filesystem or LV for storage area '$VOLUME' already exists. Skip creation."
    RC=0
    UpdateRestartFile "$JUMP" "$RC" "ORAlvcreate_for_${VOLUME^^}"
    return $RC
  fi

  # Check DATA/FRA size
  SIZEMB=`eval echo "\\${${VOLUME^^}SIZEMB:-\\$DEFAULT${VOLUME^^}SIZEMB}"`
  CheckNumber $SIZEMB || exit 1
  logger_debug "${VOLUME^^}SIZEMB=$SIZEMB"

  # Setup filesystem
  # CMD="sudo ${SUDODIR}/ORAlvcreate -l '${VOLUME,,}' -n '$DBNAME' -L '$SIZEMB' -D 1"
  CMD="sudo ${SUDODIR}/ORAlvcreate -l '${VOLUME,,}' -L '$SIZEMB' -D 1"
  logger_debug "$CMD"
  eval $CMD 2>&1 | tee >(logger_debug)
  RC=$?

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ConfigureHugepages
#   - Configure os huge pages
# Input parameter:
#   - $1: StepID for using restartfile (optional)
# Required variables:
#   - $DBNAME
# Return Values
#   -  0: Successful
#   - >0: Unsuccessful
# =================================================================================================

ConfigureHugepages() {
  logger_debug "--> Function $FUNCNAME"
  local STEPID=${1:-0}
  #
  # Configure OS Huge Pages
  logger_info "Configure huge pages .."
  # function from ORAlib use old ORAsethugepages path by default
  # set also some /etc/sysctl.conf parameter !
  # config_huge_pages 0 /app/oracle/bin/init/ORAsethugepages

  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  sudo ${SUDODIR}/ORAsethugepages | logger_debug
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_error "Configuration of huge pages failed (RC=$RC)"
    return 1
  fi

  logger_info "Bounce database $ORACLE_SID .."
  $SCRIPTDIR/ORAbounce_db -sid $ORACLE_SID | logger_debug
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_error "Bounce database failed (RC=$RC)"
    exit 1
  fi
  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME"
}

# =================================================================================================
# IsElementInList
#   - Check if element is in list
# Input parameter:
#   - $1: Element looking for
#   - $2: List of values delimited by delimiter
#   - $3: Delimiter (default: ,)
# Return Values
#   - 0: Element ist in list
#   - 1: Element is not in list
# =================================================================================================

function IsElementInList() {
  local ELEMENT="$1"
  local LIST="$2"
  local DELIMITER="${3:-,}"   # default: ,
  [[ "$LIST" =~ ($DELIMITER|^)$ELEMENT($DELIMITER|$) ]] && return 0 || return 1
}

# =================================================================================================
# GetCtmEnv
#   - Get CTM environment from CTM config data
# Set variables:
#   - CTMENV, CTMSTAGE, CTMHOST
# Return Values
#   - 0: Successful
#   - 1: Failed
# =================================================================================================

function GetCtmEnv()
{
  logger_info "Determine ctrl-m environment"
  local CTMCONFIG="/opt/ctm_ag/pcmag1/ctm/data/CONFIG.dat"
  if [ ! -s "$CTMCONFIG" ]
  then
    logger_error "The CTRL-M environment is not defined correctly!"
    logger_error "The config file $CTMCONFIG does not exist!"
    return 1
  else
    CTMENV="$(grep CTMSHOST "$CTMCONFIG"|awk '{print $2}'|awk -F\. '{print $1}'|tr [A-Z] [a-z])"
    logger_debug "CTMENV=$CTMENV"
    CTMSTAGE="$(echo ${CTMENV//ctms-/}|tr [a-z] [A-Z])"
    logger_debug "CTMSTAGE=$CTMSTAGE"
    CTMHOST=${CTMENV//-/}
    logger_debug "CTMHOST=$CTMHOST"
    return 0
  fi
}

# =================================================================================================
# GetCtmHostGroups
#   - Get CTM hostgroups for defined group identifier from cmdb
# Input parameter:
#   - $1: Datacenter  (CTMHOST from GetCtmEnv)
#   - $2: Kurzzweck   (column in bv$cmdb.ctm_hostgroup_def)
# Return Values
#   -  0: Successful
#   - >0: Failed
# =================================================================================================

function GetCtmHostGroups() {
  logger_debug "--> Function $FUNCNAME"
  local DATACENTER="$1"   # CTMHOST
  local KURZZWECK="$2"    # e.g. default|netbackup
  local RC=0
  logger_info "Determine ctrl-m host groups from cmdb"
  logger_debug "DATACENTER=$DATACENTER"
  logger_debug "KURZZWECK=$KURZZWECK"
  source $PWDDIR/.pwdfile_db_bvcmdb
  CTMGROUPS=""
  local SQLOUT=""
  SQLOUT="$($ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL 2>&1 | tee >(logger_debug)
  connect BV\$CMDB/"${PWDBVCMDB}" @dba-p
  SET heading off feedback off pages 0
  whenever sqlerror exit sql.sqlcode
  whenever oserror exit 255
  select nvl(listagg(grpname, ' '),0)
  from ctm_hostgroup_def
  where datacenter='$DATACENTER'
  and kurzzweck='$KURZZWECK'
  and rdbms='oracle';
EOSQL
  )"
  logger_info "SQLOUT=$SQLOUT"
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_error "Error in sql execution (RC=$RC)"
    RC=10
  elif [ "$SQLOUT" == "0" ]; then
    logger_error "Could not find a ctm host group!"
    RC=20
  else
    CTMGROUPS="$SQLOUT"
    logger_debug "CTMGROUPS=$CTMGROUPS"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ConfigCtmHostGroups
#   - Add host to CTM host groups defined for specific host group identifier
# Input parameter:
#   - $1: Hostgroup identified (bv$cmdb.ctm_hostgroup_def column kurzzweck)
# Return Values
#   -  0: Successful
#   - >0: Failed
# =================================================================================================

function ConfigCtmHostGroups() {
  logger_debug "--> Function $FUNCNAME"
  local KURZZWECK="$1"    #  e.g. default|netbackup
  local RC=0
  local RC1=0
  # Get current host ctm environment esp. CTMHOST
  GetCtmEnv
  RC=$?
  if [ "$RC" -eq 0 ]; then
    # Get CTMGROUPS
    GetCtmHostGroups "$CTMHOST" "$KURZZWECK"
    RC=$?
  fi
  if [ "$RC" -eq 0 ]; then
    for GRP in $CTMGROUPS
    do
      $SCRIPTDIR/CTMhostgroup -opt addhost -hgroup $GRP | logger_debug
      RC=$?
      if [ "$RC" -ne 0 ]; then
        RC1="$RC"
      fi
    done
    [ "$RC1" -eq 0 ] || RC="$RC1"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
# ConfigFoglight
#   - Add a database 'create' or 'delete' entry to cmdb for Foglight integration job
# Input parameter:
#   - $1: Option    create|remove
#   - $2: Hostname
#   - $3: DB unique name
#   - $4: Listener Port
#   - $5: StepID for using restartfile (optional)
# Required variables:
#   - $HOST','$ORACLE_SID','$DGUARDSIDE_UC','$PORT'
# Return Values
#   -  0: Successful
#   - >=: Failed
# =================================================================================================

function ConfigFoglight() {
  logger_debug "--> Function $FUNCNAME"
  local OPTION="${1,,}"     # create | delete
  local HOST="${2,,}"       # hostname -s
  local DBUNAME="${3^^}"    # db unique name
  local PORT="${4^^}"    # db unique name
  local STEPID=${5:-0}
  local RC=0
  [ $STEPID -eq 0 ] || { CheckRestartFile "$STEPID" && return 0 || true; }

  if [ -z "$DBUNAME" -o -z "$HOST" -o -z "$PORT" ]; then
    logger_error "Function input parameter missing!"
    return 1
  fi

  local DML=""
  local DBNAME="${DBUNAME//_*}"
  local DGSIDE="${DBUNAME//*_}"
  HOST="${HOST//.*}"
  logger_debug "OPTION=$OPTION"
  logger_debug "HOST=$HOST"
  logger_debug "DBNAME=$DBNAME"
  logger_debug "DGSIDE=$DGSIDE"
  logger_debug "PORT=$PORT"
  local DBMONUSER="c##paomon"

  # Determine CTM environment
  GetCtmEnv

  if [ "$OPTION" == 'create' ]; then
    DML="
    insert into ajc_data(task,datacenter,nodename,db_instance,dgside,lsnrport,mon_user,record_created)
    values('create','$CTMHOST','$HOST','$DBNAME','$DGSIDE','$PORT','$DBMONUSER',sysdate);
    "
  elif [ "$OPTION" == 'delete' ]; then
    DML="
    insert into ajc_data(task,datacenter,nodename,db_instance,lsnrport,mon_user,record_created)
    values('delete','$CTMHOST','$HOST','$ORACLE_SID',0,'$DBMONUSER',sysdate);
    "
  else
    logger_error "Option $OPTION not supported!"
    return 1
  fi

  logger_info "Add ${OPTION} entry to cmdb for Foglight integration job"
  source $PWDDIR/.pwdfile_db_bvajc
  $ORACLE_HOME/bin/sqlplus -s /nolog <<EOSQL 2>&1 | logger_debug
  WHENEVER SQLERROR EXIT SQL.SQLCODE
  WHENEVER OSERROR EXIT 255
  connect "BV\$AJC"/"${PWDBVAJC}"@dba-p
  ${DML}
  commit;
  exit;
EOSQL
  RC=$?
  if [ "$RC" -ne 0 ]; then
    logger_error "Add ${OPTION} entry to cmdb for Foglight integration failed!"
  else
    logger_debug "Successfully $OPTION database to/from cmdb for Foglight integration"
  fi
  logger_debug "SQLOUTPUT=$SQLOUTPUT"

  [ $STEPID -eq 0 ] || UpdateRestartFile "$STEPID" "$RC"
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}
# =================================================================================================
#
# InstallSoftware
#   - Installs the Oracle Database Software
# exit 1 if invalid software or size
# exit 2 if Software has already been installed
# exit 3 if insufficent space in filesystem
#
# =================================================================================================

InstallSoftware()
{
  logger_debug "--> $FUNCNAME"
  local VERSION=$1
  logger_debug "VERSION=$VERSION"
  local MAJOR=`echo $VERSION|cut -c1-2`
  logger_debug DBSOFTWAREDIR=${DBSOFTWAREDIR}
  local DBSOFTWAREDIR=${DBSOFTWAREDIR}/${MAJOR}.0.0/database
  logger_debug "DBSOFTWAREDIR=$DBSOFTWAREDIR"
  local DBVERSION=db`grep ${VERSION} ${DBSOFTWAREDIR}/images.ini|cut -d: -f2`
  logger_debug "DBVERSION=$DBVERSION"
  local SWSIZE=`grep $VERSION ${DBSOFTWAREDIR}/images.ini |cut -d: -f3`
  local DBSOFTWARE=${DBSOFTWAREDIR}/${DBVERSION}.zip
  logger_debug "DBSOFTWARE=$DBSOFTWARE"
  logger_debug "SWSIZE=$SWSIZE"
  if [ -z "$SWSIZE" -o -z "$DBSOFTWARE" ]
  then
    logger_error "Unable to find Database Software in ${DBSOFTWAREDIR}/${MAJOR}.0.0/database"
    return 1
  fi
  local INST_ORACLE_HOME=${ORAPRODDIR}/${MAJOR}.0.0/${DBVERSION}
  logger_debug INST_ORACLE_HOME=$INST_ORACLE_HOME
  if [ -d $INST_ORACLE_HOME ]
  then
    if [ `du -sm $INST_ORACLE_HOME |awk '{ print $1 }'` -gt 100 ]
    then
      logger_error "Database Software is already installed"
      return 2
    fi
  fi
  FSSIZE=`df -m |grep /app |awk '{ print $4 }'`
  logger_debug "FSSIZE=$FSSIZE"
  if [ $FSSIZE -lt $SWSIZE ]
  then
    logger_error "Insufficient space in Filesystem /app"
    return 3
  fi

  CopyPasswords
  mkdir -p $INST_ORACLE_HOME
  cd $INST_ORACLE_HOME
  logger_info "Unzip Software ..."
  unzip $DBSOFTWARE >/dev/null 2>&1
  logger_info "... done"
  CV_ASSUME_DISTID=OL7
  export CV_ASSUME_DISTID
  local OPTIONS="oracle.install.option=INSTALL_DB_SWONLY UNIX_GROUP_NAME=oinstall INVENTORY_LOCATION=/app/oraInventory ORACLE_HOME=$INST_ORACLE_HOME ORACLE_BASE=$ORACLE_BASE oracle.install.db.InstallEdition=EE oracle.install.db.OSDBA_GROUP=dba oracle.install.db.OSOPER_GROUP=dba oracle.install.db.OSBACKUPDBA_GROUP=dba oracle.install.db.OSDGDBA_GROUP=dba oracle.install.db.OSKMDBA_GROUP=dba oracle.install.db.OSRACDBA_GROUP=dba oracle.install.db.rootconfig.executeRootScript=false"
  COMMAND="$INST_ORACLE_HOME/runInstaller -silent $OPTIONS"
  logger_debug "COMMAND=$COMMAND"
  MESSAGE=`$COMMAND`
  logger_debug "$MESSAGE"

  if [ `echo "$MESSAGE" | grep -c "Successfully"` -ne 1 ]
  then
    logger_error "$MESSAGE"
    return 2
  fi
  logger_debug sudo ${INST_ORACLE_HOME}/root.sh
  MESSAGE=`sudo ${INST_ORACLE_HOME}/root.sh`
  logger_debug $MESSAGE
  MESSAGE=`$INST_ORACLE_HOME/bin/roohctl -enable`
  logger_debug $MESSAGE
  ReadOnlyTNSAdmin $INST_ORACLE_HOME
  logger_debug "<-- $FUNCNAME"
  return 0
}

# =================================================================================================
#
# NewTNSADMIN
#
# =================================================================================================

NewTNSADMIN() {
  logger_debug "--> $FUNCNAME"
  if [ -z "$ORACLE_HOME" -o "$ORACLE_HOME" = "NONE" ]
  then
    logger_error "Unable to set Network Parameters, ensure ORACLE_HOME has been set properly"
    return 1
  fi
  local TEMPDIR="/tmp/network_`date +%Y%m%d`"
  if [ -n ${ORACLE_HOME} ]
  then
    ORABASEHOME=`${ORACLE_HOME}/bin/orabasehome`
    local ORABASEHOMENET=${ORABASEHOME}/network/admin
    logger_debug ORABASEHOMENET=$ORABASEHOMENET
  else
    logger_debug "unable to find ORACLE_HOME"
    return 1
  fi
  if [ -d "$TEMPDIR" ]
  then
     rm ${TEMPDIR}/*.ora
  fi
  mkdir -p $TEMPDIR
  logger_debug "--> $FUNCNAME"
  if [ -n "$TNS_ADMIN" ]
  then
    mv ${TNS_ADMIN}/*.ora $TEMPDIR
  fi
  cp $TEMPDIR/*.ora ${ORABASEHOMENET}
  if [ "$TNS_ADMIN" != "${ORABASEHOMENET}" ]
  then
    ln -s ${ORABASEHOMENET}/*.ora $TNS_ADMIN
  fi
  rm $TEMPDIR/*
  rmdir $TEMPDIR
  logger_debug "<-- $FUNCNAME"
}

# =================================================================================================
#
# ReadOnlyTNSAdmin
#
# =================================================================================================

ReadOnlyTNSAdmin() {
  logger_debug "--> $FUNCNAME"
  if [ -z "$ORACLE_HOME" -o "$ORACLE_HOME" == "NONE" ]
  then
     ORACLE_HOME=$1
  fi
  export ORACLE_HOME
  ORABASEHOME=`${ORACLE_HOME}/bin/orabasehome`
  logger_debug "ORACLE_HOME=$ORACLE_HOME"
  ORABASEHOMENET=${ORABASEHOME}/network/admin
  logger_debug "ORABASEHOMENET=$ORABASEHOMENET"
  if [ -d "$ORABASEHOMENET" ]
  then
    logger_debug "$ORABASEHOMENET exists"
    [ ! -e "$ORABASEHOMENET"/ldap.ora ] && cp $LDAPORAFILE $ORABASEHOMENET/ldap.ora
    [ ! -e "$ORABASEHOMENET"/sqlnet.ora ] && cp $SQLNETORAFILE $ORABASEHOMENET/sqlnet.ora
  fi
  logger_debug "<-- $FUNCNAME"
}


# =================================================================================================
#
# List Database Software version
#
# =================================================================================================

ListSWVersion() {
  logger_debug "--> $FUNCNAME"
  for lmajor in `ls  ${DBSOFTWAREDIR}`
  do
    logger_info "Major Versions: $lmajor"
    for lversion in `cut -d: -f1 ${DBSOFTWAREDIR}/${lmajor}/database/images.ini`
    do
      logger_info "Version: $lversion"
    done
  done
  logger_debug "<-- $FUNCNAME"
  return 0
}

# =================================================================================================
#
# Check Database Software version
#
# =================================================================================================

CheckSWVersion() {
  logger_debug "--> $FUNCNAME"

  logger_debug "Software Version = $1"
  local major=`echo $1|cut -d. -f1`
  if [ `grep -c $1 ${DBSOFTWAREDIR}/${major}.0.0/database/images.ini` -ne 1 ]
  then
    logger_error "Invalid Oracle Version"
    logger_error "Allowed Versions are: "
    ListSWVersion
    return 1
  fi
  SWVERSION=$1
  logger_debug "SWVERSION=$SWERSION"
  logger_debug "<-- $FUNCNAME"
  return 0
}

# =================================================================================================
#
# Kill all Sessions except BVAUTOUPGRADE
#
# =================================================================================================

KillSessionsExcept() {
  logger_debug "--> $FUNCNAME"
  local SERVICENAME=$1
  local USERNAME=$2
  local PASSWORD=$3
#
# Create SQL File
#
  cat <<EOSQL > $SQLFILE
set serveroutput on
spool /tmp/locked_accounts
WHENEVER SQLERROR CONTINUE
DECLARE
  l_string VARCHAR2(1000);
BEGIN
  FOR c_rec IN (
    SELECT sid, serial#, status, username 
      FROM v\$session 
     WHERE username IN (
       SELECT username 
         FROM cdb_users
        WHERE ORACLE_MAINTAINED='N'
         AND USERNAME!='BVAUTOUPGRADE'))
  LOOP
    l_string := 'ALTER SYSTEM DISCONNECT SESSION '''||c_rec.sid||','||c_rec.serial#||''' IMMEDIATE';
    dbms_output.put_line(l_string);
    EXECUTE IMMEDIATE l_string;
  END LOOP;
END;
/
EOSQL
  CMD="RunRemoteSQL $USERNAME $PASSWORD $SERVICENAME $SQLFILE"
  logger_debug $CMD
  $CMD
  RC=$?
  logger_debug  "RC=$RC"
  logger_debug "<-- $FUNCNAME"
  if [ "$RC" -ne 0 ]
  then
   logger_error "Unable to Terminate User session"
    RC=11
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
#
# Lock all Users except BVAUTOUPGRADE
#
# =================================================================================================

LockUsersExcept() {
  logger_debug "--> $FUNCNAME"
  local SERVICENAME=$1
  local USERNAME=$2
  local PASSWORD=$3
#
# Create SQL File
#
  cat <<EOSQL > $SQLFILE
set serveroutput on
spool /tmp/locked_accounts
WHENEVER SQLERROR CONTINUE
DECLARE
  str VARCHAR2(1000);
BEGIN
  FOR c_rec IN (SELECT username FROM cdb_users
   WHERE ACCOUNT_STATUS NOT LIKE '%LOCKED%'
     AND ORACLE_MAINTAINED='N'
     AND USERNAME!='BVAUTOUPGRADE')
  LOOP
    str := 'ALTER USER '||c_rec.username||' ACCOUNT LOCK';
    EXECUTE IMMEDIATE str;
    dbms_output.put_line(str);
  END LOOP;
END;
/
EOSQL
  CMD="RunRemoteSQL $USERNAME $PASSWORD $SERVICENAME $SQLFILE"
  logger_debug $CMD
  $CMD
  RC=$?
  logger_debug  "RC=$RC"
  if [ "$RC" -ne 0 ]
  then
   logger_error "Unable to lock Users "
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
#
# Unlock all Users who have been locked x hours ago (default 48)
#
# =================================================================================================

UnLockUsers() {
  logger_debug "--> $FUNCNAME"
  local SERVICENAME=$1
  local USERNAME=$2
  local PASSWORD=$3
#
# Create SQL File
#
  cat <<EOSQL > $SQLFILE
set serveroutput on
spool /tmp/locked_accounts
WHENEVER SQLERROR CONTINUE
DECLARE
  str VARCHAR2(1000);
BEGIN
  FOR c_rec IN (SELECT username FROM cdb_users
   WHERE ACCOUNT_STATUS NOT LIKE '%LOCKED%'
     AND ORACLE_MAINTAINED='N'
     AND USERNAME!='BVAUTOUPGRADE')
  LOOP
    str := 'ALTER USER '||c_rec.username||' ACCOUNT LOCK';
    EXECUTE IMMEDIATE str;
    dbms_output.put_line(str);
  END LOOP;
END;
/
EOSQL
  CMD="RunRemoteSQL $USERNAME $PASSWORD $SERVICENAME $SQLFILE"
  logger_debug $CMD
  $CMD
  RC=$?
  logger_debug  "RC=$RC"
  if [ "$RC" -ne 0 ]
  then
   logger_error "Unable to lock Users "
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}


# =================================================================================================
#
# Check if Instance with $1 Name is running
# Return Codes:
#  4 --> Wrong DB_NAME
#  3 --> Not Running
#  2 --> Not mounted
#  1 --> Mounted
#  0 --> Open Read Write
#
# =================================================================================================

CheckInstance() {
  logger_debug "--> $FUNCNAME"
  local DBNAME=$1
#
# if dabname is db_unqiue_name remove the _Sx string
#
  DBNAME=`echo $DBNAME |awk -F_ '{ print $1 }'`
  logger_debug "DBNAME=$DBNAME"
#
# Get Instanceinfo from /etc/oratab
#
  if [ `grep -c "^${DBNAME}:" /etc/oratab` -eq 1 ]
  then
    ORAENV_ASK=NO
    ORACLE_SID=$DBNAME
    logger_debug "ORACLE_SID=$ORACLE_SID"
    . oraenv -s
    unset ORAENV_ASK
    logger_debug "ORACLE_SID=$ORACLE_SID"
  else
    logger_error "Unable to find Database "$DBNAME" in /etc/oratab"
    return 4
  fi
  logger_debug "ORACLE_SID=$ORACLE_SID"
#
# Check if Instance is running
#
  if [ `ps -ef |grep ora_pmon_${ORACLE_SID}|grep -v grep|wc -l` -eq 0 ]
  then
    logger_warn "Database $DBNAME not running" 
    return 3
  fi
#
#
#
  STATUS=$(sqlplus -s / as sysdba <<EOSQL # >/dev/null
set heading off feedback off trimspool on
WHENEVER SQLERROR EXIT 3
SELECT decode(open_mode,'READ WRITE',1,0) FROM v\$database;
EOSQL
)
  RC=$?
  logger_debug RC=$RC
  logger_debug STATUS==$STATUS

  if [ "$RC" -ne 0 ]
  then
    logger_warn "Database $DBNAME not mounted"
    return 2
  fi
  if [ "$STATUS" -ne 1 ]
  then
    logger_warn "Database $DBNAME not open"
    return 1
  fi

  RC=0
  logger_debug "<-- $FUNCNAME $RC"
}
