# @(#) ================================================================================================================
# @(#) File        : ORApitRecover
# @(#) Author      : Dieter Smets
# @(#) Modified    :
# @(#)
# @(#) Description : This script executes Database Restore to specified Timestamp
# @(#)
# @(#) Version     : 1.1
# @(#) Datum       : 24.10.2018
# @(#)
# @(#) Presumption : 
# @(#)
# @@(#)  Change History:
# @@(#)
# @@(#)  1.0  2018-10-22  Smets       Created
# @@(#)  1.1  2018-10-24  Smets       Restore basierend auf entspr. Inkarnation, falls zuvor bereits ein restore
# @@(#)                               auf spätere Zeit durchgeführt wurde.
# @(#) ================================================================================================================
set +x
#-----------------------------------------------------------------------------------------------------------------
#     Global script environment
#-----------------------------------------------------------------------------------------------------------------
PRINTOUT=0   # wird evtl. später mal als optionaler Parameter implementiert ???
CTMRUN=0     # 
SCRIPTNAME=$(basename $0)
SCRIPTDIR=/app/oracle/bin
SCRIPTSHORTDESC="This script executes Database Restore to specified Timestamp

"

source /app/oracle/bin/ORAlib
PWDDIR=/app/oracle/admin/etc/pwddir
RMANPWDFILE="${PWDDIR}/.pwdfile_db_rman"

FILETS=`date +%Y%m%d_%H%M%S`
pitRecover_SYSOUT=/app/oracle/admin/log
umask 0002
#-----------------------------------------------------------------------
# Logger Script
#-----------------------------------------------------------------------
#
Logger

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Help routine
#-----------------------------------------------------------------------------------------------------------------
function usage()
{
if [ $help -eq 1 ]
then
   RC=0
else
   RC=1
fi

echo ""
echo "  Command     : $SCRIPTNAME [-h|--help] $SID_OS|[$SID_OL] 'SID' $TS_OS|[$TS_OL] 'TIMESTAMP' [$F_OS|$F_OL]"
echo "  Description : $SCRIPTSHORTDESC"
echo ""
echo "  Parameters  : $SID_OPT,    Oracle SID"
echo "                $TS_OPT,      Restore Timestamp, yyyymmdd-hhmmss"
echo "                $F_OPT,           Force DB-Restore without confirmation"
echo "                $H_OPT,                help screen"
echo ""
echo "  Example     : Run Restore Database on SID XXXP to timestamp:"
echo "                ${SCRIPTNAME} $SID_OS xxxp $TS_OS 19590922-223000"
echo ""
echo ""
#remove_tmpfiles
exit $RC
}
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Check the given Restore Timestamp: if not in the future, if not older than 14 days
#-----------------------------------------------------------------------------------------------------------------
function check_restore_timestamp
{
RC=0
SQLRESULT=/tmp/result_sql1.lst
sqlplus -s / as sysdba <<EOSQL1 >/dev/null 2>&1
set hea off;
set pages 0
col TSRESULT format a9;
spool $SQLRESULT;
SELECT CASE
        WHEN SYSDATE - TO_DATE('${RESTORETS}', 'yyyymmdd-hh24:mi:ss') <  0 THEN 'FUTURE'
        WHEN SYSDATE - TO_DATE('${RESTORETS}', 'yyyymmdd-hh24:mi:ss') > 14 THEN 'TOO_OLD'
        ELSE 'OK'
        END AS TSRESULT
 from dual;
EOSQL1

checkORAerr
if [ ${RC} -gt 0 ]; then
     logger_error "*************************************************************"
     logger_error "* Given Restore Timestamp is not valid. Wrong Format or invalid Timestamp."
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
#     remove_tmpfiles
     rm $SQLRESULT 2>/dev/null
     exit ${RC}
fi

TSRESULT=`awk '{print $1}' $SQLRESULT`
rm $SQLRESULT 2>/dev/null

if [ "$TSRESULT" != "OK" ]
then
   logger_error "*************************************************************"
   logger_error "* Given Restore Timestamp is not valid. In the Future or too old."
   RC=1
   logger_error "* RC=$RC"
   logger_error "*************************************************************"
#   remove_tmpfiles
   exit ${RC}
fi
}
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Determine the Incarnation Number corresponding to the Restore Timestamp
#-----------------------------------------------------------------------------------------------------------------
function Get_Incarnation_Of_RestTS()
{
  RC=0
  TMPSQLOUT="/tmp/$SCRIPTNAME.tmp."`date +%s`

  sqlplus -s / as sysdba <<EOSQL >$SQLRESULT 2>&1
  connect / as sysdba
  set serverout on size unlimited feedback off
  whenever sqlerror exit sql.sqlcode
  spool $TMPSQLOUT
  declare
    l_incarnation_no pls_integer  := 0;
  begin
    select incarnation#
      into l_incarnation_no
      from v\$database_incarnation
     where RESETLOGS_TIME=(select max(RESETLOGS_TIME)
                             from v\$database_incarnation
                            where RESETLOGS_TIME<=to_date('${RESTORETS}', 'yyyymmdd-hh24miss'));
    dbms_output.put_line('export INCARNATION_NO='||l_incarnation_no);
  end;
/
EOSQL
  RC=$?
  if [ "$RC" -eq 0 ]; then
    source $TMPSQLOUT
  fi
  rm $TMPSQLOUT 2>/dev/null
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
#     END of FUNCTION SECTION
#-----------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------
#     Get Parameter
#-----------------------------------------------------------------------------------------------------------------
#set -x
SID_OS="-sid"; SID_OL="--oracle-sid"; SID_OPT="$SID_OS[|$SID_OL]"
TS_OS="-ts"; TS_OL="--timestamp";     TS_OPT="$TS_OS[|$TS_OL]"
F_OS="-f"; F_OL="--force";            F_OPT="$F_OS[|$F_OL]"
H_OS="-h"; H_OL="-?";                 H_OPT="$H_OS[|$H_OL]"

help=0
FORCE=0
RC=0
if [ $# -eq 0 ]
then
   usage
else
   while [ $# -gt 0 ]; do
     case "$1" in
         $SID_OS | $SID_OL ) SID="$2"
                             SID=`echo $SID|tr [a-z] [A-Z]`
                             sid=1
                             shift 2;;
         $TS_OS | $TS_OL )   RESTORETS="$2"
                             restorets=1
                             shift 2;;
         $F_OS | $F_OL )     FORCE=1
                             shift 1;;
         $H_OS | $H_OL )     help=1
                             usage;;
         * )                 echo "*************************************************************"
                             echo "* Parameter Error at '$1'"
                             echo "*************************************************************"
                             usage;;
     esac
   done
fi
#-----------------------------------------------------------------------------------------------------------------
#     test to see if they gave the mandatory options
#-----------------------------------------------------------------------------------------------------------------
if [ "x" == "x$sid" ]; then
  MESSAGE="$SID_OPT Option is required!"
  logger_error "$MESSAGE"
#  remove_tmpfiles
  exit 1
fi
if [ "x" == "x$restorets" ]; then
  MESSAGE="$TS_OPT Option is required!"
  logger_error "$MESSAGE"
#  remove_tmpfiles
  exit 1
fi
#-----------------------------------------------------------------------------------------------------------------
#     evaluate conditional options
#-----------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------
#     Main Processing
#-----------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------
SYSOUT=${pitRecover_SYSOUT}/${SCRIPTNAME}-SYSOUT-${SID}-${FILETS}.log
rm -f ${SYSOUT}

MESSAGE="All actions are logged in ${SYSOUT}!"
logger_info "${MESSAGE}";

MESSAGE="Oracle SID:        ${SID}";   echo "${MESSAGE}" >> ${SYSOUT}; logger_info "${MESSAGE}";

MESSAGE="RESTORE Timestamp: ${RESTORETS}";   echo "${MESSAGE}" >> ${SYSOUT}; logger_info "${MESSAGE}";

#-----------------------------------------------------------------------------------
#     Check if user is oracle, otherwise abort   
#-----------------------------------------------------------------------------------
if [ `id -un` != "oracle" ]; then
     logger_error "*************************************************************"
     logger_error "* Script may not run as user `id -un`, it must be started and run as oracle"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
#     remove_tmpfiles
     exit ${RC}
fi
#-----------------------------------------------------------------------------------
#     Check if the given Instance is running on the current host
#-----------------------------------------------------------------------------------
CheckInstance ${SID}
RC=$?
if [ ${RC} -eq 0 ]; then
     logger_error "*************************************************************"
     logger_error "* Instance ${SID} is not running on the current host `hostname`"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
#     remove_tmpfiles
     exit ${RC}
fi
#-----------------------------------------------------------------------------------
#     Check if Backups by RMAN or Actifio:
#-----------------------------------------------------------------------------------
det_used_rcvcatoid
RCVCATOID=${RCVCATOID:0:6}
if [ "$RCVCATOID" !=  "rcvcat" ]; then
   logger_error "*************************************************************"
   logger_error "* Instances with BACKUPs by Actifio are not supported yet!"
   RC=1
   logger_error "* RC=$RC"
   logger_error "*************************************************************"
#   remove_tmpfiles
   exit ${RC}
fi
#-----------------------------------------------------------------------------------
#     Check the given Restore Timestamp:
#-----------------------------------------------------------------------------------
check_restore_timestamp
#-----------------------------------------------------------------------------------
#     Check FORCE Option:
#-----------------------------------------------------------------------------------
if [ $FORCE -eq 0 ]
then
   read -p "Confirm YES to continue: " FORCECONF
   if [ "$FORCECONF" !=  "YES" ]
   then
      logger_error "*************************************************************"
      logger_error "* Confirmation for DB Restore not given. Execution stopped."
      RC=2
      logger_error "* RC=$RC"
      logger_error "*************************************************************"
#     remove_tmpfiles
      exit ${RC}
   else
      MESSAGE="* Confirmation for DB Restore has been given. Execution continues.";   echo "${MESSAGE}" >> ${SYSOUT}; logger_info "${MESSAGE}";
   fi
else
   MESSAGE="* Script has been started with the -force Option. Execution continues.";   echo "${MESSAGE}" >> ${SYSOUT}; logger_info "${MESSAGE}";
fi
#-----------------------------------------------------------------------------------
#     Start restoring the Database:
#-----------------------------------------------------------------------------------
echo ". . . Determine the Incarnation corresponding to the given Restore Point . . ." 

Get_Incarnation_Of_RestTS
if [ "$?" -ne 0 ]; then
     logger_error "*************************************************************"
     logger_error "* Error during determining the corresponding Incarnation ..."
     cat ${SQLRESULT} >>${SYSOUT}
     cat ${SYSOUT}
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
     rm $SQLRESULT 2>/dev/null
     exit ${RC}
fi
MESSAGE="* Corrsponding Incarnation for Restore TS is: ${INCARNATION_NO}.";   echo "${MESSAGE}" >> ${SYSOUT}; logger_info "${MESSAGE}";

echo ". . . executing shutdown and startup mount . . ." 

sqlplus -s / as sysdba <<EOSQL2 >>$SQLRESULT 2>&1
shutdown immediate;
startup mount;
exit;
EOSQL2
checkORAerr
if [ ${RC} -gt 0 ]; then
     logger_error "*************************************************************"
     logger_error "* Error during Shutdown ..."
     cat ${SQLRESULT} >>${SYSOUT}
     cat $SYSOUT
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
#     remove_tmpfiles
     rm $SQLRESULT 2>/dev/null
     exit ${RC}
fi
#rm $SQLRESULT 2>/dev/null

echo ". . . executing Restore . . ."
echo ". . . To view Restore Messages during Restore: Login to host `hostname` and enter tail -f $SQLRESULT"

#source $RMANPWDFILE
#connect catalog rman/$PWDRMAN@rcvcat-n
rman target / <<EORMAN1 >>$SQLRESULT 2>&1

reset database to incarnation ${INCARNATION_NO};
run
{
allocate channel RST1 type SBT_TAPE;
set until time "to_date('${RESTORETS}', 'yyyymmdd-hh24miss')";
restore database;
recover database; }
exit
EORMAN1
checkRMANerr
if [ ${RC} -gt 0 ]; then
     logger_error "*************************************************************"
     logger_error "* Error during RMAN Restore ..."
     cat ${SQLRESULT} >>${SYSOUT}
     cat $SYSOUT
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
#     remove_tmpfiles
#     rm $SQLRESULT 2>/dev/null
     exit ${RC}
fi

echo ". . . executing open resetlogs . . ." 
sqlplus -s / as sysdba <<EOSQL2 >>$SQLRESULT 2>&1
alter database open resetlogs;
exit;
EOSQL2
checkORAerr
if [ ${RC} -gt 0 ]; then
     logger_error "*************************************************************"
     logger_error "* Error during Open resetlogs ..."
     cat ${SQLRESULT} >>${SYSOUT}
     cat $SYSOUT
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
#     remove_tmpfiles
     rm $SQLRESULT 2>/dev/null
     exit ${RC}
fi

cat ${SQLRESULT} >>${SYSOUT}
rm $SQLRESULT 2>/dev/null
echo "***"
echo "***"
echo "***"
cat ${SYSOUT}
echo "***"
echo "***"
echo "***"

exit ${RC}