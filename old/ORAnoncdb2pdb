# @(#) ================================================================================================================
# @(#) File        : ORAnoncdb2pdb
# @(#) Author      : Johannes Ahrends, CarajanDB GmbH
# @(#) Version     : 1.0
# @(#) Date        : 2024-09-03
# @(#) Description : Migrate Oracle NONCDB to PDB
# @(#)               Must run on target server
# @(#)
# @@(#)  Change History:
# @@(#)  Version  Date        Author        Description
# @@(#)  ------------------------------------------------------------------------------------------------
# @@(#)  0.1      2023-03-20  J. Ahrends    initial Script
# @@(#)  0.2      2023-03-18  J. Ahrends    added autoupgrade
# @@(#)  0.3      2023-06-03  M. Pils       fixed indentation, added options --targetcdb, --targetpdb, --clear
# @@(#)                                     set STARTTIME default to now, added CharSet check and some logger info
# @@(#)  0.4      2024-03-18  M. Pils       added --parallel option and new --skip option
# @@(#)                                     added RunAutoupgradePostProc and ORABINDIR
# @@(#)  0.5      2024-07-08  M. Pils       redesigned --skip option and added PDBREFRESHINTERVAL
# @@(#)  0.6      2024-07-17  M. Pils       minor changes (variable names, comments)
# @@(#)  0.7      2024-08-12  J. Ahrends    Allow autoupgrade Rerun
# @@(#)  0.8      2024-08-17  J. Ahrends    Error correction
# @@(#)  1.0      2024-09-03  J. Ahrends    Use target_migration_time as start_time
# @(#) ================================================================================================================

# Set Variable ORABINDIR if you want to test / develop
export ORABINDIR="${ORABINDIR:-/app/oracle/bin}"
export ORABASEDIR="${ORABASEDIR:-${ORACLE_BASE}}"
export   UPGRADEDIR=${ORABINDIR}/autoupgrade

# Read Oracle Library including Logger
source $ORABINDIR/ORAlib
source $ORABINDIR/ORACDBlib

# Init log4sh with default logfile name
Logger 

# Read default parameters
Parameter
DBLINKNAME=BVDBCLONE

# =================================================================================================
#
# Function Usage
# Assumption: The database name is unique in the entire Barmenia environment
#
# Options:
#
# =================================================================================================

usage() {
  if [ -z "$SOURCEDB" ]; then
    TARGETPDB="{SourceDB without Stage}"
  else
    TARGETPDB="$(echo $SOURCEDB |rev|cut -c2-|rev)"
  fi
  logger_info "Usage $0 --sourcedb DBNAME --targetdb DBNAME [--start_time YYYY-MM-DD_HH24:MI:SS] [-pparallel N] [--clear] "
  logger_info "--sourcedb   : Name of the NONCDB database"
  logger_info "--targetcdb  : Name of the CDB database"
  logger_info "--targetpdb  : Name of the PDB database (default: $TARGETPDB)"
  logger_info "--start_time : Time when the migration should start. if missed or negative start immediatly after copy"
  logger_info "--parallel N : Parallel processing degree"
  logger_info "--clear      : cleanup autoupgrade status from previous execution"
  logger_info "--skip 'fs'  : Comma separated list of skip step options (fs = filesystem check)"
  logger_info "Example: $0 --sourcedb D44I --targetcdb CD44I --start_time 2023-03-20_10:00:00"
  exit
}

# =================================================================================================
#
# Create User bvautoupgrade
#
# =================================================================================================

CheckCharSets() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  local SQLFILE=`mktemp -u -t ${FUNCNAME}_XXXXXXXXXX.sql`

  cat <<EOCAT >$SQLFILE
    select 'NLS_CHARACTERSET:'||value from nls_database_parameters where parameter='NLS_CHARACTERSET';
EOCAT

  # Get source charset
  logger_debug "RunRemoteSQL sys $PWDSYS $SERVICENAME $SQLFILE"
  RunRemoteSQL sys $PWDSYS $SERVICENAME $SQLFILE
  RC=$?
  logger_debug "SQLOUTPUT=$SQLOUTPUT"
  if [ "$RC" -ne 0 ]; then
    logger_error "Get charset from source failed (RC=$RC)"
    RC=10
  else
    SOURCECS="$(echo "$SQLOUTPUT"|grep 'NLS_CHARACTERSET:'|cut -d: -f2)"
    logger_debug "SOURCECS=$SOURCECS"
  fi

  if [ "$RC" -eq 0 ]; then
    # Get target charset4
    logger_debug "RunSingleSQL 'CDB$ROOT' $SQLFILE"
    RunSingleSQL 'CDB$ROOT' "$SQLFILE"
    RC=$?
    logger_debug "SQLOUTPUT=$SQLOUTPUT"
    if [ "$RC" -ne 0 ]; then
      logger_error "Get charset from target failed (RC=$RC)"
      RC=20
    else
      TARGETCS="$(echo "$SQLOUTPUT"|grep 'NLS_CHARACTERSET:'|cut -d: -f2)"
      logger_debug "TARGETCS=$TARGETCS"
    fi
  fi

  if [ "$RC" -eq 0 -a "$TARGETCS" != "AL32UTF8" -a "$SOURCECS" != "$TARGETCS" ]; then
    logger_error "Target charset '$TARGETCS' is not a superset of source charset '$SOURCECS'!"
    RC=30
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
#
# Create User bvautoupgrade
#
# =================================================================================================

CreateUserBVA() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  cat <<EOCAT >$SQLFILE
WHENEVER SQLERROR CONTINUE
BEGIN
  EXECUTE IMMEDIATE 'DROP USER BVAUTOUPGRADE';
-- EXCEPTION
--   WHEN OTHERS THEN
--     NULL;
END;
/
WHENEVER SQLERROR EXIT SQL.SQLCODE
CREATE USER bvautoupgrade identified by ${DEFAULTPWD};
GRANT create session, create pluggable database, select_catalog_role to bvautoupgrade;
GRANT read on sys.enc\$ TO bvautoupgrade;
EOCAT
  RunRemoteSQL sys $PWDSYS $SERVICENAME $SQLFILE
  RC=$?
  logger_debug "RC=$RC"
  if [ "$RC" -ne 0 ]
  then
    logger_error "Unable to create User BVAUTOUPGRADE"
    RC=10
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
#
# Create database link bvclone
#
# =================================================================================================

CreateDBlinkBVClone() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  cat <<EOCAT >$SQLFILE
WHENEVER SQLERROR CONTINUE
BEGIN
  EXECUTE IMMEDIATE 'DROP DATABASE LINK $DBLINKNAME';
--EXCEPTION
--  WHEN OTHERS THEN
--    NULL;
END;
/
WHENEVER SQLERROR EXIT SQL.SQLCODE
CREATE DATABASE LINK $DBLINKNAME
  CONNECT TO bvautoupgrade IDENTIFIED BY "$DEFAULTPWD"
  USING '${SERVICENAME}.unix.lan'
;
EOCAT
  RunSingleSQL 'CDB$ROOT' "$SQLFILE"
  RC=$?
  logger_debug "RC=$RC"
  if [ "$RC" -ne 0 ]; then
    logger_error "Unable to create Database Link $DBLINKNAME"
    RC=10
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
#
# Drop database link bvclone
#
# =================================================================================================

DropDBlinkBVClone() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  cat <<EOCAT >$SQLFILE
    BEGIN
      EXECUTE IMMEDIATE 'DROP DATABASE LINK $DBLINKNAME';
    EXCEPTION
      WHEN OTHERS THEN
        NULL;
    END;
    /
EOCAT
  RunSingleSQL 'CDB$ROOT' "$SQLFILE"
  RC=$?
  logger_debug "RC=$RC"
  if [ "$RC" -ne 0 ]; then
    logger_error "Unable to drop Database Link $DBLINKNAME"
    RC=10
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
#
# Drop User bvautoupgrade
#
# =================================================================================================

DropUserBVA() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  cat <<EOCAT >$SQLFILE
    BEGIN
      EXECUTE IMMEDIATE 'DROP USER BVAUTOUPGRADE';
    EXCEPTION
      WHEN OTHERS THEN
        NULL;
    END;
    /
EOCAT
  RunSingleSQL "$SOURCEDB" "$SQLFILE"
  RC=$?
  logger_debug "RC=$RC"
  if [ "$RC" -ne 0 ]; then
    logger_error "Unable to drop User BVAUTOUPGRADE in PDB $SOURCEDB"
    RC=10
  fi

  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
#
# CreateConfig
#
# =================================================================================================

CreateConfig() {
  logger_debug "--> Function $FUNCNAME"
  GLOBALLOGDIR=$CONFIGDIR/globallog
  LOGDIR=$CONFIGDIR/log
  mkdir -p $GLOBALLOGDIR $LOGDIR
  # Why should we schedule the copy 2 hours in advance?
  # STARTTIME="$(date --date 'today + 2 hours' "+%d/%m/%Y %H:%M:%S")"
  # STARTTIME="+2h"
  
  if [ -z "$STARTTIME" ]
  then 
    STARTTIME="now"
  else
    STARTTIME=`echo $STARTTIME |sed -s 's/_/ /'`
  fi
  PDBREFRESHINTERVAL=600    # refresh pdb every 600 seconds
  logger_debug "Starttime=$STARTTIME"
  logger_debug "PDBrefreshInterval=$PDBREFRESHINTERVAL"
#
# Cat Configfile
#
cat <<EOCAT > $CONFIGFILE
# https://docs.oracle.com/en/database/oracle/oracle-database/19/spucs/local-parameters-autoupgrade-config-file.html
# -----------------------------------
# Common parameter
# -----------------------------------
global.autoupg_log_dir=$GLOBALLOGDIR
$SOURCEDB.log_dir=$LOGDIR
# For clarification only, default=localhost
$SOURCEDB.upgrade_node=localhost
# For clarification only, default=yes, create a guaranted restore point
$SOURCEDB.restoration=yes
# Start_time can be used to schedule upgrade jobs
# - final upgrade phase after all data are copied and regular refreshed (PDBREFRESHINTERVAL)
# - final refresh + upgrade
$SOURCEDB.start_time=$STARTTIME
# Should we run recompile at the end of deploy mode?
$SOURCEDB.run_utlrp=yes
## Set COMPATIBLE db parameter to the default value of the target release after the upgrade
#upg1.raise_compatible=yes
# -----------------------------------
# Source db parameter
# -----------------------------------
$SOURCEDB.source_base=$ORACLE_BASE
$SOURCEDB.source_home=$ORACLE_HOME
$SOURCEDB.sid=$SOURCEDB
# -----------------------------------
# Target db parameter
# -----------------------------------
$SOURCEDB.target_base=$ORACLE_BASE
$SOURCEDB.target_home=$ORACLE_HOME
$SOURCEDB.target_cdb=$TARGETCDB
# target pdb name must be the same like source dbname/sid
# ? The default name for the target PDB when you convert a non-CDB to a PDB
# ? is to use the database unique name of the non-CDB Oracle Database.
# ? In addition, if you are creating a refreshable clone database, then append a suffix
# ? to the parameter that specifies either the source database name or PDB name (target_name.suffix)
$SOURCEDB.target_pdb_name.${SOURCEDB}=${TARGETPDB}
$SOURCEDB.source_dblink.${SOURCEDB}=$DBLINKNAME $PDBREFRESHINTERVAL
# Copy files and generate new OMF file names
$SOURCEDB.target_pdb_copy_option.${SOURCEDB}=file_name_convert=none
EOCAT
#
# End Cat COnfigfile
#

  if [ "$PARALLEL" -ne 0 ]; then
    PSERVER="$PARALLEL"                           # parallel used server processes
    CATCTL_UPPER_N="$PARALLEL"                     # processors used in parallel by catctl
    CATCTL_LOWER_N="$((${CATCTL_UPPERN} * 4))"     # processes used in parallel by catctl
    logger_debug "CATCTL_UPPER_N=$CATCTL_UPPER_N"
    logger_debug "CATCTL_LOWER_N=$CATCTL_LOWER_N"
#
# Added to Config File
#
    cat <<EOCAT >> $CONFIGFILE
# -----------------------------------
# Tuning parameter
# -----------------------------------
### Parallel degree
# see https://dohdatabase.com/2021/01/19/control-upgrade-parallelism-in-autoupgrade/
# see https://docs.oracle.com/en/database/oracle/oracle-database/19/upgrd/local-parameters-autoupgrade-config-file.html
#
# Number of servers that will run in parallel when creating a pluggable database
# (parallel degree for execution servers to copy the new PDB's data files)
$SOURCEDB.parallel_pdb_creation_clause.${SOURCEDB}=${PSERVER}
# -n Number of processes to use for parallel operations (total parallel degree);
#    setting -> conservative: CPU_COUNT, progressiv: CPU_COUNT+10%
# -N Number of processors to use when upgrading PDBs (pdb upgrade parallel degree)
$SOURCEDB.catctl_options=-n ${CATCTL_LOWER_N} -N ${CATCTL_UPPER_N}
#
# query_hint_parallel=X     - parallel query degree to the code that gathers data from the tablespaces
# utlrp_threads_per_pdb=X   - Overwrites default maximum number of threads generated by the recompilation of invalid objects in the CDB
# utlrp_pdb_in_parallel=X   - Overwrites default maximum number of concurrent recompilation threads
#upg1.tune_setting=query_hint_parallel=8,utlrp_threads_per_pdb=8
#upg1.tune_setting=utlrp_threads_per_pdb=$PSERVER
EOCAT
#
# Added to Config File
#
  fi
  logger_debug "<-- Function $FUNCNAME"
  return 0
}

# =================================================================================================
#
# RunAutoupgrade
#
# =================================================================================================

RunAutoupgrade() {
  logger_debug "--> Function $FUNCNAME"
  local RC=0
  CONFIGDIR=$ORABASEDIR/admin/log/autoupgrade_$SOURCEDB
  CONFIGFILE=$CONFIGDIR/autoupgrade_${SOURCEDB}.cfg
  GBLSTATUSLOG="$CONFIGDIR/globallog/cfgtoollogs/upgrade/auto/status/status.log"
  mkdir -p $CONFIGDIR
  CreateConfig
  logger_debug "CONFIGFILE=$CONFIGFILE"
  cat $CONFIGFILE | logger_debug
  if [ ! -r $CONFIGFILE ]; 
  then
    logger_error "Unable to create Configfile $CONFIGFILE"
    RC=10
  else
    CMD="$ORACLE_HOME/jdk/bin/java -jar $UPGRADEDIR/autoupgrade.jar -mode deploy -config $CONFIGFILE -noconsole $CLEANUP_OPTION"
    logger_debug "$CMD"
    logger_debug "Start autoupgrade process .."
    logger_info "Check autoupgrade status log: $GBLSTATUSLOG"
    logger_info "Check database log: $DBLOG"

    $CMD 2>&1 | tee >(logger_debug)
    RC=$?
    if [ "$RC" -ne 0 ] 
    then
      logger_debug "Autoupgrade process failed (RC=$RC)"
    fi
    logger_debug "Autoupgrade process succeeded"
  fi
  logger_debug "<-- Function $FUNCNAME (RC=$RC)"
  return $RC
}

# =================================================================================================
#
# RunAutoupgradePostProc
#
# =================================================================================================

RunAutoupgradePostProc() {
logger_debug "--> Function $FUNCNAME"
local RC=0
cat <<EOCAT >$SQLFILE
-- enable automatic pdb open read write
alter pluggable database ${TARGETPDB} save state;

/* fix some entries in PDB_PLUG_IN_VIOLATIONS */
alter session set container=${TARGETPDB};
-- fix old pending violations in PDB_PLUG_IN_VIOLATIONS
exec DBMS_PDB.SYNC_PDB;
-- remove resolved violations from PDB_PLUG_IN_VIOLATIONS
exec DBMS_PDB.CLEAR_PLUGIN_VIOLATIONS;
commit;
EOCAT
RunSingleSQL 'CDB$ROOT' "$SQLFILE"
RC=$?
logger_debug "RC=$RC"
if [ "$RC" -ne 0 ]; then
logger_error "Error in RunAutoupgradePostProc SQLs"
RC=10
fi

logger_debug "<-- Function $FUNCNAME (RC=$RC)"
return $RC
}

# =================================================================================================
#
# Read Script Options (getopt)
#
# Define Options
#
#  SHORT --> short option (e.g. -d)
#  LONG --> long option (e.g. --database)
#  : means that a second argument is required
#
# Return Values
#   0 : Successful
#  10 : Unsuccessful
#  11 : Invalid Argument
#
# =================================================================================================

ReadOptions() {
logger_debug "--> Function $FUNCNAME"
if [ $# -eq 0 ]; then
logger_fatal "Arguments required"
return 10
fi
SHORT="h"
LONG="help,sourcedb:,targetcdb:,targetpdb:,parallel:,clear,skip:,start_time:"
logger_debug "LONG=$LONG"
logger_debug "Arguments=$*"
OPTIONS=$(getopt --options $SHORT --long $LONG --name "$0" -- "$@" 2>/dev/null)
RC=$?
logger_debug "OPTIONS=$OPTIONS"
if [ "$RC" -ne 0 ]; then
logger_fatal "Invalid Arguments"
return 11
fi

CLEANUP="false"
CLEANUP_OPTION=""
PARALLEL=0
unset STARTTIME
eval set -- $OPTIONS
while true
do
case $1 in
-h|--help)    usage
	    shift;;
--sourcedb)   SOURCEDB="$2"
	    logger_debug "SOURCEDB=$SOURCEDB"
	    shift 2;;
--targetcdb)  TARGETCDB="$2"
	    logger_debug "TARGETCDB=$TARGETCDB"
	    shift 2;;
--clear)      CLEANUP="true"
	    CLEANUP_OPTION="-clear_recovery_data"
	    logger_debug "CLEANUP=$CLEANUP"
	    shift;;
--targetpdb)  TARGETPDB="$2"
	    logger_debug "TARGETPDB=$TARGETPDB"
	    shift 2;;
--parallel)   PARALLEL="$2"
	    logger_debug "PARALLEL=$PARALLEL"
	    shift 2;;
--start_time)  STARTTIME="$2"
	    logger_debug "STARTTIME=$STARTTIME"
	    shift 2;;
--skip)       SKIP="$(echo $2 | tr -d ' ' | tr 'A-Z' 'a-z')"
	    logger_debug "SKIP=$SKIP"
	    shift 2;;
--)           shift;break;;
*)            logger_error "Unknown parameter '$1'"
	    usage;;
esac
done
logger_debug "<-- Function $FUNCNAME"
return 0
}

# =================================================================================================
# Main
# =================================================================================================

logger_info "CLEANUP=$CLEANUP"
if [ $# -ne 0 ] 
then
ReadOptions $*
RC=$?
if [ $RC -ne 0 ] 
then
usage
elif [ -n "$HELP" ]
then
usage
fi
else
usage
fi

# ------------------------------------------------
# Do some initial checks
# ------------------------------------------------

# Check DBNAME for source
if [ -z "$SOURCEDB" ]; then
logger_error "No Source Database specified"
usage
exit 11
fi
SOURCEDB=$(echo "$SOURCEDB"|tr '[:lower:]' '[:upper:]')
logger_debug "SOURCEDB=$SOURCEDB"

# Check DBNAME for target
if [ -z "$TARGETCDB" ]; then
logger_error "No Target Database specified"
usage
exit 12
fi
TARGETCDB=$(echo "$TARGETCDB"|tr '[:lower:]' '[:upper:]')
logger_debug "TARGETCDB=$TARGETCDB"

# Check PDBNAME for target
if [ -z "$TARGETPDB" ]; then
# Default: SOURCEDB without last charcter (stage)
TARGETPDB="$(echo $SOURCEDB |rev|cut -c2-|rev)"
fi
TARGETPDB="$(echo "$TARGETPDB"|tr '[:lower:]' '[:upper:]')"
logger_debug "TARGETPDB=$TARGETPDB"

[ ! "$CLEANUP" ] || logger_info "Cleanup from previous autoupgrade execution specified."

# ------------------------------------------------
# Prepare for clone of source NonCDB to target CDB
# ------------------------------------------------

# Re-Init log4sh with CDB specific logfile name
logger_debug "Re-Init Logger using `basename $0|cut -d. -f1`${TARGETCDB/#/_}${TARGETPDB/#/_}-{type}-{date}.log"
Logger "${TARGETCDB/#/_}${TARGETPDB/#/_}" 1

# Check availability of target (CDB) instance
logger_info "Check availability of target .."
InstanceUp "$TARGETCDB"
RC=$?
if [ "$RC" -ne 0 ]; then
logger_error "Instance $TARGETCDB is not in a correct state"
exit 21
fi

# Check availability of source (NonCDB) instance
logger_info "Check availability of source .."
GetTnsServicename "$SOURCEDB"
[ "$RC" -eq 0 ] || exit 22

source $PWDDIR/.pwdfile_db_sys
RemoteInstanceState "$SERVICENAME"
[ "$RC" -eq 0 ] || exit 23

# Check source and target charset
#logger_info "Check database character sets .."
# Not necessary as both are set up with CMDB Infos for required Character Set
CheckCharSets
[ "$RC" -eq 0 ] || exit 24

# Check if this is an Autoupgrade rerun
  CONFIGDIR=$ORABASEDIR/admin/log/autoupgrade_$SOURCEDB
  CONFIGFILE=$CONFIGDIR/autoupgrade_${SOURCEDB}.cfg
  GBLSTATUSLOG="$CONFIGDIR/globallog/cfgtoollogs/upgrade/auto/status/status.log"
  if [ ! -r "$GBLSTATUSLOG" ]
  then
# Check available filesystem space for data and fra
    if [ $(IsElementInList "fs" "$SKIP"; echo $?) -eq 0 ]; then
      logger_info "Skip filesystem check!"
    else
# Check available filesystem space for data
      logger_info "Check free space in DATA filesystem .."
      GetDBsize
      [ $? -eq 0 ] || exit 31
      logger_debug "DBSIZEMB=$DBSIZEMB"
      CheckDBFilesystem "$DATAFILEDEST" "$DBSIZEMB"
      [ $? -eq 0 ] || exit 32
  
# Check available filesystem space for fra
      logger_info "Check free space in FRA filesystem .."
      GetFRAsize
      [ $? -eq 0 ] || exit 33
      logger_debug "FRASIZEMB=$FRASIZEMB"
      CheckDBFilesystem "$FRAFILEDEST" "$FRASIZEMB"
      [ $? -eq 0 ] || exit 34
    fi

# Create db user BVAUTOUPGRADE on target cdb
    logger_info "Create db user BVAUTOUPGRADE on target .."
    CreateUserBVA
    [ $? -eq 0 ] || exit 41

# Create db link BVDBCLONE on target cdb
    logger_info "Create db link $DBLINKNAME on target .."
    CreateDBlinkBVClone
    [ $? -eq 0 ] || exit 42

# ------------------------------------------------
# Clone source NonCDB as PDB to target CDB
# ------------------------------------------------

# Some requirements for Autoupgrade from Non-CDB to CDB
# see https://docs.oracle.com/en/database/oracle/oracle-database/23/upgrd/understanding-non-cdb-to-pdb-upgrades-autoupgrade.html#GUID-D739E4A4-F1B9-45BE-B0E2-F213FE70F665
# - The target CDB must be created in advance of performing the upgrade with AutoUpgrade.
# - The PDB created from the non-CDB must continue to use the source non-CDB name. You cannot change the name of the database.
# - The set of Oracle Database options must be same or superset of source db
# - The endian format must be same on source and target host
# - The source non-CDB and target CDB have compatible character sets and national character sets.
# - The source non-CDB Oracle Database release and operating system platform must be supported for direct upgrade to the target CDB release.
# - Operating system authentication is enabled for the source non-CDB and target CDB.

# Run autoupgrade
  else
    logger_info "Autoupgrade Rerun"
  fi
logger_info "Run autoupgrade to clone source to target .."
RunAutoupgrade
RC=$?
if [ "$RC" -ne 0 ]; then
  exit 51
fi
RunAutoupgradePostProc
[ $? -eq 0 ] || exit 52

logger_info "Ready!"
exit 0
