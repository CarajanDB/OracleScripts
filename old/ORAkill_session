#!/bin/bash
# @(#) ================================================================================================================
# @(#)  File        : ORAkill_session
# @(#)  Author      : Thorsten Thiel
# @(#)  Modified    : 
# @(#)
# @(#)  Description : This script kills oracle sessions of a certain username.
# @(#)                It needs an USERNAME and SID parameter
# @(#)
# @(#)  Version     : 1.3
# @(#)  Date        : 25.01.2018
# @(#)
# @(#)  Attention   : This script must be started as user ORACLE
# @(#)
# @@(#)  Change History:
# @@(#)
# @@(#)    1.0  2016-03-22  Thiel	Created
# @@(#)    1.1  2017-08-01  Ahrends	Option -f
# @@(#)    1.2  2017-09-13  Thiel       changed function cr_kill_sess_sql
# @@(#)    1.3  2018-01-25  Pils        changed pwddir location
# @(#)-----------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------
# read the options and define possible arguments
#-----------------------------------------------------------------------------------------------------------------
PARSED_OPTIONS=`getopt -o i::hlfu: --long inst::,help,list,force,user: -n '$0' -- "$@"`
#echo "PARSED_OPTIONS: $PARSED_OPTIONS#"
eval set -- "$PARSED_OPTIONS"

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Help routine
#-----------------------------------------------------------------------------------------------------------------
function usage()
{
if [ $HELP -eq 0 ]
then
   if [ $RC -eq 0 ]
   then
      RC=1
   fi
fi
echo ""
echo "  Command     : $SCRIPTNAME [-h|--help] [-l|--list] [-f|--force] -u|[--user=]'SCHEMANAME' -i|[--inst=]'ORACLE_SID' "
echo "  Description : $SCRIPTSHORTDESC"
echo ""
echo "  Parameters  : -u|--user,               define schema name"
echo "                -i|--inst,               define comma separated list of ORACLE_SIDs"
echo "                -l|--list,               do not kill just list generated kill session commands"
echo "                -f|--force,              kill session immediate (no input required"
echo "                -h|--help                help screen"
echo ""
echo "  Example     : ${SCRIPTNAME} -l -u'DBSNMP' -i'dmsi,orai'"
echo ""
echo "  Attention   : This script must be started as user ORACLE"
echo ""
exit $RC
}

#-----------------------------------------------------------------------
# Logger Script
#-----------------------------------------------------------------------
logger() {
if [ -r $SCRIPTDIR/log4sh ]
then
   LOCALLOGGER="`basename $0 | cut -d"." -f 1`_log4sh.properties"
   if [ -r $SCRIPTDIR/${LOCALLOGGER} ]
   then
      LOG4SH_CONFIGURATION=$SCRIPTDIR/$LOCALLOGGER . $SCRIPTDIR/log4sh
   else
      LOG4SH_CONFIGURATION=$SCRIPTDIR/log4sh.properties . $SCRIPTDIR/log4sh
   fi
else
   echo "ERROR: could not load (log4sh)" >&2
   exit 1
fi
#  echo "LOG4SH_CONFIGURATION:$LOG4SH_CONFIGURATION"
}

#-----------------------------------------------------------------------
# write log header
#-----------------------------------------------------------------------
log_header()
{
logger_info "-----------------------------------------------------------------------"
logger_info "ORAkill_session started"
}

#-----------------------------------------------------------------------
# write log footer
#-----------------------------------------------------------------------
log_footer()
{
logger_info "ORAkill_session ended"
logger_info "-----------------------------------------------------------------------"
}

#-----------------------------------------------------------------------
# Read password from hidden file
#-----------------------------------------------------------------------
readPWD() {
   logger_debug "SYS Password"
   if [ -f $PWDDIR/.pwdfile_db_sys ]
   then
      typeset -l ORACLE_SID_LC=$PRIMARYDB
      source $PWDDIR/.pwdfile_db_sys
      logger_debug "Password = ${PWDSYS}"
   else
      logger_error "No Passwordfile"
      exit 10
   fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Get SID Environment
#-----------------------------------------------------------------------------------------------------------------
function get_sid_env() 
{
  OH=`grep "^${INST}:" ${ORATAB}` 
  if [ $? -ne 0 ]; then
     Bmsg -rl $LOGFILE -m "> ORACLE_SID: ${INST} not in ${ORATAB}"
     echo "${SCRIPTNAME} - ${HOST}: ORACLE_SID ${INST} not in ${ORATAB}" |mail -s "${SCRIPTNAME}" $MAILTO
     Bmsg -rl $LOGFILE -m "> A mail message was send to ${MAILTO}." 
     Bmsg -sl $LOGFILE -m "#  ${SCRIPTNAME} - script end"
     exit 255
  fi
  ORACLE_SID=${INST}
  ORACLE_SID_LC=`echo $ORACLE_SID|tr 'A-Z' 'a-z'`
  ORACLE_HOME=`echo ${OH}|cut -d: -f2`
  RMAN="${ORACLE_HOME}/bin/rman"
  RTAB=`grep "^${INST}:" ${RMANTAB}`
  if [ $? -ne 0 ]; then
     Bmsg -rl $LOGFILE -m "> ORACLE_SID: ${INST} not in ${RMANTAB}"
     echo "ORACLE_SID: ${INST} not in ${RMANTAB}" |mail -s "${SCRIPTNAME}" $MAILTO
     Bmsg -rl $LOGFILE -m "> A mail message was send to ${MAILTO}." 
     Bmsg -sl $LOGFILE -m "#  ${SCRIPTNAME} - script end"
     exit 255
  fi
  BACKUPTYPE=`echo "${RTAB}"|cut -d: -f2`
  RMANCAT=`echo "${RTAB}"|cut -d: -f3`
  RMANUSER=`echo "${RTAB}"|cut -d: -f4`
  if [ -s $PWDDIR/.pwdfile_db_sys ]
  then
     source $PWDDIR/.pwdfile_db_sys
  else
     PWDSYS="Sys${ORACLE_SID_LC}56"
  fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Check if DB is open
#-----------------------------------------------------------------------------------------------------------------
function get_db_values()
{
  Bmsg -1m "${SCRIPTNAME} - Get values from database"
  export ORACLE_HOME=${ORACLE_HOME}
  export ORACLE_SID=${ORACLE_SID}
  ${ORACLE_HOME}/bin/sqlplus -s /nolog <<EOSQL
  connect / as sysdba
  set serverout on size unlimited feedback off
  whenever sqlerror exit sql.sqlcode
  spool $TMPSQLOUT
  declare
    l_primary_mode   pls_integer  := 0;
    l_db_name        varchar2(20) := '';
    l_db_unique_name varchar2(20) := '';
    l_dg_broker      pls_integer  := 0;
  begin
    select case DATABASE_ROLE when 'PRIMARY' then 1 else 0 end,
           NAME,
           DB_UNIQUE_NAME,
           case DATAGUARD_BROKER when 'ENABLED' then 1 else 0 end
      into l_primary_mode,l_db_name,l_db_unique_name,l_dg_broker
      from v\$database;
    dbms_output.put_line('export IS_PRIMARY='||l_primary_mode);
    dbms_output.put_line('export DBNAME='||l_db_name);
    dbms_output.put_line('export DBUNAME='||l_db_unique_name);
    dbms_output.put_line('export DGUARD='||l_dg_broker);
  end;
/
EOSQL
  RC=$?
  if [ "$RC" -eq 0 ]; then
    source $TMPSQLOUT
  fi
  rm $TMPSQLOUT
  return $RC
}

#-----------------------------------------------------------------------------------------------------------------
# chk_ora_err
#-----------------------------------------------------------------------------------------------------------------
chk_ora_err ()
{
OERR=`grep "ORA-" $SQLRESULT`

if [ "$OERR" != "" ]
then
   RC=1
fi
}

#-----------------------------------------------------------------------------------------------------------------
# get_used
#-----------------------------------------------------------------------------------------------------------------
get_used ()
{
# Ermittelt die Summe der noch nicht gesicherten ARCHIVELOGS
# ---------------------------------------------------------------------------
MESSAGE="The count of archivelogs not backed up could not be determined!"
SQLRESULT=/tmp/result_sql1.lst
${ORACLE_HOME}/bin/sqlplus -s /nolog <<EOSQL1 >/dev/null
connect / as sysdba
set termout off;
set feed off;
set hea off;
spool $SQLRESULT;
select count(*)
from V\$archived_log
where BACKUP_COUNT = 0
and status='A'
and standby_dest='NO';
EOSQL1

chk_ora_err
if [ $RC -eq 1 ]
then
   Bmsg -sl $RMANLOGFILE -m "$MESSAGE"
   exit 1
fi

ARCCOUNT=`cat $SQLRESULT|tail -1|sed s/' '//g`
rm $SQLRESULT 2>/dev/null
if [ $ARCCOUNT -eq 0 ]
then
   USED=0
#  echo "USED1: $USED#" >>$LOG
else
   MESSAGE="The amount of archivelogs not backed up could not be determined!"
   SQLRESULT=/tmp/result_sql2.lst
${ORACLE_HOME}/bin/sqlplus -s /nolog <<EOSQL1 >/dev/null
connect / as sysdba
set termout off;
set feed off;
set hea off;
spool $SQLRESULT;
select case (round((sum(blocks*block_size)/1024/1024),0)) when NULL then 0 else (round((sum(blocks*block_size)/1024/1024),0)) end  as MB
from V\$archived_log
where BACKUP_COUNT = 0
and status='A'
and standby_dest='NO';
EOSQL1

   chk_ora_err
   if [ $RC -eq 0 ]
   then
      USED=`cat $SQLRESULT|tail -1|sed s/' '//g`
   else
      Bmsg -rl $RMANLOGFILE -m "$MESSAGE"
      exit 1
   fi
#  echo "USED2: $USED#" >>$LOG
   rm $SQLRESULT 2>/dev/null
fi
}
#THI 21.12.2015

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: check_instance
#-----------------------------------------------------------------------------------------------------------------
check_instance()
{
SMON=`ps -ef|grep -i smon|grep ${INST}|tail -1|awk '{print $NF}'`
if [ ! "$SMON" == "ora_smon_${INST}" ] # SMON nicht gefunden; Instanz laeuft nicht
then
   grep ${INST} /app/oracle/inst_int_down >/dev/null 2>&1
   if [ $? -eq 0 ] # Instanz absichtlich aus
   then
      Bmsg -gm "Die Instanz ${INST} laeuft nicht!"
      Bmsg -gm "Die Instanz ist absichtlich aus!"
      logger_info "Die Instanz ${INST} laeuft nicht!"
      logger_info "Die Instanz ist absichtlich aus!"
      return 1
   else
      Bmsg -rm "ERR: Die Instanz ${INST} laeuft nicht!"
      logger_info "Die Instanz ${INST} laeuft nicht!"
      return 1
   fi
fi
return 0
}

#-----------------------------------------------------------------------------------------------------------------
# cr_kill_sess_sql
#-----------------------------------------------------------------------------------------------------------------
cr_kill_sess_sql()
{
. dbset $INST >/dev/null 2>&1
#usertest|grep $USERNAME|sort -k8|awk '{printf "alter system kill session '%s,%s' immediate;\n",$5,$6}' >kill_${USERNAME}_sess.sql 2>&1
usertest|awk '{if($2=="'$USERNAME'"){print $0}}'|sort -k8|awk '{printf "alter system kill session '%s,%s' immediate;\n",$5,$6}' >kill_${USERNAME}_sess.sql 2>&1
cat kill_${USERNAME}_sess.sql| sed s/"ion "/"ion \'"/ >/tmp/kill_${USERNAME}_sess.sql
cat /tmp/kill_${USERNAME}_sess.sql | sed s/" immediate;"/"\' immediate;"/ >kill_${USERNAME}_sess.sql
echo
Bmsg -bm "Liste der generierten KILL-Kommandos"
Bmsg -bm "------------------------------------"
cat kill_${USERNAME}_sess.sql
}

#-----------------------------------------------------------------------------------------------------------------
# run_kill_sess_sql
#-----------------------------------------------------------------------------------------------------------------
run_kill_sess_sql()
{
if [ $FORCE -eq 0 ]
then
   echo "weiter? (Weiter mit ENTER und abbrechen mit CTRL-C)"
   read o
fi
rm /tmp/kill_${USERNAME}_sess.sql
echo "exit;" >>kill_${USERNAME}_sess.sql
MESSAGE="Kill sessions for USER $USERNAME in $INST instance"
SQLRESULT="/tmp/sqlresult1.sql"
sqlplus -s / as sysdba <<EOSQL1
spool $SQLRESULT
@kill_${USERNAME}_sess
EOSQL1

chk_ora_err
if [ $RC -eq 1 ]
then
   Bmsg -rm "$MESSAGE ran into errors!"
else
   Bmsg -gm "$MESSAGE was successfull!"
fi

rm kill_${USERNAME}_sess.sql
}

#-----------------------------------------------------------------------------------------------------------------
#     Global script environment
#-----------------------------------------------------------------------------------------------------------------
set +x                        #to hide script execution content like passwords from sysoutput
MAILTO="unix-dba@barmenia.de"
HOST=`hostname -s`
#LONGHOST=`hostname -f`
SCRIPTNAME=$(basename $0)
SCRIPTSHORTDESC="kill sessions of defined users"
ORACLE_BASE="/app/oracle"
STARTDATE=`date +"%Y-%m-%d"`
SCRIPTDIR="/app/oracle/bin"
PWDDIR="/app/oracle/admin/etc/pwddir"

source /app/oracle/bin/.bash_functions
RC=$?
if [ $RC -ne 0 ]; then
 echo ".bash_functions file not found!"
 exit $RC
fi

#-----------------------------------------------------------------------------------------------------------------
#     begin logging
#-----------------------------------------------------------------------------------------------------------------
logger
log_header

#-----------------------------------------------------------------------------------------------------------------
#     Get Opts
#-----------------------------------------------------------------------------------------------------------------
USER=0
INSTANCE=0
LSSESS=0
HELP=0
FORCE=0

while true ; do
   case "$1" in
      -i|--inst) case "$2" in
                   "") ORACLE_SID_LIST=$ORACLE_SID
                       INSTANCE=1
                       shift 2
                       ;;
                    *) INSTLIST=$2
                       ORACLE_SID_LIST=`echo $INSTLIST| sed 's/,/ /g'`
                       INSTANCE=1
                       shift 2
                       ;;
                 esac
                 ;;
      -u|--user) USERNAME=`echo $2|tr [a-z] [A-Z]`
                 USER=1
                 shift 2
                 ;;
      -l|--list) LSSESS=1
                 shift
                 ;;
      -f|--force) FORCE=1
                 shift
                 ;;
      --) shift
          break
          ;;
      -h|--help) HELP=1
                 usage
                 ;;
      *) usage
         ;;
   esac
done

#echo "ORACLE_SID_LIST: $ORACLE_SID_LIST#"
#echo "USERNAME: $USERNAME#"
#echo "LISTING: $LSSESS#"
#echo "FORCE: $FORCE#"
#echo "HELP: $HELP#"

#-----------------------------------------------------------------------------------------------------------------
#     Check if user is oracle, otherwise abort
#-----------------------------------------------------------------------------------------------------------------
if [ `id -un` != "oracle" ]; then
  Bmsg -rm "Script may not run as user `id -un`, it must be started and run as oracle"
  logger_fatal "Script may not run as user `id -un`, it must be started and run as oracle"
  RC=255
  Bmsg -rm "Error Code: ${RC}"
  log_footer
  exit $RC
fi

#-----------------------------------------------------------------------------------------------------------------
#     Sanity check
#-----------------------------------------------------------------------------------------------------------------
SUMOPT=`expr $USER + $INSTANCE`
if [ $SUMOPT -ne 2 ]; then
  echo
  Bmsg -rm "Ein Parameter USER (-u) und INSTance (-i) MUSS angegeben werden!"
  logger_fatal "Ein Parameter USER (-u) und INSTance (-i) MUSS angegeben werden!"
  RC=255
  Bmsg -rm "Error Code: ${RC}"
  log_footer
  usage
fi

#-----------------------------------------------------------------------------------------------------------------
#     Main program - start
#-----------------------------------------------------------------------------------------------------------------
##### do action for every SID #####
for INST in $ORACLE_SID_LIST
do
  Bmsg -bm "Instanz: $INST"
  check_instance
  if [ "$?" -eq 1 ] # Instanz laeuft nicht
  then
     continue #naechste Instanz aus $ORACLE_SID_LIST
  fi
  cr_kill_sess_sql
  if [ $LSSESS -eq 0 ]
  then
     run_kill_sess_sql
  fi
done

#-----------------------------------------------------------------------------------------------------------------
#     Main program - end
#-----------------------------------------------------------------------------------------------------------------
log_footer
exit $SCRIPTRC

