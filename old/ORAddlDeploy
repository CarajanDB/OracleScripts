# @(#) ================================================================================================================
# @(#) File        : ORAddlDeploy
# @(#) Author      : Dieter Smets
# @(#) Modified    :
# @(#)
# @(#) Description : This script does run all Files in given Directory by SQL/Plus as described here:
# @(#)               Description:   http://lxwiki.unix.lan/wiki_root/dokuwiki/dokumentationen/doku.php?id=datenbanken:oracle:oraddldeploy
# @(#)                              http://wsv-muv.unix.lan/mediawiki/index.php/DDL_Deploy
# @(#)
# @(#) Version     : 1.18
# @(#) Datum       : 09.04.2024
# @(#)
# @(#) Presumption :
# @(#)
# @@(#)  Change History:
# @@(#)
# @@(#)  1.0  2017-10-20  Smets       Created
# @@(#)  1.1  2018-01-09  Smets       Support of Stages EDMZ and PDMZ
# @@(#)  1.2  2018-01-15  Smets       Erweiterung SYSOUT-/RCLIST-Temp-Filename um Application Shortcut
# @@(#)  1.2  2018-01-15  Smets       Logger aktualisiert, Anmeldung mit AD User implementiert, ReportSafe
# @@(#)  1.3  2018-02-08  Smets       Postproc SET Anweisungen ergaenzt, Versionierungs-Log angepasst (Sammeln mehrerer ReleaseCandidates).
# @@(#)  1.3  2018-02-09  Smets       Versionierungs-Log angepasst (Fehlerkorrektur).
# @@(#)  1.4  2018-02-09  Smets       Zusaetzliches Logging der Skript Messages ins DDL-Log Verzeichnis.
# @@(#)  1.5  2018-02-28  Bialas      1. Remove Tmp-Files on Exit; 2. new Option -ctm/--controlm added
# @@(#)  1.6  2018-09-26  Smets       -crp Option ergaenzt: CREATE RESTORE POINT to support fast Fallback scenario.
# @@(#)  1.7  2018-10-12  Smets       Korrigiert: Berechnung Skript-Elapsed-Zeiten.
# @@(#)  1.8  2018-10-26  Smets       ELAPSED_TIME_ALL in spezieller Release-Tabelle speichern.
# @@(#)  1.9  2018-11-05  Smets       Speicherung von ELAPSED_TIME_ALL nur wenn > 1 Min.
# @@(#)                               P-STAGE Pruefung erweitert auf PDMZ .
# @@(#)  1.10 2019-02-07  Smets       Schreiben des DDLDEPLOY_RUNLOG auch nach fehlerhafter Ausfuehrung.
# @@(#)  1.11 2019-10-16  Smets       Aenderung Password Location fuer BVBTCUSR auf /app/oracle/admin/etc/pwddir
# @@(#)  1.12 2020-04-01  Truschka    Fileausfuehrung in spezieller Protokoll-Tabelle speichern
# @@(#)  1.13 2020-09-01  MPils       added set suffix '' to enable sql scripts without file extention
# @@(#)  1.14 2020-12-17  Danowski    Added optional value to -crp option (set to /[0-9]{1-2}[hd]/).
# @@(#)                               This value defines a custom lifespan for the restorpoint that's being created.
# @@(#)  1.15 2021-01-04  Smets       chgrp to oinstall for LOG-Files in usage Function.
# @@(#)  1.16 2021-05-06  Smets       Korrektur der MSG fÃ¼r die -crp Option.
# @@(#)  1.17 2023-02-01  Smets       Print (cat) SYSOUT when -ctm Option has been set.
# @@(#)  1.18 2024-04-09  MPils       Added "" for Oracle Password
# @(#) ================================================================================================================
set +x
#-----------------------------------------------------------------------------------------------------------------
#     Global script environment
#-----------------------------------------------------------------------------------------------------------------
PRINTOUT=0   # wird evtl. spueter mal als optionaler Parameter implementiert ???
CTMRUN=0     #
SCRIPTNAME=$(basename $0)
SCRIPTDIR=/app/oracle/bin
SCRIPTSHORTDESC="This script does run all Files in given Directory by SQL/Plus as descriebed here:

                             http://lxwiki.unix.lan/wiki_root/dokuwiki/dokumentationen/doku.php?id=datenbanken:oracle:oraddldeploy
"
PWDDIR=/app/oracle/admin/etc/pwddir
FILETS=`date +%Y%m%d_%H%M%S`
DDL_DEPLOY_SYSOUT=/app/oracle/admin/log
#SYSOUT=${DDL_DEPLOY_SYSOUT}/${SCRIPTNAME}-SYSOUT-${FILETS}.log
#echo ${SYSOUT}
DDL_POSTPROC_DIR=/oranfs/share/ora_admin/DDLdeploy_postproc

#-----------------------------------------------------------------------
# Logger Script
#-----------------------------------------------------------------------
#
source /app/oracle/bin/ORAlib
Logger

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Help routine
#-----------------------------------------------------------------------------------------------------------------
function usage()
{
if [ $help -eq 1 ]
then
   RC=0
else
   RC=1
fi

echo ""
echo "  Command     : $SCRIPTNAME $DB_OS OID $S_OS SCHEMA $I_OS INPUTDIR [$V_OS DBVERSION] [$FP_OS FILEPREF] [$X_OS] [$CRP_OS] [$NP_OS] [$NODDL_OS]"
echo "  Description : $SCRIPTSHORTDESC"
echo ""
echo "  Parameters  : $DB_OPT,        Oracle TNS Service Name"
echo "                $S_OPT,          Schema Name"
echo "                $I_OPT,           Input Directory with DDL Files to execute"
echo "                $V_OPT,       Optional Do DB-Version Setting (XXX.m.n), DEFAULT: suppress DB-Version Setting"
echo "                $FP_OPT,       Optional File Prefix to execute, DEFAULT = rc"
echo "                $X_OPT,           Optional Execute SchemaSave (DataPumpExport incl. Metatdata) before DDL executions"
echo "                $CRP_OPT,  Optional Create guaranteed Restore Point before DDL executions. Add lifespan in the format xxh (hours) or xxd (days)"
echo "                $H_OPT,                help screen"
echo ""
echo "                Parameters for very special Executions different from Standard:"
echo ""
echo "                $NP_OPT,     Optional Suppress Post-Processing, DEFAULT: Execute Post-Processing"
echo "                $NODDL_OPT,   Optional Suppress DDL-Processing, DEFAULT: Execute DDL-Processing"
echo "                                        This Option enables separate processing of Post-processing and/or DB-Versioning"
echo "                $CTM_OPT,      Optional Run Skript in Control-M Mode"
echo "                                        Use this Option to execute Script by a parent Script via Control-M. E.g. Refresh 2I Process. "
echo ""
echo "  Example     : Run complete DDL Package of Version 5.88 of PSH Project for the F-Stage and build Release Table entry:"
echo "                ${SCRIPTNAME} $DB_OS psh-f $S_OS bvpshadm $I_OS /oranfs/share/ora_admin/DDL/V5.88 $V_OS psh.5.88"
echo ""
echo "                Run all DDL Files prefixed by 'rc2_psh' of Version 5.88 of PSH Project for the F-Stage:"
echo "                ${SCRIPTNAME} $DB_OS psh-f $S_OS bvpshadm $I_OS /oranfs/share/ora_admin/DDL/V5.88 $V_OS psh.5.88 $FP_OS rc2_psh"
echo ""
echo ""

# Change Ownership of Log-Files to "oinstall":
for LOGFILES in `find ${DDL_DEPLOY_SYSOUT} -name "${SCRIPTNAME}*" -user "$USER" -group barmstaf`
do
chgrp oinstall $LOGFILES
done

remove_tmpfiles

exit $RC
}
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Detect File Encoding
#-----------------------------------------------------------------------------------------------------------------
function det_sql_file_encoding
{
#set -x
if [ $(hostname -s) = 'lx0wj' ]
then
   ENCODING=`file -bi $FILENAME|awk -F= '{print $2}'`
else
   ENCODING=`uchardet $FILENAME`
fi
ENCODING=$( echo "$ENCODING" | tr '[:lower:]' '[:upper:]' )

if [ "$ENCODING" != 'UTF-8' ]
then
   NLS_LANG_VAR=AMERICAN_AMERICA.WE8MSWIN1252
else
   NLS_LANG_VAR=AMERICAN_AMERICA.UTF8
fi
NLS_LANG=${NLS_LANG_VAR}
export NLS_LANG
#echo "("`date +%Y%m%d_%H%M%S`")   File:   ${FILENAME}   -   NLS_LANG set to: ${NLS_LANG_VAR}"
MESSAGE="File:   ${FILENAME}   -   NLS_LANG set to: ${NLS_LANG_VAR}"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Check if Script is started by Control-M
#-----------------------------------------------------------------------------------------------------------------
function check_if_started_by_ctm
{

#check if CTMRUN already set by -ctm|--controlm param, default is 0
if [ $CTMRUN -eq 0 ]
then

  #set -x
  PSOUT=`ps -ef|grep ${PPID}|awk -v ppid=$PPID '{if($2==ppid){print $0}}'`
  CTMRUN=0
  #echo $PSOUT
  echo $PSOUT|grep -e 'ctms-' -e 'ctm_ag'  >/dev/null 2>&1
  if [ $? -eq 0 ]
  then
    CTMRUN=1
  fi
   #if [ $CTMRUN -eq 1 ]
   #then
   #   echo "von Control-M gestartet"
   #else
   #   echo "manuell gestartet"
   #fi
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Get User/Password depending on Run-Environment (Control-M or Foreground)
#-----------------------------------------------------------------------------------------------------------------
function get_user_and_pwd
{
if [ $CTMRUN -eq 1 ]
then
   set +x     # suppress PWD listing
   # Get Password from PasswordFile:
   DBAUSER=BVBTCUSR
   source $PWDDIR/.pwdfile_db_bvbtcusr
   DBAPASS=${PWDBVBTCUSR}
else
   TIMEOUT=30
   if [ $USER == "oracle" ]
   then
#     logger_error "*************************************************************"
     logger_error "* Scipt has been started by User oracle. Not allowed!"
#     logger_error "* Start Script by your AD Account!"
#     RC=1
#     logger_error "* RC=$RC"
#     logger_error "*************************************************************"
#     exit ${RC}
      echo "Enter your AD Account: "; read -t $TIMEOUT DBAUSER
    else
      DBAUSER=$USER
    fi
    echo "Enter ${DBAUSER}'s Password within $TIMEOUT seconds: "; stty -echo; read -t $TIMEOUT DBAPASS; stty echo
fi
# Check Password and build ReportSave TITLE:
sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@${DBNAME}
select 'DDL Deploy ${DBVER_APPL}.${DBVER_MAJOR}.${DBVER_MINOR}@${DBNAME}' from dual ;
quit;
EOT
RC1=$?
grep -Ec "ORA-[0-9][0-9][0-9][0-9][0-9]" ${SYSOUT} >/dev/null 2>&1
if [ $? -eq 0 ] || [ ${RC1} -gt 0 ]
   then
     logger_error "* Fehler bei SQL-Plus Ausfuehrung!"
     cat ${SYSOUT}
     RC=1
     logger_error "* RC=$RC"
     remove_tmpfiles
     exit ${RC}
fi
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Execute Datapump Export
#-----------------------------------------------------------------------------------------------------------------
function execute_datapump_export
{
START_TIME_SCRIPT=$(date +%s);

RC4=0
if [ "x" == "x$dbversion" ];
   then
      EXP_TEXT='NoVersion'
   else
      EXP_TEXT=$( echo "${DBVERSION}" | tr '[:lower:]' '[:upper:]' )
fi

sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@${DBNAME}

whenever sqlerror exit failure commit;
whenever oserror exit failure commit;
set sqlblanklines on;
set serveroutput on;

Begin
schema_save.EXPORT(SCHEMA=>'${DBSCHEMA}',FreeText=>'ORAddlDeploy_Save_${EXP_TEXT}') ;

EXCEPTION
   WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR
      (-20005,'- SchemaSave Export Error');
End;
/
EOT
RC4=$?

if [ ${RC4} -gt 0 ]
   then
     logger_error "*************************************************************"
     logger_error "* Fehler beim Datapump Export"
     logger_error "* Siehe ${SYSOUT}"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
     remove_tmpfiles
     exit ${RC}
fi

END_TIME_SCRIPT=$(date +%s);
ELAPSED_TIME_SCRIPT=$(($END_TIME_SCRIPT-$START_TIME_SCRIPT));
((sec=ELAPSED_TIME_SCRIPT%60, ELAPSED_TIME_SCRIPT/=60, min=ELAPSED_TIME_SCRIPT%60, hrs=ELAPSED_TIME_SCRIPT/60))
ELAPSED_TIME_SCRIPT=$(printf "%d:%02d:%02d" $hrs $min $sec)
MESSAGE="Elapsed Time DataPumpExport is: "${ELAPSED_TIME_SCRIPT}"."
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
echo "${MESSAGE}";
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Create Guaranteed Restore Point (optionally with a self-defined lifespan)
#-----------------------------------------------------------------------------------------------------------------
function create_restore_point
{
# Create Restore Point must run via SYS User:
SYSUSER=SYS
source $PWDDIR/.pwdfile_db_sys
SYSPASS=${PWDSYS}

#RESTOREPOINT="ORAddlDeploy_${DBVERSION}_${DBSCHEMA}"
RESTOREPOINT="ORAddlDeploy_${DBVERSION}_${FILETS}"
if [ ! -z "$CRERP" ]
then
  RESTOREPOINT="${RESTOREPOINT}_$CRERP"
fi
RC5=0

sqlplus -s ${SYSUSER}/"${SYSPASS}"@${DBNAME} AS SYSDBA <<EOT
set feedback off;
whenever sqlerror exit failure commit;

CREATE RESTORE POINT "${RESTOREPOINT}" GUARANTEE FLASHBACK DATABASE;

exit;
EOT
RC5=$?
if [ ${RC5} -gt 0 ]
   then
     logger_error "*************************************************************"
     logger_error "* Fehler beim CREATE RESTORE POINT: ${RESTOREPOINT}"
     logger_error "* Siehe ${SYSOUT}"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
     remove_tmpfiles
     exit ${RC}
fi

MESSAGE="Guaranteed Restore Point created: ${RESTOREPOINT}"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";
}

#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Execute DDL-Files
#-----------------------------------------------------------------------------------------------------------------
function execute_ddl_files
{
START_TIME_SCRIPT=$(date +%s);

sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@${DBNAME}

SPOOL OFF;
set serveroutput on;
set echo on;
whenever sqlerror exit failure commit;
whenever oserror exit failure commit;
set suffix '';
set sqlblanklines on;
set trimspool on;
set timing on;
SPOOL ./logs/${DBNAME}_${FILENAME}.log;

alter session set current_schema = "${DBSCHEMA}" ;

select 'Database: ' || NAME from V\$DATABASE union all
select 'Schema:   ' || sys_context( 'userenv', 'current_schema' ) from dual union all
select 'DB User:  ' || sys_context('userenv','AUTHENTICATED_IDENTITY') from dual union all
select 'OS User:  ' || sys_context( 'userenv', 'os_user' ) from dual
;

set define off;

start ${FILENAME} ${STAGE_UC};

quit;
EOT
RC1=$?

if [ ${RC1} -gt 0 ]
   then
     logger_error "*************************************************************"
     logger_error "* Fehler bei SQL Ausfuehrung! Skript: ${FILENAME}"
     logger_error "* Siehe ${SYSOUT}"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
     END_TIME_SCRIPT=$(date +%s);
	 	 ELAPSED_TIME_SCRIPT=$(($END_TIME_SCRIPT-$START_TIME_SCRIPT));
	   ((sec=ELAPSED_TIME_SCRIPT%60, ELAPSED_TIME_SCRIPT/=60, min=ELAPSED_TIME_SCRIPT%60, hrs=ELAPSED_TIME_SCRIPT/60))
		 ELAPSED_TIME_SCRIPT=$(printf "%d:%02d:%02d" $hrs $min $sec)
		 if [ "x" == "x$dbversion" ];
     then :
     else
		    write_file_protokoll
		 fi

     END_TIME_ALL=$(date +%s)
     ELAPSED_TIME_ALL=$(($END_TIME_ALL-$START_TIME_ALL))
     ((sec=ELAPSED_TIME_ALL%60, ELAPSED_TIME_ALL/=60, min=ELAPSED_TIME_ALL%60, hrs=ELAPSED_TIME_ALL/60))
     ELAPSED_TIME_ALL=$(printf "%d:%02d:%02d" $hrs $min $sec)
     write_deploy_execution_time
     MESSAGE="* Fehler bei SQL Ausfuehrung! Skript: ${FILENAME} Elapsed Time ${ELAPSED_TIME_SCRIPT}"
     echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
     echo "${MESSAGE}";
     cat ${DDLDEPLOY_RUNLOG} >>./logs/${DBNAME}_Processing_Messages.log
     if [ $CTMRUN -eq 1 ]
        then cat ${SYSOUT}
     fi
     remove_tmpfiles
     exit ${RC}
fi

END_TIME_SCRIPT=$(date +%s);
ELAPSED_TIME_SCRIPT=$(($END_TIME_SCRIPT-$START_TIME_SCRIPT));
((sec=ELAPSED_TIME_SCRIPT%60, ELAPSED_TIME_SCRIPT/=60, min=ELAPSED_TIME_SCRIPT%60, hrs=ELAPSED_TIME_SCRIPT/60))
ELAPSED_TIME_SCRIPT=$(printf "%d:%02d:%02d" $hrs $min $sec)
MESSAGE="Elapsed Time ${FILENAME} is: "${ELAPSED_TIME_SCRIPT}"."
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
echo "${MESSAGE}";
if [ "x" == "x$dbversion" ];
   then :
   else
   write_file_protokoll
fi
}
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Execute DDL-PostProcessing
#-----------------------------------------------------------------------------------------------------------------
function execute_ddl_postproc
{
#logger_info "Execute Postprocessing: ${DDL_POSTPROC_DIR}/${DBSCHEMA}.postproc"
MESSAGE="Execute Postprocessing: ${DDL_POSTPROC_DIR}/${DBSCHEMA}.postproc"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";

sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@${DBNAME}

SPOOL OFF;
set serveroutput on;
set echo on;
whenever sqlerror exit failure commit;
whenever oserror exit failure commit;
set sqlblanklines on;
set trimspool on;
set define on;
SPOOL ./logs/${DBNAME}_PostProcessing.log;
alter session set current_schema = "${DBSCHEMA}" ;

start ${DDL_POSTPROC_DIR}/${DBSCHEMA}.postproc ${STAGE_UC};

quit;
EOT
RC2=$?

if [ ${RC2} -gt 0 ]
   then
     logger_error "*************************************************************"
     logger_error "* Fehler bei SQL Ausfuehrung! Skript: ${DDL_POSTPROC_DIR}/${DBSCHEMA}"
     logger_error "* Siehe ${SYSOUT}"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
     MESSAGE="* Fehler bei SQL Ausfuehrung! Skript: ${DDL_POSTPROC_DIR}/${DBSCHEMA}"
     echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
     cat ${DDLDEPLOY_RUNLOG} >>./logs/${DBNAME}_Processing_Messages.log
     if [ $CTMRUN -eq 1 ]
        then cat ${SYSOUT}
     fi
     remove_tmpfiles
     exit ${RC}
fi

}
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Execute DB Versioning
#-----------------------------------------------------------------------------------------------------------------
function execute_db_versioning
{
#logger_info "Execute DB-Versioning: ${DBVER_APPL} / ${DBVER_MAJOR}.${DBVER_MINOR}.${DBVER_RELCAND} @Stage ${STAGE_UC}"
MESSAGE="Execute DB-Versioning: ${DBVER_APPL} / ${DBVER_MAJOR}.${DBVER_MINOR}.${DBVER_RELCAND} @Stage ${STAGE_UC}"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";
sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@DBA-P

SPOOL OFF;
set serveroutput on;
set echo on;
whenever sqlerror exit failure commit;
whenever oserror exit failure commit;
set sqlblanklines on;
set trimspool on;
--SPOOL ./logs/${DBNAME}_DB_Versioning.log;
SPOOL ${TMP_SPOOL}
set define on;

MERGE INTO BVDBS.TDBS_RELEASEWECHSEL RW1
   USING (SELECT
                 '${DBVER_APPL}'           AS TK_SYS
                ,'${STAGE_UC}'             AS TK_DBK_ENV
                ,${DBVER_MAJOR}            AS IL_REL_MAJ
                ,${DBVER_MINOR}            AS IL_REL_MNOR
                ,${DBVER_RELCAND}          AS IL_REL_CAND
                ,SYSTIMESTAMP              AS DT_AEN
                ,'n/a'                     AS TK_DKT_XREL_OWN
                FROM dual ) RW2
   ON (
            RW1.TK_SYS       = RW2.TK_SYS
        AND RW1.TK_DBK_ENV   = RW2.TK_DBK_ENV
        AND RW1.IL_REL_MAJ   = RW2.IL_REL_MAJ
        AND RW1.IL_REL_MNOR  = RW2.IL_REL_MNOR
        AND RW1.IL_REL_CAND  = RW2.IL_REL_CAND
      )
   WHEN MATCHED THEN UPDATE SET
                 RW1.DT_AEN      = SYSTIMESTAMP
   WHEN NOT MATCHED THEN INSERT ( RW1.TK_SYS
                                 ,RW1.TK_DBK_ENV
                                 ,RW1.IL_REL_MAJ
                                 ,RW1.IL_REL_MNOR
                                 ,RW1.IL_REL_CAND
                                 ,RW1.DT_AEN
                                 ,RW1.TK_DKT_XREL_OWN
                                )
                         VALUES ( RW2.TK_SYS
                                 ,RW2.TK_DBK_ENV
                                 ,RW2.IL_REL_MAJ
                                 ,RW2.IL_REL_MNOR
                                 ,RW2.IL_REL_CAND
                                 ,RW2.DT_AEN
                                 ,RW2.TK_DKT_XREL_OWN
                                )
;
quit;
EOT
RC3=$?

if [ ${RC3} -gt 0 ]
   then
     logger_error "*************************************************************"
     logger_error "* Fehler bei DB Versionierung: ${DBVER_APPL}.${DBVER_MAJOR}.${DBVER_MINOR}.${DBVER_RELCAND} @ ${STAGE_UC}"
     logger_error "* Siehe ${SYSOUT}"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
     MESSAGE="* Fehler bei DB Versionierung: ${DBVER_APPL}.${DBVER_MAJOR}.${DBVER_MINOR}.${DBVER_RELCAND} @ ${STAGE_UC}"
     echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
     cat ${DDLDEPLOY_RUNLOG} >>./logs/${DBNAME}_Processing_Messages.log
     remove_tmpfiles
     exit ${RC}
fi

grep -Ec "SP2-[0-9][0-9][0-9][0-9]" ${SYSOUT} >/dev/null 2>&1
if [ $? -eq 0 ]
   then
     logger_error "*************************************************************"
     logger_error "* Fehler bei SQL-Plus Ausfuehrung! SQL/Plus SP2 Fehler"
     logger_error "* Siehe ${SYSOUT}"
     RC=1
     logger_error "* RC=$RC"
     logger_error "*************************************************************"
fi
}
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: Write ELAPSED_TIME_ALL to Table BVDBS.TDBS_RELEASE_LAUFZEITEN @ DBAP
#-----------------------------------------------------------------------------------------------------------------
function write_deploy_execution_time
{
sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@DBA-P

SPOOL OFF;
set serveroutput on;
set echo on;
whenever sqlerror exit failure commit;
whenever oserror exit failure commit;
set sqlblanklines on;
set trimspool on;
set define on;

MERGE INTO BVDBS.TDBS_RELEASE_LAUFZEITEN RLFZ1
   USING (SELECT
                 '${DBVER_APPL}'             AS TK_SYS
                ,'${STAGE_UC}'               AS TK_DBK_ENV
                ,${DBVER_MAJOR}              AS IL_REL_MAJ
                ,${DBVER_MINOR}              AS IL_REL_MNOR
                ,'${ELAPSED_TIME_ALL}'||'; ' AS IL_DEPLOY_LAUFZEIT
                FROM dual ) RLFZ2
   ON (
            RLFZ1.TK_SYS       = RLFZ2.TK_SYS
        AND RLFZ1.TK_DBK_ENV   = RLFZ2.TK_DBK_ENV
        AND RLFZ1.IL_REL_MAJ   = RLFZ2.IL_REL_MAJ
        AND RLFZ1.IL_REL_MNOR  = RLFZ2.IL_REL_MNOR
      )
   WHEN MATCHED THEN UPDATE SET
                 RLFZ1.IL_DEPLOY_LAUFZEIT      = RLFZ1.IL_DEPLOY_LAUFZEIT || '${ELAPSED_TIME_ALL}'||'; '
   WHEN NOT MATCHED THEN INSERT ( RLFZ1.TK_SYS
                                 ,RLFZ1.TK_DBK_ENV
                                 ,RLFZ1.IL_REL_MAJ
                                 ,RLFZ1.IL_REL_MNOR
                                 ,RLFZ1.IL_DEPLOY_LAUFZEIT
                                )
                         VALUES ( RLFZ2.TK_SYS
                                 ,RLFZ2.TK_DBK_ENV
                                 ,RLFZ2.IL_REL_MAJ
                                 ,RLFZ2.IL_REL_MNOR
                                 ,'${ELAPSED_TIME_ALL}'||'; '
                                )
;
quit;
EOT
RC3=$?

if [ ${RC3} -gt 0 ]
   then
     MESSAGE="Deploy Elapsed Zeit konnte nicht in Release-Tabelle geschrieben werden. Ausfuehrung wird ohne Fehler beendet."
     echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
     logger_info "${MESSAGE}";
     logger_info "* Siehe ${SYSOUT}"
#     remove_tmpfiles
#     exit 0
fi
grep -Ec "SP2-[0-9][0-9][0-9][0-9]" ${SYSOUT} >/dev/null 2>&1
if [ $? -eq 0 ]
   then
     MESSAGE="Deploy Elapsed Zeit konnte nicht in Release-Tabelle geschrieben werden. Ausfuehrung wird ohne Fehler beendet."
     echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
     logger_info "${MESSAGE}";
     logger_info "* Siehe ${SYSOUT}"
fi
}
#------------------------------------------------------------------------------------------------------------------------------
#     FUNCTION: Write Filename, Returncode and Laufzeit(ELAPSED_TIME_SKRIPT) to Table BVDBS.TDBS_RELEASE_FILE_PROTOKOLL @ DBAP
#-----------------------------------------------------------------------------------------------------------------------------
function write_file_protokoll
{
sqlplus /nolog <<EOT >> ${SYSOUT} 2>&1
connect ${DBAUSER}/"${DBAPASS}"@DBA-P

SPOOL OFF;
set serveroutput on;
set echo on;
whenever sqlerror exit failure commit;
whenever oserror exit failure commit;
set sqlblanklines on;
set trimspool on;
set define on;

INSERT INTO BVDBS.TDBS_RELEASE_FILE_PROTOKOLL RFP1
  (
   RFP1.TK_SYS
  ,RFP1.TK_DBK_ENV
  ,RFP1.IL_REL_MAJ
  ,RFP1.IL_REL_MNOR
  ,RFP1.SCRIPT_NAME
  ,RFP1.SCRIPT_DIR
  ,RFP1.RETURNCODE
  ,RFP1.LAUFZEIT
  ,RFP1.AUSFUEHRUNGSZEIT
  ,RFP1.IL_REL_CAND
  )
  VALUES (
   '${DBVER_APPL}'
  ,'${STAGE_UC}'
  ,${DBVER_MAJOR}
  ,${DBVER_MINOR}
  ,'${FILENAME}'
  ,'${INPUTDIR}'
  ,${RC}
  ,'${ELAPSED_TIME_SCRIPT}'
  ,SYSTIMESTAMP
  ,'${TMP_REL_CAND}'
  )
;
quit;
EOT
RC3=$?

if [ ${RC3} -gt 0 ]
   then
     MESSAGE="Daten konnten nicht in RELEASE_FILE_PROTOKOLL-Tabelle geschrieben werden. Ausfuehrung wird ohne Fehler beendet."
     echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
     logger_info "${MESSAGE}";
     logger_info "* Siehe ${SYSOUT}"
fi
grep -Ec "SP2-[0-9][0-9][0-9][0-9]" ${SYSOUT} >/dev/null 2>&1
if [ $? -eq 0 ]
   then
     MESSAGE="Deploy Elapsed Zeit konnte nicht in RELEASE_FILE_PROTOKOLL-Tabelle geschrieben werden. Ausfuehrung wird ohne Fehler beendet."
     echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
     logger_info "${MESSAGE}";
     logger_info "* Siehe ${SYSOUT}"
fi
}
#-----------------------------------------------------------------------------------------------------------------
#     FUNCTION: LOG in Report-Safe sichern:
#-----------------------------------------------------------------------------------------------------------------
function save_log_2_reportsafe
{
HOSTNAME=`hostname`
#ERRFIL=/tmp/${SCRIPTNAME}_${DBVER_APPL}_${FILETS}.err
ERRFIL="/tmp/${SCRIPTNAME}_RepSafeError_${DBNAME}_${DBVER_APPL}_${FILETS}.err"

lpr  -P REPLOG -J DB_PROD_DDL_Deploy-${FILETS} ${SYSOUT} >$ERRFIL 2>&1
echo "*************************************************************"
echo "* Folgende Zeile in Consol-Ticket als Bemerkung eintragen:"
echo "* Protokollierung in ReportSafe: Folder: PublicFolder/Project_Sysout/DBA_PROD, Report = DB_PROD_DDL_Deploy-${FILETS}"
echo "*************************************************************"
if [ -s $ERRFIL ]
then
ERROUT=`cat $ERRFIL`
mail -s "DDL Deploy Logfilesicherung" unix-dba\@barmenia.de <<EOT
Das nachfolgend genannte Logfile konnte nicht nach ReportSafe uebertragen werden!

Hostname: $HOSTNAME
Logfile:  DB_PROD_DDLdeploy-${FILETS}

die Fehlermeldung ist:
$ERROUT

Wenn der Fehler behoben ist kann das Logfile mittels

lpr  -P REPLOG -J DB_PROD_DDL_Deploy-${FILETS} ${SYSOUT}

manuell nach ReportSafe uebertragen werden!
EOT
logger_info "SYSOUT konnte nicht nach ReportSafe geschrieben werden; siehe Mail an unix-dba!";
fi
rm $ERRFIL
}
#-----------------------------------------------------------------------------------------------------------------
##     FUNCTION: REMOVE 4 log/err Files:
##-----------------------------------------------------------------------------------------------------------------
function remove_tmpfiles
{
#echo $DDLDEPLOY_RUNLOG
#echo $ERRFIL
#echo $RCLISTE
#echo $TMP_SPOOL
if [ -f "$DDLDEPLOY_RUNLOG" ]; then	rm  "$DDLDEPLOY_RUNLOG";
fi
if [ -f "$ERRFIL" ];           then rm  "$ERRFIL";
fi
if [ -f "$RCLISTE" ];          then rm  "$RCLISTE"
fi
if [ -f "$TMP_SPOOL" ];        then rm  "$TMP_SPOOL"
fi
}
#-----------------------------------------------------------------------------------------------------------------
#     END of FUNCTION SECTION
#-----------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------
#     Get Parameter
#-----------------------------------------------------------------------------------------------------------------
#set -x
DB_OS="-db"; DB_OL="--db_name";            DB_OPT="$DB_OS[|$DB_OL]"
S_OS="-s"; S_OL="--schema";                S_OPT="$S_OS[|$S_OL]"
I_OS="-i"; I_OL="--indir";                 I_OPT="$I_OS[|$I_OL]"
FP_OS="-fp"; FP_OL="--filepref";           FP_OPT="$FP_OS[|$FP_OL]"
V_OS="-v"; V_OL="--dbversion";             V_OPT="$V_OS[|$V_OL]"
NP_OS="-np"; NP_OL="--nopostproc";         NP_OPT="$NP_OS[|$NP_OL]"
NODDL_OS="-noddl"; NODDL_OL="--noddlproc"; NODDL_OPT="$NODDL_OS[|$NODDL_OL]"
X_OS="-x"; X_OL="--dpexp";                 X_OPT="$X_OS[|$X_OL]"
CRP_OS="-crp"; CRP_OL="--crerestpoint";    CRP_OPT="$CRP_OS[|$CRP_OL]"
H_OS="-h"; H_OL="-?";                      H_OPT="$H_OS[|$H_OL]"
CTM_OS="-ctm"; CTM_OL="--controlm";        CTM_OPT="$CTM_OS[|$CTM_OL]"


help=0
if [ $# -eq 0 ]
then
   usage
else
  while [ $# -gt 0 ]; do
    case "$1" in
      $DB_OS | $DB_OL )
        DBNAME="$2"
        DBNAME=`echo $DBNAME|tr [a-z] [A-Z]`
        DBNAME_LC=`echo $DBNAME|tr [A-Z] [a-z]`
        dbname=1
        shift 2;;
      $S_OS | $S_OL )
        DBSCHEMA="$2"
        DBSCHEMA=`echo $DBSCHEMA|tr [a-z] [A-Z]`
        dbschema=1
        shift 2;;
      $I_OS | $I_OL )
        INPUTDIR="$2"
        inputdir=1
        shift 2;;
      $FP_OS | $FP_OL )
        FILEPREF="${2}*"
        filepref=1
        shift 2;;
      $V_OS | $V_OL )
        DBVERSION="${2}"
        dbversion=1
        shift 2;;
      $NP_OS | $NP_OL )
        nopostproc=1
        shift 1;;
      $NODDL_OS | $NODDL_OL )
        noddlproc=1
        shift 1;;
      $X_OS | $X_OL )
        dpexport=1
        shift 1;;
      $CRP_OS | $CRP_OL )
        next_opt="$2"
        if [ "${next_opt%${next_opt#?}}" = '-' ] || [ "$2" = "" ]; then
          crerp=1
        elif [ ! $(expr match $next_opt "[0-9][0-9]*[hd]") = 0 ]; then
          crerp=2
          CRERP=$next_opt
        fi
        shift $crerp;;
      $CTM_OS | $CTM_OL)
        CTMRUN=2
        shift 1;;
      $H_OS | $H_OL )
        help=1
        usage;;
      * )
        echo "*************************************************************"
        echo "* Parameter Error at '$1'"
        echo "*************************************************************"
        usage;;
    esac
  done
fi
#-----------------------------------------------------------------------------------------------------------------
#     test to see if they gave the mandatory options
#-----------------------------------------------------------------------------------------------------------------
if [ "x" == "x$dbname" ]; then
  MESSAGE="$DB_OPT Option is required!"
  logger_error "$MESSAGE"
  remove_tmpfiles
  exit 1
fi
if [ "x" == "x$dbschema" ]; then
  MESSAGE="$S_OPT Option is required!"
  logger_error "$MESSAGE"
  remove_tmpfiles
  exit 1
fi
if [ "x" == "x$inputdir" ]; then
  MESSAGE="$I_OPT Option is required!"
  logger_error "$MESSAGE"
  remove_tmpfiles
  exit 1
fi
#-----------------------------------------------------------------------------------------------------------------
#     evaluate conditional options
#-----------------------------------------------------------------------------------------------------------------
if [ "x" == "x$filepref" ]; then
      FILEPREF=rc\*
fi

if [ "x" == "x$dbversion" ];
  then :
  else
    DBVER_APPL=$(echo "${DBVERSION}"|cut -d"." -f1)
    DBVERSIONC=$( echo "$DBVERSION" | sed -e "s/^${DBVER_APPL}//" )
    DBVER_APPL=$( echo "$DBVER_APPL" | tr '[:lower:]' '[:upper:]' )
    DBVERSIONC=$( echo "$DBVERSIONC" | sed -e "s/^.//" )
    DBVER_MAJOR=$(echo "${DBVERSIONC}"|cut -d"." -f1)
    DBVERSIONC=$( echo "$DBVERSIONC" | sed -e "s/^${DBVER_MAJOR}//" )
    DBVERSIONC=$( echo "$DBVERSIONC" | sed -e "s/^.//" )
    DBVER_MINOR=$(echo "${DBVERSIONC}"|cut -d"." -f1)
    if [ "x" == "x${DBVER_APPL}" ] || [ "x" == "x${DBVER_MAJOR}" ] || [ "x" == "x${DBVER_MINOR}" ]; then
      MESSAGE="Invalid  specification of $V_OPT Option. Format: xxx.m.n"
      logger_error "$MESSAGE"
      remove_tmpfiles
      exit 1
    fi
fi
#-----------------------------------------------------------------------------------------------------------------
#     build STAGE from DBNAME (TNS-Service Name)
#-----------------------------------------------------------------------------------------------------------------
#STAGE_UC=`echo $DBNAME|rev|cut -c 1`
STAGE_UC=`echo $DBNAME|cut -d "-" -f 2`
STAGE_UC=$( echo "$STAGE_UC" | tr '[:lower:]' '[:upper:]' )
STAGE_LC=$( echo "$STAGE_UC" | tr '[:upper:]' '[:lower:]' )

#-----------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------
#     Main Processing
#-----------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------

#DDLDEPLOY_RUNLOG="/tmp/ddldeploy_runlog_${DBNAME}_${DBVER_APPL}_"`date +%s`
DDLDEPLOY_RUNLOG="/tmp/${SCRIPTNAME}_RunLog_${DBNAME}_${DBVER_APPL}__${FILETS}.tmp"

echo "" >> ${DDLDEPLOY_RUNLOG}
echo "Run from: "`date` >> ${DDLDEPLOY_RUNLOG}
echo "" >> ${DDLDEPLOY_RUNLOG}


#logger_info "Input DIR:        ${INPUTDIR}";
MESSAGE="Input DIR:        ${INPUTDIR}"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";

#logger_info "Database:         ${DBNAME}  ";
MESSAGE="Database:         ${DBNAME}  "
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";

#logger_info "Stage:            ${STAGE_UC}";
MESSAGE="Stage:            ${STAGE_UC}"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";

#logger_info "Schema:           ${DBSCHEMA}";
MESSAGE="Schema:           ${DBSCHEMA}"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";

#logger_info "FilePrefix:       ${FILEPREF}";
MESSAGE="FilePrefix:       ${FILEPREF}"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";

#logger_info "DB Version:       ${DBVER_APPL}.${DBVER_MAJOR}.${DBVER_MINOR}";
MESSAGE="DB Version:       ${DBVER_APPL}.${DBVER_MAJOR}.${DBVER_MINOR}"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";

if [ "x1" == "x$dpexport" ]; then MESSAGE="Datapump Export:  ON";   echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
                             else MESSAGE="Datapump Export:  OFF";  echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
fi
if [ "x1" == "x$crerp" ] || [ "x2" == "x$crerp" ]; then MESSAGE="Guaranteed Restore Point requested";   echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
                                                   else MESSAGE="No Restore Point requested";  echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
fi
if [ "x" == "x$nopostproc" ]; then MESSAGE="PostProcessing:   ON";  echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
                              else MESSAGE="PostProcessing:   OFF"; echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
fi
if [ "x" == "x$noddlproc" ]; then MESSAGE="DDL-Processing:   ON";   echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
                             else MESSAGE="DDL-Processing:   OFF";  echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
fi
check_if_started_by_ctm
if [ $CTMRUN -eq 1 ]
   then MESSAGE="Script wurde aus Control-M heraus gestartet.";   echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
   elif [ $CTMRUN -eq 2 ]
   then MESSAGE="Script wurde mit -ctm Option gestartet.";        echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}"; CTMRUN=1;
   else MESSAGE="Script wurde manuell gestartet.";                echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}; logger_info "${MESSAGE}";
fi
echo " "

rm -f ${SYSOUT}
SYSOUT=${DDL_DEPLOY_SYSOUT}/${SCRIPTNAME}-SYSOUT-${DBNAME}-${FILETS}.log

get_user_and_pwd

# Change Ownership of Log-Files to "oinstall":
for LOGFILES in `find ${DDL_DEPLOY_SYSOUT} -name "${SCRIPTNAME}*" -user "$USER" -group barmstaf`
do
chgrp oinstall $LOGFILES
done

cd ${INPUTDIR}
if [ ! -d ${INPUTDIR}/logs ];
then
    umask 0002
    mkdir ${INPUTDIR}/logs
fi

#logger_info "All actions are logged in ${SYSOUT}!"
MESSAGE="All actions are logged in ${SYSOUT}!"
echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
logger_info "${MESSAGE}";

echo " "
RC=0

# Build list of ReleaseCandidates from Filename Prefix:
#RCLISTE="/tmp/ddl_rc_liste_${DBNAME}_${DBVER_APPL}_"`date +%s`
RCLISTE="/tmp/${SCRIPTNAME}_RC_LIST_${DBNAME}_${DBVER_APPL}_${FILETS}.tmp"

START_TIME_ALL=$(date +%s);



# Test exit
#remove_tmpfiles
#exit



#------------------------------------------------------
#-- Run Datapump Export before DDL-Deploy
#------------------------------------------------------

if [ "x1" == "x$dpexport" ]
then
   execute_datapump_export;
fi

#------------------------------------------------------
#-- Create Guaranteed Restore Point
#------------------------------------------------------

if [ "x1" == "x$crerp" ] || [ "x2" == "x$crerp" ]
then
   create_restore_point;
fi

#------------------------------------------------------
#-- Loop through files prefixed by $FILEPREF:
#------------------------------------------------------
#set -x

if [ "`ls -l ${FILEPREF} 2>/dev/null|grep -v "^total"|wc -l`" -gt "0" ]
then

   for FILENAME in ${FILEPREF}
   do

   # Get DDL ReleaseCandidates from Filename (3.Position) if DB-Versioning is desired:
   if [ "x$dbversion" == "x1" ] && [ ${FILENAME:0:2} == "rc" ] && echo "${FILENAME:2:1}" | grep -q '[0-9]'
   then
      echo ${FILENAME} | cut -c3-3 >>${RCLISTE}
#     Use Release Candidat to save in TDBS_RELEASE_FILE_PROTOKOLL Table:
      TMP_REL_CAND=${FILENAME:2:1}
   fi

   if [ "x" == "x$noddlproc" ]
   then
      det_sql_file_encoding

      execute_ddl_files
   fi

   done
fi

# Write DDL ReleaseCandidates unique to File:
if [ -s ${RCLISTE} ]
then
   cat ${RCLISTE} | sort | uniq >${RCLISTE}_uniq; mv ${RCLISTE}_uniq ${RCLISTE}
else
   dbversion=0
fi

#------------------------------------------------------
#-- Run DDL Post-Processing (GRANTS, CREATE SYNONYMS):
#------------------------------------------------------

if [ "x" == "x$nopostproc" ]
then
   execute_ddl_postproc;
else
   logger_info "PostProcessing is suppressed!";
fi

#------------------------------------------------------
#-- Execute DB Versioning for each ReleaseCandidate:
#------------------------------------------------------

rm -f ./logs/${DBNAME}_DB_Versioning.log
#TMP_SPOOL="/tmp/ddl_versioning_${DBNAME}_${DBVER_APPL}_"`date +%s`".log"
TMP_SPOOL="/tmp/${SCRIPTNAME}_VersioningSpool_${DBNAME}_${DBVER_APPL}_${FILETS}.tmp"
if [ "x$dbversion" == "x1" ]
then
   for DBVER_RELCAND in $(cat ${RCLISTE})
   do
       execute_db_versioning
       cat ${TMP_SPOOL} >>./logs/${DBNAME}_DB_Versioning.log
   done;
rm ${TMP_SPOOL}
rm ${RCLISTE}

fi

#-----------------------------------------------------------------------------------------------------------------
#-- End-Processing
#-----------------------------------------------------------------------------------------------------------------

# Print out the SYSOUT file only if Script has bin started by Control-M or the PRINTOUT Parameter has been set:
if [ $CTMRUN -eq 1 ] || [ $PRINTOUT -eq 1 ]
   then
     cat ${SYSOUT}
fi

# Write SYSOUT file to Report-Safe only if Script has been started manually, did run successfully, and only at P-Stage:
if [ $CTMRUN -eq 0 ] && [ $RC -eq 0 ]
   then
     if [[ $STAGE_UC == 'P' || $STAGE_UC == 'PDMZ' ]]
        then
          logger_info "$SCRIPTNAME Output wird nach ReportSafe geschrieben.";
          save_log_2_reportsafe
     fi
fi



if [ ${RC} -gt 0 ]
  then
    logger_error "$SCRIPTNAME beendet: RC=${RC}";
  else
    END_TIME_ALL=$(date +%s)
    ELAPSED_TIME_ALL=$(($END_TIME_ALL-$START_TIME_ALL))
    ((sec=ELAPSED_TIME_ALL%60, ELAPSED_TIME_ALL/=60, min=ELAPSED_TIME_ALL%60, hrs=ELAPSED_TIME_ALL/60))
    ELAPSED_TIME_ALL=$(printf "%d:%02d:%02d" $hrs $min $sec)
    MESSAGE="Elapsed Time over all is: "${ELAPSED_TIME_ALL}"."
    echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
    echo "${MESSAGE}"
    MESSAGE="$SCRIPTNAME beendet: RC=${RC}"
    echo "${MESSAGE}" >> ${DDLDEPLOY_RUNLOG}
    logger_info "${MESSAGE}";
#   Write Script Execution Time to Table, if Runtime is greater than 1 Min.:
    if [ "x$dbversion" == "x1" ]
      then
      if [ $min -gt 0 ] || [ $hrs -gt 0 ]; then
        write_deploy_execution_time
      fi
    fi
fi


# Print out the DDL Deploy Messages to the DDL Script Log Directory:

cat ${DDLDEPLOY_RUNLOG} >>./logs/${DBNAME}_Processing_Messages.log
#rm -f ${DDLDEPLOY_RUNLOG}

#

## Cleanup log-files older than DELDAY days:
DELDAY="+7"        # Anzahl Tage fuers lueschen alter log Daten
find ${DDL_DEPLOY_SYSOUT}/ -name "${SCRIPTNAME}*.*" -mtime ${DELDAY} -type f -exec rm -f {} \;

remove_tmpfiles
exit ${RC}
